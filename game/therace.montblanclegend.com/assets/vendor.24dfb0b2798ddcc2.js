//  Merci-Michel [R]
//  https://www.merci-michel.com/
//  Build 20220509-171726

var e = Object.defineProperty,
	t = Object.defineProperties,
	n = Object.getOwnPropertyDescriptors,
	i = Object.getOwnPropertySymbols,
	r = Object.prototype.hasOwnProperty,
	s = Object.prototype.propertyIsEnumerable,
	a = (t, n, i) => n in t ? e(t, n, {
		enumerable: !0,
		configurable: !0,
		writable: !0,
		value: i
	}) : t[n] = i,
	o = (e, t) => {
		for (var n in t || (t = {})) r.call(t, n) && a(e, n, t[n]);
		if (i)
			for (var n of i(t)) s.call(t, n) && a(e, n, t[n]);
		return e
	},
	l = (e, i) => t(e, n(i));

function c(e, t) {
	const n = Object.create(null),
		i = e.split(",");
	for (let r = 0; r < i.length; r++) n[i[r]] = !0;
	return t ? e => !!n[e.toLowerCase()] : e => !!n[e]
}
const u = c("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");

function h(e) {
	return !!e || "" === e
}

function d(e) {
	if (D(e)) {
		const t = {};
		for (let n = 0; n < e.length; n++) {
			const i = e[n],
				r = F(i) ? m(i) : d(i);
			if (r)
				for (const e in r) t[e] = r[e]
		}
		return t
	}
	return F(e) || U(e) ? e : void 0
}
const p = /;(?![^(]*\))/g,
	f = /:(.+)/;

function m(e) {
	const t = {};
	return e.split(p).forEach((e => {
		if (e) {
			const n = e.split(f);
			n.length > 1 && (t[n[0].trim()] = n[1].trim())
		}
	})), t
}

function g(e) {
	let t = "";
	if (F(e)) t = e;
	else if (D(e))
		for (let n = 0; n < e.length; n++) {
			const i = g(e[n]);
			i && (t += i + " ")
		} else if (U(e))
			for (const n in e) e[n] && (t += n + " ");
	return t.trim()
}

function v(e, t) {
	if (e === t) return !0;
	let n = N(e),
		i = N(t);
	if (n || i) return !(!n || !i) && e.getTime() === t.getTime();
	if (n = D(e), i = D(t), n || i) return !(!n || !i) && function(e, t) {
		if (e.length !== t.length) return !1;
		let n = !0;
		for (let i = 0; n && i < e.length; i++) n = v(e[i], t[i]);
		return n
	}(e, t);
	if (n = U(e), i = U(t), n || i) {
		if (!n || !i) return !1;
		if (Object.keys(e).length !== Object.keys(t).length) return !1;
		for (const n in e) {
			const i = e.hasOwnProperty(n),
				r = t.hasOwnProperty(n);
			if (i && !r || !i && r || !v(e[n], t[n])) return !1
		}
	}
	return String(e) === String(t)
}

function _(e, t) {
	return e.findIndex((e => v(e, t)))
}
const y = e => null == e ? "" : D(e) || U(e) && (e.toString === V || !O(e.toString)) ? JSON.stringify(e, x, 2) : String(e),
	x = (e, t) => t && t.__v_isRef ? x(e, t.value) : R(t) ? {
		[`Map(${t.size})`]: [...t.entries()].reduce(((e, [t, n]) => (e[`${t} =>`] = n, e)), {})
	} : k(t) ? {
		[`Set(${t.size})`]: [...t.values()]
	} : !U(t) || D(t) || G(t) ? t : String(t),
	b = {},
	w = [],
	S = () => {},
	M = () => !1,
	T = /^on[^a-z]/,
	C = e => T.test(e),
	E = e => e.startsWith("onUpdate:"),
	A = Object.assign,
	P = (e, t) => {
		const n = e.indexOf(t);
		n > -1 && e.splice(n, 1)
	},
	L = Object.prototype.hasOwnProperty,
	I = (e, t) => L.call(e, t),
	D = Array.isArray,
	R = e => "[object Map]" === H(e),
	k = e => "[object Set]" === H(e),
	N = e => e instanceof Date,
	O = e => "function" == typeof e,
	F = e => "string" == typeof e,
	z = e => "symbol" == typeof e,
	U = e => null !== e && "object" == typeof e,
	B = e => U(e) && O(e.then) && O(e.catch),
	V = Object.prototype.toString,
	H = e => V.call(e),
	G = e => "[object Object]" === H(e),
	W = e => F(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
	q = c(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
	j = e => {
		const t = Object.create(null);
		return n => t[n] || (t[n] = e(n))
	},
	Y = /-(\w)/g,
	X = j((e => e.replace(Y, ((e, t) => t ? t.toUpperCase() : "")))),
	$ = /\B([A-Z])/g,
	Z = j((e => e.replace($, "-$1").toLowerCase())),
	K = j((e => e.charAt(0).toUpperCase() + e.slice(1))),
	J = j((e => e ? `on${K(e)}` : "")),
	Q = (e, t) => !Object.is(e, t),
	ee = (e, t) => {
		for (let n = 0; n < e.length; n++) e[n](t)
	},
	te = (e, t, n) => {
		Object.defineProperty(e, t, {
			configurable: !0,
			enumerable: !1,
			value: n
		})
	},
	ne = e => {
		const t = parseFloat(e);
		return isNaN(t) ? e : t
	};
let ie;
let re;
const se = [];
class ae {
	constructor(e = !1) {
		this.active = !0, this.effects = [], this.cleanups = [], !e && re && (this.parent = re, this.index = (re.scopes || (re.scopes = [])).push(this) - 1)
	}
	run(e) {
		if (this.active) try {
			return this.on(), e()
		} finally {
			this.off()
		}
	}
	on() {
		this.active && (se.push(this), re = this)
	}
	off() {
		this.active && (se.pop(), re = se[se.length - 1])
	}
	stop(e) {
		if (this.active) {
			if (this.effects.forEach((e => e.stop())), this.cleanups.forEach((e => e())), this.scopes && this.scopes.forEach((e => e.stop(!0))), this.parent && !e) {
				const e = this.parent.scopes.pop();
				e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index)
			}
			this.active = !1
		}
	}
}
const oe = e => {
		const t = new Set(e);
		return t.w = 0, t.n = 0, t
	},
	le = e => (e.w & de) > 0,
	ce = e => (e.n & de) > 0,
	ue = new WeakMap;
let he = 0,
	de = 1;
const pe = [];
let fe;
const me = Symbol(""),
	ge = Symbol("");
class ve {
	constructor(e, t = null, n) {
		this.fn = e, this.scheduler = t, this.active = !0, this.deps = [],
			function(e, t) {
				(t = t || re) && t.active && t.effects.push(e)
			}(this, n)
	}
	run() {
		if (!this.active) return this.fn();
		if (!pe.includes(this)) try {
			return pe.push(fe = this), xe.push(ye), ye = !0, de = 1 << ++he, he <= 30 ? (({
				deps: e
			}) => {
				if (e.length)
					for (let t = 0; t < e.length; t++) e[t].w |= de
			})(this) : _e(this), this.fn()
		} finally {
			he <= 30 && (e => {
				const {
					deps: t
				} = e;
				if (t.length) {
					let n = 0;
					for (let i = 0; i < t.length; i++) {
						const r = t[i];
						le(r) && !ce(r) ? r.delete(e) : t[n++] = r, r.w &= ~de, r.n &= ~de
					}
					t.length = n
				}
			})(this), de = 1 << --he, we(), pe.pop();
			const e = pe.length;
			fe = e > 0 ? pe[e - 1] : void 0
		}
	}
	stop() {
		this.active && (_e(this), this.onStop && this.onStop(), this.active = !1)
	}
}

function _e(e) {
	const {
		deps: t
	} = e;
	if (t.length) {
		for (let n = 0; n < t.length; n++) t[n].delete(e);
		t.length = 0
	}
}
let ye = !0;
const xe = [];

function be() {
	xe.push(ye), ye = !1
}

function we() {
	const e = xe.pop();
	ye = void 0 === e || e
}

function Se(e, t, n) {
	if (!Me()) return;
	let i = ue.get(e);
	i || ue.set(e, i = new Map);
	let r = i.get(n);
	r || i.set(n, r = oe()), Te(r)
}

function Me() {
	return ye && void 0 !== fe
}

function Te(e, t) {
	let n = !1;
	he <= 30 ? ce(e) || (e.n |= de, n = !le(e)) : n = !e.has(fe), n && (e.add(fe), fe.deps.push(e))
}

function Ce(e, t, n, i, r, s) {
	const a = ue.get(e);
	if (!a) return;
	let o = [];
	if ("clear" === t) o = [...a.values()];
	else if ("length" === n && D(e)) a.forEach(((e, t) => {
		("length" === t || t >= i) && o.push(e)
	}));
	else switch (void 0 !== n && o.push(a.get(n)), t) {
		case "add":
			D(e) ? W(n) && o.push(a.get("length")) : (o.push(a.get(me)), R(e) && o.push(a.get(ge)));
			break;
		case "delete":
			D(e) || (o.push(a.get(me)), R(e) && o.push(a.get(ge)));
			break;
		case "set":
			R(e) && o.push(a.get(me))
	}
	if (1 === o.length) o[0] && Ee(o[0]);
	else {
		const e = [];
		for (const t of o) t && e.push(...t);
		Ee(oe(e))
	}
}

function Ee(e, t) {
	for (const n of D(e) ? e : [...e])(n !== fe || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run())
}
const Ae = c("__proto__,__v_isRef,__isVue"),
	Pe = new Set(Object.getOwnPropertyNames(Symbol).map((e => Symbol[e])).filter(z)),
	Le = Ne(),
	Ie = Ne(!1, !0),
	De = Ne(!0),
	Re = ke();

function ke() {
	const e = {};
	return ["includes", "indexOf", "lastIndexOf"].forEach((t => {
		e[t] = function(...e) {
			const n = _t(this);
			for (let t = 0, r = this.length; t < r; t++) Se(n, 0, t + "");
			const i = n[t](...e);
			return -1 === i || !1 === i ? n[t](...e.map(_t)) : i
		}
	})), ["push", "pop", "shift", "unshift", "splice"].forEach((t => {
		e[t] = function(...e) {
			be();
			const n = _t(this)[t].apply(this, e);
			return we(), n
		}
	})), e
}

function Ne(e = !1, t = !1) {
	return function(n, i, r) {
		if ("__v_isReactive" === i) return !e;
		if ("__v_isReadonly" === i) return e;
		if ("__v_raw" === i && r === (e ? t ? ut : ct : t ? lt : ot).get(n)) return n;
		const s = D(n);
		if (!e && s && I(Re, i)) return Reflect.get(Re, i, r);
		const a = Reflect.get(n, i, r);
		if (z(i) ? Pe.has(i) : Ae(i)) return a;
		if (e || Se(n, 0, i), t) return a;
		if (Mt(a)) {
			return !s || !W(i) ? a.value : a
		}
		return U(a) ? e ? pt(a) : dt(a) : a
	}
}

function Oe(e = !1) {
	return function(t, n, i, r) {
		let s = t[n];
		if (!e && (i = _t(i), s = _t(s), !D(t) && Mt(s) && !Mt(i))) return s.value = i, !0;
		const a = D(t) && W(n) ? Number(n) < t.length : I(t, n),
			o = Reflect.set(t, n, i, r);
		return t === _t(r) && (a ? Q(i, s) && Ce(t, "set", n, i) : Ce(t, "add", n, i)), o
	}
}
const Fe = {
		get: Le,
		set: Oe(),
		deleteProperty: function(e, t) {
			const n = I(e, t);
			e[t];
			const i = Reflect.deleteProperty(e, t);
			return i && n && Ce(e, "delete", t, void 0), i
		},
		has: function(e, t) {
			const n = Reflect.has(e, t);
			return z(t) && Pe.has(t) || Se(e, 0, t), n
		},
		ownKeys: function(e) {
			return Se(e, 0, D(e) ? "length" : me), Reflect.ownKeys(e)
		}
	},
	ze = {
		get: De,
		set: (e, t) => !0,
		deleteProperty: (e, t) => !0
	},
	Ue = A({}, Fe, {
		get: Ie,
		set: Oe(!0)
	}),
	Be = e => e,
	Ve = e => Reflect.getPrototypeOf(e);

function He(e, t, n = !1, i = !1) {
	const r = _t(e = e.__v_raw),
		s = _t(t);
	t !== s && !n && Se(r, 0, t), !n && Se(r, 0, s);
	const {
		has: a
	} = Ve(r), o = i ? Be : n ? bt : xt;
	return a.call(r, t) ? o(e.get(t)) : a.call(r, s) ? o(e.get(s)) : void(e !== r && e.get(t))
}

function Ge(e, t = !1) {
	const n = this.__v_raw,
		i = _t(n),
		r = _t(e);
	return e !== r && !t && Se(i, 0, e), !t && Se(i, 0, r), e === r ? n.has(e) : n.has(e) || n.has(r)
}

function We(e, t = !1) {
	return e = e.__v_raw, !t && Se(_t(e), 0, me), Reflect.get(e, "size", e)
}

function qe(e) {
	e = _t(e);
	const t = _t(this);
	return Ve(t).has.call(t, e) || (t.add(e), Ce(t, "add", e, e)), this
}

function je(e, t) {
	t = _t(t);
	const n = _t(this),
		{
			has: i,
			get: r
		} = Ve(n);
	let s = i.call(n, e);
	s || (e = _t(e), s = i.call(n, e));
	const a = r.call(n, e);
	return n.set(e, t), s ? Q(t, a) && Ce(n, "set", e, t) : Ce(n, "add", e, t), this
}

function Ye(e) {
	const t = _t(this),
		{
			has: n,
			get: i
		} = Ve(t);
	let r = n.call(t, e);
	r || (e = _t(e), r = n.call(t, e)), i && i.call(t, e);
	const s = t.delete(e);
	return r && Ce(t, "delete", e, void 0), s
}

function Xe() {
	const e = _t(this),
		t = 0 !== e.size,
		n = e.clear();
	return t && Ce(e, "clear", void 0, void 0), n
}

function $e(e, t) {
	return function(n, i) {
		const r = this,
			s = r.__v_raw,
			a = _t(s),
			o = t ? Be : e ? bt : xt;
		return !e && Se(a, 0, me), s.forEach(((e, t) => n.call(i, o(e), o(t), r)))
	}
}

function Ze(e, t, n) {
	return function(...i) {
		const r = this.__v_raw,
			s = _t(r),
			a = R(s),
			o = "entries" === e || e === Symbol.iterator && a,
			l = "keys" === e && a,
			c = r[e](...i),
			u = n ? Be : t ? bt : xt;
		return !t && Se(s, 0, l ? ge : me), {
			next() {
				const {
					value: e,
					done: t
				} = c.next();
				return t ? {
					value: e,
					done: t
				} : {
					value: o ? [u(e[0]), u(e[1])] : u(e),
					done: t
				}
			},
			[Symbol.iterator]() {
				return this
			}
		}
	}
}

function Ke(e) {
	return function(...t) {
		return "delete" !== e && this
	}
}

function Je() {
	const e = {
			get(e) {
				return He(this, e)
			},
			get size() {
				return We(this)
			},
			has: Ge,
			add: qe,
			set: je,
			delete: Ye,
			clear: Xe,
			forEach: $e(!1, !1)
		},
		t = {
			get(e) {
				return He(this, e, !1, !0)
			},
			get size() {
				return We(this)
			},
			has: Ge,
			add: qe,
			set: je,
			delete: Ye,
			clear: Xe,
			forEach: $e(!1, !0)
		},
		n = {
			get(e) {
				return He(this, e, !0)
			},
			get size() {
				return We(this, !0)
			},
			has(e) {
				return Ge.call(this, e, !0)
			},
			add: Ke("add"),
			set: Ke("set"),
			delete: Ke("delete"),
			clear: Ke("clear"),
			forEach: $e(!0, !1)
		},
		i = {
			get(e) {
				return He(this, e, !0, !0)
			},
			get size() {
				return We(this, !0)
			},
			has(e) {
				return Ge.call(this, e, !0)
			},
			add: Ke("add"),
			set: Ke("set"),
			delete: Ke("delete"),
			clear: Ke("clear"),
			forEach: $e(!0, !0)
		};
	return ["keys", "values", "entries", Symbol.iterator].forEach((r => {
		e[r] = Ze(r, !1, !1), n[r] = Ze(r, !0, !1), t[r] = Ze(r, !1, !0), i[r] = Ze(r, !0, !0)
	})), [e, n, t, i]
}
const [Qe, et, tt, nt] = Je();

function it(e, t) {
	const n = t ? e ? nt : tt : e ? et : Qe;
	return (t, i, r) => "__v_isReactive" === i ? !e : "__v_isReadonly" === i ? e : "__v_raw" === i ? t : Reflect.get(I(n, i) && i in t ? n : t, i, r)
}
const rt = {
		get: it(!1, !1)
	},
	st = {
		get: it(!1, !0)
	},
	at = {
		get: it(!0, !1)
	},
	ot = new WeakMap,
	lt = new WeakMap,
	ct = new WeakMap,
	ut = new WeakMap;

function ht(e) {
	return e.__v_skip || !Object.isExtensible(e) ? 0 : function(e) {
		switch (e) {
			case "Object":
			case "Array":
				return 1;
			case "Map":
			case "Set":
			case "WeakMap":
			case "WeakSet":
				return 2;
			default:
				return 0
		}
	}((e => H(e).slice(8, -1))(e))
}

function dt(e) {
	return e && e.__v_isReadonly ? e : ft(e, !1, Fe, rt, ot)
}

function pt(e) {
	return ft(e, !0, ze, at, ct)
}

function ft(e, t, n, i, r) {
	if (!U(e)) return e;
	if (e.__v_raw && (!t || !e.__v_isReactive)) return e;
	const s = r.get(e);
	if (s) return s;
	const a = ht(e);
	if (0 === a) return e;
	const o = new Proxy(e, 2 === a ? i : n);
	return r.set(e, o), o
}

function mt(e) {
	return gt(e) ? mt(e.__v_raw) : !(!e || !e.__v_isReactive)
}

function gt(e) {
	return !(!e || !e.__v_isReadonly)
}

function vt(e) {
	return mt(e) || gt(e)
}

function _t(e) {
	const t = e && e.__v_raw;
	return t ? _t(t) : e
}

function yt(e) {
	return te(e, "__v_skip", !0), e
}
const xt = e => U(e) ? dt(e) : e,
	bt = e => U(e) ? pt(e) : e;

function wt(e) {
	Me() && ((e = _t(e)).dep || (e.dep = oe()), Te(e.dep))
}

function St(e, t) {
	(e = _t(e)).dep && Ee(e.dep)
}

function Mt(e) {
	return Boolean(e && !0 === e.__v_isRef)
}

function Tt(e) {
	return Ct(e, !1)
}

function Ct(e, t) {
	return Mt(e) ? e : new Et(e, t)
}
class Et {
	constructor(e, t) {
		this._shallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : _t(e), this._value = t ? e : xt(e)
	}
	get value() {
		return wt(this), this._value
	}
	set value(e) {
		e = this._shallow ? e : _t(e), Q(e, this._rawValue) && (this._rawValue = e, this._value = this._shallow ? e : xt(e), St(this))
	}
}

function At(e) {
	return Mt(e) ? e.value : e
}
const Pt = {
	get: (e, t, n) => At(Reflect.get(e, t, n)),
	set: (e, t, n, i) => {
		const r = e[t];
		return Mt(r) && !Mt(n) ? (r.value = n, !0) : Reflect.set(e, t, n, i)
	}
};

function Lt(e) {
	return mt(e) ? e : new Proxy(e, Pt)
}
class It {
	constructor(e, t, n) {
		this._setter = t, this.dep = void 0, this._dirty = !0, this.__v_isRef = !0, this.effect = new ve(e, (() => {
			this._dirty || (this._dirty = !0, St(this))
		})), this.__v_isReadonly = n
	}
	get value() {
		const e = _t(this);
		return wt(e), e._dirty && (e._dirty = !1, e._value = e.effect.run()), e._value
	}
	set value(e) {
		this._setter(e)
	}
}

function Dt(e, t) {
	let n, i;
	const r = O(e);
	r ? (n = e, i = S) : (n = e.get, i = e.set);
	return new It(n, i, r || !i)
}

function Rt(e, t, ...n) {
	const i = e.vnode.props || b;
	let r = n;
	const s = t.startsWith("update:"),
		a = s && t.slice(7);
	if (a && a in i) {
		const e = `${"modelValue"===a?"model":a}Modifiers`,
			{
				number: t,
				trim: s
			} = i[e] || b;
		s ? r = n.map((e => e.trim())) : t && (r = n.map(ne))
	}
	let o, l = i[o = J(t)] || i[o = J(X(t))];
	!l && s && (l = i[o = J(Z(t))]), l && Ji(l, e, 6, r);
	const c = i[o + "Once"];
	if (c) {
		if (e.emitted) {
			if (e.emitted[o]) return
		} else e.emitted = {};
		e.emitted[o] = !0, Ji(c, e, 6, r)
	}
}

function kt(e, t, n = !1) {
	const i = t.emitsCache,
		r = i.get(e);
	if (void 0 !== r) return r;
	const s = e.emits;
	let a = {},
		o = !1;
	if (!O(e)) {
		const i = e => {
			const n = kt(e, t, !0);
			n && (o = !0, A(a, n))
		};
		!n && t.mixins.length && t.mixins.forEach(i), e.extends && i(e.extends), e.mixins && e.mixins.forEach(i)
	}
	return s || o ? (D(s) ? s.forEach((e => a[e] = null)) : A(a, s), i.set(e, a), a) : (i.set(e, null), null)
}

function Nt(e, t) {
	return !(!e || !C(t)) && (t = t.slice(2).replace(/Once$/, ""), I(e, t[0].toLowerCase() + t.slice(1)) || I(e, Z(t)) || I(e, t))
}
Promise.resolve();
let Ot = null,
	Ft = null;

function zt(e) {
	const t = Ot;
	return Ot = e, Ft = e && e.type.__scopeId || null, t
}

function Ut(e) {
	Ft = e
}

function Bt() {
	Ft = null
}

function Vt(e, t = Ot, n) {
	if (!t) return e;
	if (e._n) return e;
	const i = (...n) => {
		i._d && mi(-1);
		const r = zt(t),
			s = e(...n);
		return zt(r), i._d && mi(1), s
	};
	return i._n = !0, i._c = !0, i._d = !0, i
}

function Ht(e) {
	const {
		type: t,
		vnode: n,
		proxy: i,
		withProxy: r,
		props: s,
		propsOptions: [a],
		slots: o,
		attrs: l,
		emit: c,
		render: u,
		renderCache: h,
		data: d,
		setupState: p,
		ctx: f,
		inheritAttrs: m
	} = e;
	let g, v;
	const _ = zt(e);
	try {
		if (4 & n.shapeFlag) {
			const e = r || i;
			g = Li(u.call(e, e, h, s, p, d, f)), v = l
		} else {
			const e = t;
			0, g = Li(e.length > 1 ? e(s, {
				attrs: l,
				slots: o,
				emit: c
			}) : e(s, null)), v = t.props ? l : Gt(l)
		}
	} catch (x) {
		hi.length = 0, Qi(x, e, 1), g = Ti(ci)
	}
	let y = g;
	if (v && !1 !== m) {
		const e = Object.keys(v),
			{
				shapeFlag: t
			} = y;
		e.length && 7 & t && (a && e.some(E) && (v = Wt(v, a)), y = Ci(y, v))
	}
	return n.dirs && (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs), n.transition && (y.transition = n.transition), g = y, zt(_), g
}
const Gt = e => {
		let t;
		for (const n in e)("class" === n || "style" === n || C(n)) && ((t || (t = {}))[n] = e[n]);
		return t
	},
	Wt = (e, t) => {
		const n = {};
		for (const i in e) E(i) && i.slice(9) in t || (n[i] = e[i]);
		return n
	};

function qt(e, t, n) {
	const i = Object.keys(t);
	if (i.length !== Object.keys(e).length) return !0;
	for (let r = 0; r < i.length; r++) {
		const s = i[r];
		if (t[s] !== e[s] && !Nt(n, s)) return !0
	}
	return !1
}

function jt(e, t) {
	if (Hi) {
		let n = Hi.provides;
		const i = Hi.parent && Hi.parent.provides;
		i === n && (n = Hi.provides = Object.create(i)), n[e] = t
	} else;
}

function Yt(e, t, n = !1) {
	const i = Hi || Ot;
	if (i) {
		const r = null == i.parent ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides;
		if (r && e in r) return r[e];
		if (arguments.length > 1) return n && O(t) ? t.call(i.proxy) : t
	}
}
const Xt = [Function, Array],
	$t = {
		name: "BaseTransition",
		props: {
			mode: String,
			appear: Boolean,
			persisted: Boolean,
			onBeforeEnter: Xt,
			onEnter: Xt,
			onAfterEnter: Xt,
			onEnterCancelled: Xt,
			onBeforeLeave: Xt,
			onLeave: Xt,
			onAfterLeave: Xt,
			onLeaveCancelled: Xt,
			onBeforeAppear: Xt,
			onAppear: Xt,
			onAfterAppear: Xt,
			onAppearCancelled: Xt
		},
		setup(e, {
			slots: t
		}) {
			const n = Gi(),
				i = function() {
					const e = {
						isMounted: !1,
						isLeaving: !1,
						isUnmounting: !1,
						leavingVNodes: new Map
					};
					return pn((() => {
						e.isMounted = !0
					})), gn((() => {
						e.isUnmounting = !0
					})), e
				}();
			let r;
			return () => {
				const s = t.default && tn(t.default(), !0);
				if (!s || !s.length) return;
				const a = _t(e),
					{
						mode: o
					} = a,
					l = s[0];
				if (i.isLeaving) return Jt(l);
				const c = Qt(l);
				if (!c) return Jt(l);
				const u = Kt(c, a, i, n);
				en(c, u);
				const h = n.subTree,
					d = h && Qt(h);
				let p = !1;
				const {
					getTransitionKey: f
				} = c.type;
				if (f) {
					const e = f();
					void 0 === r ? r = e : e !== r && (r = e, p = !0)
				}
				if (d && d.type !== ci && (!xi(c, d) || p)) {
					const e = Kt(d, a, i, n);
					if (en(d, e), "out-in" === o) return i.isLeaving = !0, e.afterLeave = () => {
						i.isLeaving = !1, n.update()
					}, Jt(l);
					"in-out" === o && c.type !== ci && (e.delayLeave = (e, t, n) => {
						Zt(i, d)[String(d.key)] = d, e._leaveCb = () => {
							t(), e._leaveCb = void 0, delete u.delayedLeave
						}, u.delayedLeave = n
					})
				}
				return l
			}
		}
	};

function Zt(e, t) {
	const {
		leavingVNodes: n
	} = e;
	let i = n.get(t.type);
	return i || (i = Object.create(null), n.set(t.type, i)), i
}

function Kt(e, t, n, i) {
	const {
		appear: r,
		mode: s,
		persisted: a = !1,
		onBeforeEnter: o,
		onEnter: l,
		onAfterEnter: c,
		onEnterCancelled: u,
		onBeforeLeave: h,
		onLeave: d,
		onAfterLeave: p,
		onLeaveCancelled: f,
		onBeforeAppear: m,
		onAppear: g,
		onAfterAppear: v,
		onAppearCancelled: _
	} = t, y = String(e.key), x = Zt(n, e), b = (e, t) => {
		e && Ji(e, i, 9, t)
	}, w = {
		mode: s,
		persisted: a,
		beforeEnter(t) {
			let i = o;
			if (!n.isMounted) {
				if (!r) return;
				i = m || o
			}
			t._leaveCb && t._leaveCb(!0);
			const s = x[y];
			s && xi(e, s) && s.el._leaveCb && s.el._leaveCb(), b(i, [t])
		},
		enter(e) {
			let t = l,
				i = c,
				s = u;
			if (!n.isMounted) {
				if (!r) return;
				t = g || l, i = v || c, s = _ || u
			}
			let a = !1;
			const o = e._enterCb = t => {
				a || (a = !0, b(t ? s : i, [e]), w.delayedLeave && w.delayedLeave(), e._enterCb = void 0)
			};
			t ? (t(e, o), t.length <= 1 && o()) : o()
		},
		leave(t, i) {
			const r = String(e.key);
			if (t._enterCb && t._enterCb(!0), n.isUnmounting) return i();
			b(h, [t]);
			let s = !1;
			const a = t._leaveCb = n => {
				s || (s = !0, i(), b(n ? f : p, [t]), t._leaveCb = void 0, x[r] === e && delete x[r])
			};
			x[r] = e, d ? (d(t, a), d.length <= 1 && a()) : a()
		},
		clone: e => Kt(e, t, n, i)
	};
	return w
}

function Jt(e) {
	if (sn(e)) return (e = Ci(e)).children = null, e
}

function Qt(e) {
	return sn(e) ? e.children ? e.children[0] : void 0 : e
}

function en(e, t) {
	6 & e.shapeFlag && e.component ? en(e.component.subTree, t) : 128 & e.shapeFlag ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function tn(e, t = !1) {
	let n = [],
		i = 0;
	for (let r = 0; r < e.length; r++) {
		const s = e[r];
		s.type === oi ? (128 & s.patchFlag && i++, n = n.concat(tn(s.children, t))) : (t || s.type !== ci) && n.push(s)
	}
	if (i > 1)
		for (let r = 0; r < n.length; r++) n[r].patchFlag = -2;
	return n
}

function nn(e) {
	return O(e) ? {
		setup: e,
		name: e.name
	} : e
}
const rn = e => !!e.type.__asyncLoader,
	sn = e => e.type.__isKeepAlive;

function an(e, t) {
	ln(e, "a", t)
}

function on(e, t) {
	ln(e, "da", t)
}

function ln(e, t, n = Hi) {
	const i = e.__wdc || (e.__wdc = () => {
		let t = n;
		for (; t;) {
			if (t.isDeactivated) return;
			t = t.parent
		}
		e()
	});
	if (un(t, i, n), n) {
		let e = n.parent;
		for (; e && e.parent;) sn(e.parent.vnode) && cn(i, t, n, e), e = e.parent
	}
}

function cn(e, t, n, i) {
	const r = un(t, e, i, !0);
	vn((() => {
		P(i[t], r)
	}), n)
}

function un(e, t, n = Hi, i = !1) {
	if (n) {
		const r = n[e] || (n[e] = []),
			s = t.__weh || (t.__weh = (...i) => {
				if (n.isUnmounted) return;
				be(), Wi(n);
				const r = Ji(t, n, e, i);
				return qi(), we(), r
			});
		return i ? r.unshift(s) : r.push(s), s
	}
}
const hn = e => (t, n = Hi) => (!Yi || "sp" === e) && un(e, t, n),
	dn = hn("bm"),
	pn = hn("m"),
	fn = hn("bu"),
	mn = hn("u"),
	gn = hn("bum"),
	vn = hn("um"),
	_n = hn("sp"),
	yn = hn("rtg"),
	xn = hn("rtc");

function bn(e, t = Hi) {
	un("ec", e, t)
}
let wn = !0;

function Sn(e) {
	const t = Cn(e),
		n = e.proxy,
		i = e.ctx;
	wn = !1, t.beforeCreate && Mn(t.beforeCreate, e, "bc");
	const {
		data: r,
		computed: s,
		methods: a,
		watch: o,
		provide: l,
		inject: c,
		created: u,
		beforeMount: h,
		mounted: d,
		beforeUpdate: p,
		updated: f,
		activated: m,
		deactivated: g,
		beforeDestroy: v,
		beforeUnmount: _,
		destroyed: y,
		unmounted: x,
		render: b,
		renderTracked: w,
		renderTriggered: M,
		errorCaptured: T,
		serverPrefetch: C,
		expose: E,
		inheritAttrs: A,
		components: P,
		directives: L,
		filters: I
	} = t;
	if (c && function(e, t, n = S, i = !1) {
			D(e) && (e = Ln(e));
			for (const r in e) {
				const n = e[r];
				let s;
				s = U(n) ? "default" in n ? Yt(n.from || r, n.default, !0) : Yt(n.from || r) : Yt(n), Mt(s) && i ? Object.defineProperty(t, r, {
					enumerable: !0,
					configurable: !0,
					get: () => s.value,
					set: e => s.value = e
				}) : t[r] = s
			}
		}(c, i, null, e.appContext.config.unwrapInjectedRef), a)
		for (const S in a) {
			const e = a[S];
			O(e) && (i[S] = e.bind(n))
		}
	if (r) {
		const t = r.call(n, n);
		U(t) && (e.data = dt(t))
	}
	if (wn = !0, s)
		for (const D in s) {
			const e = s[D],
				t = Dt({
					get: O(e) ? e.bind(n, n) : O(e.get) ? e.get.bind(n, n) : S,
					set: !O(e) && O(e.set) ? e.set.bind(n) : S
				});
			Object.defineProperty(i, D, {
				enumerable: !0,
				configurable: !0,
				get: () => t.value,
				set: e => t.value = e
			})
		}
	if (o)
		for (const S in o) Tn(o[S], i, n, S);
	if (l) {
		const e = O(l) ? l.call(n) : l;
		Reflect.ownKeys(e).forEach((t => {
			jt(t, e[t])
		}))
	}

	function R(e, t) {
		D(t) ? t.forEach((t => e(t.bind(n)))) : t && e(t.bind(n))
	}
	if (u && Mn(u, e, "c"), R(dn, h), R(pn, d), R(fn, p), R(mn, f), R(an, m), R(on, g), R(bn, T), R(xn, w), R(yn, M), R(gn, _), R(vn, x), R(_n, C), D(E))
		if (E.length) {
			const t = e.exposed || (e.exposed = {});
			E.forEach((e => {
				Object.defineProperty(t, e, {
					get: () => n[e],
					set: t => n[e] = t
				})
			}))
		} else e.exposed || (e.exposed = {});
	b && e.render === S && (e.render = b), null != A && (e.inheritAttrs = A), P && (e.components = P), L && (e.directives = L)
}

function Mn(e, t, n) {
	Ji(D(e) ? e.map((e => e.bind(t.proxy))) : e.bind(t.proxy), t, n)
}

function Tn(e, t, n, i) {
	const r = i.includes(".") ? Cr(n, i) : () => n[i];
	if (F(e)) {
		const n = t[e];
		O(n) && Sr(r, n)
	} else if (O(e)) Sr(r, e.bind(n));
	else if (U(e))
		if (D(e)) e.forEach((e => Tn(e, t, n, i)));
		else {
			const i = O(e.handler) ? e.handler.bind(n) : t[e.handler];
			O(i) && Sr(r, i, e)
		}
}

function Cn(e) {
	const t = e.type,
		{
			mixins: n,
			extends: i
		} = t,
		{
			mixins: r,
			optionsCache: s,
			config: {
				optionMergeStrategies: a
			}
		} = e.appContext,
		o = s.get(t);
	let l;
	return o ? l = o : r.length || n || i ? (l = {}, r.length && r.forEach((e => En(l, e, a, !0))), En(l, t, a)) : l = t, s.set(t, l), l
}

function En(e, t, n, i = !1) {
	const {
		mixins: r,
		extends: s
	} = t;
	s && En(e, s, n, !0), r && r.forEach((t => En(e, t, n, !0)));
	for (const a in t)
		if (i && "expose" === a);
		else {
			const i = An[a] || n && n[a];
			e[a] = i ? i(e[a], t[a]) : t[a]
		} return e
}
const An = {
	data: Pn,
	props: Dn,
	emits: Dn,
	methods: Dn,
	computed: Dn,
	beforeCreate: In,
	created: In,
	beforeMount: In,
	mounted: In,
	beforeUpdate: In,
	updated: In,
	beforeDestroy: In,
	beforeUnmount: In,
	destroyed: In,
	unmounted: In,
	activated: In,
	deactivated: In,
	errorCaptured: In,
	serverPrefetch: In,
	components: Dn,
	directives: Dn,
	watch: function(e, t) {
		if (!e) return t;
		if (!t) return e;
		const n = A(Object.create(null), e);
		for (const i in t) n[i] = In(e[i], t[i]);
		return n
	},
	provide: Pn,
	inject: function(e, t) {
		return Dn(Ln(e), Ln(t))
	}
};

function Pn(e, t) {
	return t ? e ? function() {
		return A(O(e) ? e.call(this, this) : e, O(t) ? t.call(this, this) : t)
	} : t : e
}

function Ln(e) {
	if (D(e)) {
		const t = {};
		for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
		return t
	}
	return e
}

function In(e, t) {
	return e ? [...new Set([].concat(e, t))] : t
}

function Dn(e, t) {
	return e ? A(A(Object.create(null), e), t) : t
}

function Rn(e, t, n, i = !1) {
	const r = {},
		s = {};
	te(s, bi, 1), e.propsDefaults = Object.create(null), kn(e, t, r, s);
	for (const a in e.propsOptions[0]) a in r || (r[a] = void 0);
	n ? e.props = i ? r : ft(r, !1, Ue, st, lt) : e.type.props ? e.props = r : e.props = s, e.attrs = s
}

function kn(e, t, n, i) {
	const [r, s] = e.propsOptions;
	let a, o = !1;
	if (t)
		for (let l in t) {
			if (q(l)) continue;
			const c = t[l];
			let u;
			r && I(r, u = X(l)) ? s && s.includes(u) ? (a || (a = {}))[u] = c : n[u] = c : Nt(e.emitsOptions, l) || c !== i[l] && (i[l] = c, o = !0)
		}
	if (s) {
		const t = _t(n),
			i = a || b;
		for (let a = 0; a < s.length; a++) {
			const o = s[a];
			n[o] = Nn(r, t, o, i[o], e, !I(i, o))
		}
	}
	return o
}

function Nn(e, t, n, i, r, s) {
	const a = e[n];
	if (null != a) {
		const e = I(a, "default");
		if (e && void 0 === i) {
			const e = a.default;
			if (a.type !== Function && O(e)) {
				const {
					propsDefaults: s
				} = r;
				n in s ? i = s[n] : (Wi(r), i = s[n] = e.call(null, t), qi())
			} else i = e
		}
		a[0] && (s && !e ? i = !1 : !a[1] || "" !== i && i !== Z(n) || (i = !0))
	}
	return i
}

function On(e, t, n = !1) {
	const i = t.propsCache,
		r = i.get(e);
	if (r) return r;
	const s = e.props,
		a = {},
		o = [];
	let l = !1;
	if (!O(e)) {
		const i = e => {
			l = !0;
			const [n, i] = On(e, t, !0);
			A(a, n), i && o.push(...i)
		};
		!n && t.mixins.length && t.mixins.forEach(i), e.extends && i(e.extends), e.mixins && e.mixins.forEach(i)
	}
	if (!s && !l) return i.set(e, w), w;
	if (D(s))
		for (let u = 0; u < s.length; u++) {
			const e = X(s[u]);
			Fn(e) && (a[e] = b)
		} else if (s)
			for (const u in s) {
				const e = X(u);
				if (Fn(e)) {
					const t = s[u],
						n = a[e] = D(t) || O(t) ? {
							type: t
						} : t;
					if (n) {
						const t = Bn(Boolean, n.type),
							i = Bn(String, n.type);
						n[0] = t > -1, n[1] = i < 0 || t < i, (t > -1 || I(n, "default")) && o.push(e)
					}
				}
			}
	const c = [a, o];
	return i.set(e, c), c
}

function Fn(e) {
	return "$" !== e[0]
}

function zn(e) {
	const t = e && e.toString().match(/^\s*function (\w+)/);
	return t ? t[1] : null === e ? "null" : ""
}

function Un(e, t) {
	return zn(e) === zn(t)
}

function Bn(e, t) {
	return D(t) ? t.findIndex((t => Un(t, e))) : O(t) && Un(t, e) ? 0 : -1
}
const Vn = e => "_" === e[0] || "$stable" === e,
	Hn = e => D(e) ? e.map(Li) : [Li(e)],
	Gn = (e, t, n) => {
		const i = Vt(((...e) => Hn(t(...e))), n);
		return i._c = !1, i
	},
	Wn = (e, t, n) => {
		const i = e._ctx;
		for (const r in e) {
			if (Vn(r)) continue;
			const n = e[r];
			if (O(n)) t[r] = Gn(0, n, i);
			else if (null != n) {
				const e = Hn(n);
				t[r] = () => e
			}
		}
	},
	qn = (e, t) => {
		const n = Hn(t);
		e.slots.default = () => n
	};

function jn(e, t) {
	if (null === Ot) return e;
	const n = Ot.proxy,
		i = e.dirs || (e.dirs = []);
	for (let r = 0; r < t.length; r++) {
		let [e, s, a, o = b] = t[r];
		O(e) && (e = {
			mounted: e,
			updated: e
		}), e.deep && Er(s), i.push({
			dir: e,
			instance: n,
			value: s,
			oldValue: void 0,
			arg: a,
			modifiers: o
		})
	}
	return e
}

function Yn(e, t, n, i) {
	const r = e.dirs,
		s = t && t.dirs;
	for (let a = 0; a < r.length; a++) {
		const o = r[a];
		s && (o.oldValue = s[a].value);
		let l = o.dir[i];
		l && (be(), Ji(l, n, 8, [e.el, o, e, t]), we())
	}
}

function Xn() {
	return {
		app: null,
		config: {
			isNativeTag: M,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {}
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap,
		propsCache: new WeakMap,
		emitsCache: new WeakMap
	}
}
let $n = 0;

function Zn(e, t) {
	return function(n, i = null) {
		null == i || U(i) || (i = null);
		const r = Xn(),
			s = new Set;
		let a = !1;
		const o = r.app = {
			_uid: $n++,
			_component: n,
			_props: i,
			_container: null,
			_context: r,
			_instance: null,
			version: Pr,
			get config() {
				return r.config
			},
			set config(e) {},
			use: (e, ...t) => (s.has(e) || (e && O(e.install) ? (s.add(e), e.install(o, ...t)) : O(e) && (s.add(e), e(o, ...t))), o),
			mixin: e => (r.mixins.includes(e) || r.mixins.push(e), o),
			component: (e, t) => t ? (r.components[e] = t, o) : r.components[e],
			directive: (e, t) => t ? (r.directives[e] = t, o) : r.directives[e],
			mount(s, l, c) {
				if (!a) {
					const u = Ti(n, i);
					return u.appContext = r, l && t ? t(u, s) : e(u, s, c), a = !0, o._container = s, s.__vue_app__ = o, Zi(u.component) || u.component.proxy
				}
			},
			unmount() {
				a && (e(null, o._container), delete o._container.__vue_app__)
			},
			provide: (e, t) => (r.provides[e] = t, o)
		};
		return o
	}
}
const Kn = function(e, t) {
	t && t.pendingBranch ? D(e) ? t.effects.push(...e) : t.effects.push(e) : gr(e, lr, or, cr)
};

function Jn(e) {
	return function(e, t) {
		(ie || (ie = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {})).__VUE__ = !0;
		const {
			insert: n,
			remove: i,
			patchProp: r,
			createElement: s,
			createText: a,
			createComment: o,
			setText: l,
			setElementText: c,
			parentNode: u,
			nextSibling: h,
			setScopeId: d = S,
			cloneNode: p,
			insertStaticContent: f
		} = e, m = (e, t, n, i = null, r = null, s = null, a = !1, o = null, l = !!t.dynamicChildren) => {
			if (e === t) return;
			e && !xi(e, t) && (i = J(e), W(e, r, s, !0), e = null), -2 === t.patchFlag && (l = !1, t.dynamicChildren = null);
			const {
				type: c,
				ref: u,
				shapeFlag: h
			} = t;
			switch (c) {
				case li:
					g(e, t, n, i);
					break;
				case ci:
					v(e, t, n, i);
					break;
				case ui:
					null == e && _(t, n, i, a);
					break;
				case oi:
					R(e, t, n, i, r, s, a, o, l);
					break;
				default:
					1 & h ? M(e, t, n, i, r, s, a, o, l) : 6 & h ? k(e, t, n, i, r, s, a, o, l) : (64 & h || 128 & h) && c.process(e, t, n, i, r, s, a, o, l, ne)
			}
			null != u && r && Qn(u, e && e.ref, s, t || e, !t)
		}, g = (e, t, i, r) => {
			if (null == e) n(t.el = a(t.children), i, r);
			else {
				const n = t.el = e.el;
				t.children !== e.children && l(n, t.children)
			}
		}, v = (e, t, i, r) => {
			null == e ? n(t.el = o(t.children || ""), i, r) : t.el = e.el
		}, _ = (e, t, n, i) => {
			[e.el, e.anchor] = f(e.children, t, n, i)
		}, y = ({
			el: e,
			anchor: t
		}, i, r) => {
			let s;
			for (; e && e !== t;) s = h(e), n(e, i, r), e = s;
			n(t, i, r)
		}, x = ({
			el: e,
			anchor: t
		}) => {
			let n;
			for (; e && e !== t;) n = h(e), i(e), e = n;
			i(t)
		}, M = (e, t, n, i, r, s, a, o, l) => {
			a = a || "svg" === t.type, null == e ? T(t, n, i, r, s, a, o, l) : P(e, t, r, s, a, o, l)
		}, T = (e, t, i, a, o, l, u, h) => {
			let d, f;
			const {
				type: m,
				props: g,
				shapeFlag: v,
				transition: _,
				patchFlag: y,
				dirs: x
			} = e;
			if (e.el && void 0 !== p && -1 === y) d = e.el = p(e.el);
			else {
				if (d = e.el = s(e.type, l, g && g.is, g), 8 & v ? c(d, e.children) : 16 & v && E(e.children, d, null, a, o, l && "foreignObject" !== m, u, h), x && Yn(e, null, a, "created"), g) {
					for (const t in g) "value" === t || q(t) || r(d, t, null, g[t], l, e.children, a, o, K);
					"value" in g && r(d, "value", null, g.value), (f = g.onVnodeBeforeMount) && ei(f, a, e)
				}
				C(d, e, e.scopeId, u, a)
			}
			x && Yn(e, null, a, "beforeMount");
			const b = (!o || o && !o.pendingBranch) && _ && !_.persisted;
			b && _.beforeEnter(d), n(d, t, i), ((f = g && g.onVnodeMounted) || b || x) && Kn((() => {
				f && ei(f, a, e), b && _.enter(d), x && Yn(e, null, a, "mounted")
			}), o)
		}, C = (e, t, n, i, r) => {
			if (n && d(e, n), i)
				for (let s = 0; s < i.length; s++) d(e, i[s]);
			if (r) {
				if (t === r.subTree) {
					const t = r.vnode;
					C(e, t, t.scopeId, t.slotScopeIds, r.parent)
				}
			}
		}, E = (e, t, n, i, r, s, a, o, l = 0) => {
			for (let c = l; c < e.length; c++) {
				const l = e[c] = o ? Ii(e[c]) : Li(e[c]);
				m(null, l, t, n, i, r, s, a, o)
			}
		}, P = (e, t, n, i, s, a, o) => {
			const l = t.el = e.el;
			let {
				patchFlag: u,
				dynamicChildren: h,
				dirs: d
			} = t;
			u |= 16 & e.patchFlag;
			const p = e.props || b,
				f = t.props || b;
			let m;
			(m = f.onVnodeBeforeUpdate) && ei(m, n, t, e), d && Yn(t, e, n, "beforeUpdate");
			const g = s && "foreignObject" !== t.type;
			if (h ? L(e.dynamicChildren, h, l, n, i, g, a) : o || U(e, t, l, null, n, i, g, a, !1), u > 0) {
				if (16 & u) D(l, t, p, f, n, i, s);
				else if (2 & u && p.class !== f.class && r(l, "class", null, f.class, s), 4 & u && r(l, "style", p.style, f.style, s), 8 & u) {
					const a = t.dynamicProps;
					for (let t = 0; t < a.length; t++) {
						const o = a[t],
							c = p[o],
							u = f[o];
						u === c && "value" !== o || r(l, o, c, u, s, e.children, n, i, K)
					}
				}
				1 & u && e.children !== t.children && c(l, t.children)
			} else o || null != h || D(l, t, p, f, n, i, s);
			((m = f.onVnodeUpdated) || d) && Kn((() => {
				m && ei(m, n, t, e), d && Yn(t, e, n, "updated")
			}), i)
		}, L = (e, t, n, i, r, s, a) => {
			for (let o = 0; o < t.length; o++) {
				const l = e[o],
					c = t[o],
					h = l.el && (l.type === oi || !xi(l, c) || 70 & l.shapeFlag) ? u(l.el) : n;
				m(l, c, h, null, i, r, s, a, !0)
			}
		}, D = (e, t, n, i, s, a, o) => {
			if (n !== i) {
				for (const l in i) {
					if (q(l)) continue;
					const c = i[l],
						u = n[l];
					c !== u && "value" !== l && r(e, l, u, c, o, t.children, s, a, K)
				}
				if (n !== b)
					for (const l in n) q(l) || l in i || r(e, l, n[l], null, o, t.children, s, a, K);
				"value" in i && r(e, "value", n.value, i.value)
			}
		}, R = (e, t, i, r, s, o, l, c, u) => {
			const h = t.el = e ? e.el : a(""),
				d = t.anchor = e ? e.anchor : a("");
			let {
				patchFlag: p,
				dynamicChildren: f,
				slotScopeIds: m
			} = t;
			m && (c = c ? c.concat(m) : m), null == e ? (n(h, i, r), n(d, i, r), E(t.children, i, d, s, o, l, c, u)) : p > 0 && 64 & p && f && e.dynamicChildren ? (L(e.dynamicChildren, f, i, s, o, l, c), (null != t.key || s && t === s.subTree) && ti(e, t, !0)) : U(e, t, i, d, s, o, l, c, u)
		}, k = (e, t, n, i, r, s, a, o, l) => {
			t.slotScopeIds = o, null == e ? 512 & t.shapeFlag ? r.ctx.activate(t, n, i, a, l) : N(t, n, i, r, s, a, l) : O(e, t, l)
		}, N = (e, t, n, i, r, s, a) => {
			const o = e.component = function(e, t, n) {
				const i = e.type,
					r = (t ? t.appContext : e.appContext) || Bi,
					s = {
						uid: Vi++,
						vnode: e,
						type: i,
						parent: t,
						appContext: r,
						root: null,
						next: null,
						subTree: null,
						update: null,
						scope: new ae(!0),
						render: null,
						proxy: null,
						exposed: null,
						exposeProxy: null,
						withProxy: null,
						provides: t ? t.provides : Object.create(r.provides),
						accessCache: null,
						renderCache: [],
						components: null,
						directives: null,
						propsOptions: On(i, r),
						emitsOptions: kt(i, r),
						emit: null,
						emitted: null,
						propsDefaults: b,
						inheritAttrs: i.inheritAttrs,
						ctx: b,
						data: b,
						props: b,
						attrs: b,
						slots: b,
						refs: b,
						setupState: b,
						setupContext: null,
						suspense: n,
						suspenseId: n ? n.pendingId : 0,
						asyncDep: null,
						asyncResolved: !1,
						isMounted: !1,
						isUnmounted: !1,
						isDeactivated: !1,
						bc: null,
						c: null,
						bm: null,
						m: null,
						bu: null,
						u: null,
						um: null,
						bum: null,
						da: null,
						a: null,
						rtg: null,
						rtc: null,
						ec: null,
						sp: null
					};
				s.ctx = {
					_: s
				}, s.root = t ? t.root : s, s.emit = Rt.bind(null, s), e.ce && e.ce(s);
				return s
			}(e, i, r);
			if (sn(e) && (o.ctx.renderer = ne), function(e, t = !1) {
					Yi = t;
					const {
						props: n,
						children: i
					} = e.vnode, r = ji(e);
					Rn(e, n, r, t), ((e, t) => {
						if (32 & e.vnode.shapeFlag) {
							const n = t._;
							n ? (e.slots = _t(t), te(t, "_", n)) : Wn(t, e.slots = {})
						} else e.slots = {}, t && qn(e, t);
						te(e.slots, bi, 1)
					})(e, i);
					const s = r ? function(e, t) {
						const n = e.type;
						e.accessCache = Object.create(null), e.proxy = yt(new Proxy(e.ctx, Ui));
						const {
							setup: i
						} = n;
						if (i) {
							const n = e.setupContext = i.length > 1 ? function(e) {
								const t = t => {
									e.exposed = t || {}
								};
								let n;
								return {
									get attrs() {
										return n || (n = function(e) {
											return new Proxy(e.attrs, {
												get: (t, n) => (Se(e, 0, "$attrs"), t[n])
											})
										}(e))
									},
									slots: e.slots,
									emit: e.emit,
									expose: t
								}
							}(e) : null;
							Wi(e), be();
							const r = Ki(i, e, 0, [e.props, n]);
							if (we(), qi(), B(r)) {
								if (r.then(qi, qi), t) return r.then((n => {
									Xi(e, n, t)
								})).catch((t => {
									Qi(t, e, 0)
								}));
								e.asyncDep = r
							} else Xi(e, r, t)
						} else $i(e, t)
					}(e, t) : void 0;
					Yi = !1
				}(o), o.asyncDep) {
				if (r && r.registerDep(o, F), !e.el) {
					const e = o.subTree = Ti(ci);
					v(null, e, t, n)
				}
			} else F(o, e, t, n, r, s, a)
		}, O = (e, t, n) => {
			const i = t.component = e.component;
			if (function(e, t, n) {
					const {
						props: i,
						children: r,
						component: s
					} = e, {
						props: a,
						children: o,
						patchFlag: l
					} = t, c = s.emitsOptions;
					if (t.dirs || t.transition) return !0;
					if (!(n && l >= 0)) return !(!r && !o || o && o.$stable) || i !== a && (i ? !a || qt(i, a, c) : !!a);
					if (1024 & l) return !0;
					if (16 & l) return i ? qt(i, a, c) : !!a;
					if (8 & l) {
						const e = t.dynamicProps;
						for (let t = 0; t < e.length; t++) {
							const n = e[t];
							if (a[n] !== i[n] && !Nt(c, n)) return !0
						}
					}
					return !1
				}(e, t, n)) {
				if (i.asyncDep && !i.asyncResolved) return void z(i, t, n);
				i.next = t,
					function(e) {
						const t = nr.indexOf(e);
						t > ir && nr.splice(t, 1)
					}(i.update), i.update()
			} else t.component = e.component, t.el = e.el, i.vnode = t
		}, F = (e, t, n, i, r, s, a) => {
			const o = new ve((() => {
					if (e.isMounted) {
						let t, {
								next: n,
								bu: i,
								u: l,
								parent: c,
								vnode: h
							} = e,
							d = n;
						o.allowRecurse = !1, n ? (n.el = h.el, z(e, n, a)) : n = h, i && ee(i), (t = n.props && n.props.onVnodeBeforeUpdate) && ei(t, c, n, h), o.allowRecurse = !0;
						const p = Ht(e),
							f = e.subTree;
						e.subTree = p, m(f, p, u(f.el), J(f), e, r, s), n.el = p.el, null === d && function({
							vnode: e,
							parent: t
						}, n) {
							for (; t && t.subTree === e;)(e = t.vnode).el = n, t = t.parent
						}(e, p.el), l && Kn(l, r), (t = n.props && n.props.onVnodeUpdated) && Kn((() => ei(t, c, n, h)), r)
					} else {
						let a;
						const {
							el: l,
							props: c
						} = t, {
							bm: u,
							m: h,
							parent: d
						} = e, p = rn(t);
						if (o.allowRecurse = !1, u && ee(u), !p && (a = c && c.onVnodeBeforeMount) && ei(a, d, t), o.allowRecurse = !0, l && se) {
							const n = () => {
								e.subTree = Ht(e), se(l, e.subTree, e, r, null)
							};
							p ? t.type.__asyncLoader().then((() => !e.isUnmounted && n())) : n()
						} else {
							const a = e.subTree = Ht(e);
							m(null, a, n, i, e, r, s), t.el = a.el
						}
						if (h && Kn(h, r), !p && (a = c && c.onVnodeMounted)) {
							const e = t;
							Kn((() => ei(a, d, e)), r)
						}
						256 & t.shapeFlag && e.a && Kn(e.a, r), e.isMounted = !0, t = n = i = null
					}
				}), (() => fr(e.update)), e.scope),
				l = e.update = o.run.bind(o);
			l.id = e.uid, o.allowRecurse = l.allowRecurse = !0, l()
		}, z = (e, t, n) => {
			t.component = e;
			const i = e.vnode.props;
			e.vnode = t, e.next = null,
				function(e, t, n, i) {
					const {
						props: r,
						attrs: s,
						vnode: {
							patchFlag: a
						}
					} = e, o = _t(r), [l] = e.propsOptions;
					let c = !1;
					if (!(i || a > 0) || 16 & a) {
						let i;
						kn(e, t, r, s) && (c = !0);
						for (const s in o) t && (I(t, s) || (i = Z(s)) !== s && I(t, i)) || (l ? !n || void 0 === n[s] && void 0 === n[i] || (r[s] = Nn(l, o, s, void 0, e, !0)) : delete r[s]);
						if (s !== o)
							for (const e in s) t && I(t, e) || (delete s[e], c = !0)
					} else if (8 & a) {
						const n = e.vnode.dynamicProps;
						for (let i = 0; i < n.length; i++) {
							let a = n[i];
							const u = t[a];
							if (l)
								if (I(s, a)) u !== s[a] && (s[a] = u, c = !0);
								else {
									const t = X(a);
									r[t] = Nn(l, o, t, u, e, !1)
								}
							else u !== s[a] && (s[a] = u, c = !0)
						}
					}
					c && Ce(e, "set", "$attrs")
				}(e, t.props, i, n), ((e, t, n) => {
					const {
						vnode: i,
						slots: r
					} = e;
					let s = !0,
						a = b;
					if (32 & i.shapeFlag) {
						const e = t._;
						e ? n && 1 === e ? s = !1 : (A(r, t), n || 1 !== e || delete r._) : (s = !t.$stable, Wn(t, r)), a = t
					} else t && (qn(e, t), a = {
						default: 1
					});
					if (s)
						for (const o in r) Vn(o) || o in a || delete r[o]
				})(e, t.children, n), be(), vr(void 0, e.update), we()
		}, U = (e, t, n, i, r, s, a, o, l = !1) => {
			const u = e && e.children,
				h = e ? e.shapeFlag : 0,
				d = t.children,
				{
					patchFlag: p,
					shapeFlag: f
				} = t;
			if (p > 0) {
				if (128 & p) return void H(u, d, n, i, r, s, a, o, l);
				if (256 & p) return void V(u, d, n, i, r, s, a, o, l)
			}
			8 & f ? (16 & h && K(u, r, s), d !== u && c(n, d)) : 16 & h ? 16 & f ? H(u, d, n, i, r, s, a, o, l) : K(u, r, s, !0) : (8 & h && c(n, ""), 16 & f && E(d, n, i, r, s, a, o, l))
		}, V = (e, t, n, i, r, s, a, o, l) => {
			t = t || w;
			const c = (e = e || w).length,
				u = t.length,
				h = Math.min(c, u);
			let d;
			for (d = 0; d < h; d++) {
				const i = t[d] = l ? Ii(t[d]) : Li(t[d]);
				m(e[d], i, n, null, r, s, a, o, l)
			}
			c > u ? K(e, r, s, !0, !1, h) : E(t, n, i, r, s, a, o, l, h)
		}, H = (e, t, n, i, r, s, a, o, l) => {
			let c = 0;
			const u = t.length;
			let h = e.length - 1,
				d = u - 1;
			for (; c <= h && c <= d;) {
				const i = e[c],
					u = t[c] = l ? Ii(t[c]) : Li(t[c]);
				if (!xi(i, u)) break;
				m(i, u, n, null, r, s, a, o, l), c++
			}
			for (; c <= h && c <= d;) {
				const i = e[h],
					c = t[d] = l ? Ii(t[d]) : Li(t[d]);
				if (!xi(i, c)) break;
				m(i, c, n, null, r, s, a, o, l), h--, d--
			}
			if (c > h) {
				if (c <= d) {
					const e = d + 1,
						h = e < u ? t[e].el : i;
					for (; c <= d;) m(null, t[c] = l ? Ii(t[c]) : Li(t[c]), n, h, r, s, a, o, l), c++
				}
			} else if (c > d)
				for (; c <= h;) W(e[c], r, s, !0), c++;
			else {
				const p = c,
					f = c,
					g = new Map;
				for (c = f; c <= d; c++) {
					const e = t[c] = l ? Ii(t[c]) : Li(t[c]);
					null != e.key && g.set(e.key, c)
				}
				let v, _ = 0;
				const y = d - f + 1;
				let x = !1,
					b = 0;
				const S = new Array(y);
				for (c = 0; c < y; c++) S[c] = 0;
				for (c = p; c <= h; c++) {
					const i = e[c];
					if (_ >= y) {
						W(i, r, s, !0);
						continue
					}
					let u;
					if (null != i.key) u = g.get(i.key);
					else
						for (v = f; v <= d; v++)
							if (0 === S[v - f] && xi(i, t[v])) {
								u = v;
								break
							} void 0 === u ? W(i, r, s, !0) : (S[u - f] = c + 1, u >= b ? b = u : x = !0, m(i, t[u], n, null, r, s, a, o, l), _++)
				}
				const M = x ? function(e) {
					const t = e.slice(),
						n = [0];
					let i, r, s, a, o;
					const l = e.length;
					for (i = 0; i < l; i++) {
						const l = e[i];
						if (0 !== l) {
							if (r = n[n.length - 1], e[r] < l) {
								t[i] = r, n.push(i);
								continue
							}
							for (s = 0, a = n.length - 1; s < a;) o = s + a >> 1, e[n[o]] < l ? s = o + 1 : a = o;
							l < e[n[s]] && (s > 0 && (t[i] = n[s - 1]), n[s] = i)
						}
					}
					s = n.length, a = n[s - 1];
					for (; s-- > 0;) n[s] = a, a = t[a];
					return n
				}(S) : w;
				for (v = M.length - 1, c = y - 1; c >= 0; c--) {
					const e = f + c,
						h = t[e],
						d = e + 1 < u ? t[e + 1].el : i;
					0 === S[c] ? m(null, h, n, d, r, s, a, o, l) : x && (v < 0 || c !== M[v] ? G(h, n, d, 2) : v--)
				}
			}
		}, G = (e, t, i, r, s = null) => {
			const {
				el: a,
				type: o,
				transition: l,
				children: c,
				shapeFlag: u
			} = e;
			if (6 & u) return void G(e.component.subTree, t, i, r);
			if (128 & u) return void e.suspense.move(t, i, r);
			if (64 & u) return void o.move(e, t, i, ne);
			if (o === oi) {
				n(a, t, i);
				for (let e = 0; e < c.length; e++) G(c[e], t, i, r);
				return void n(e.anchor, t, i)
			}
			if (o === ui) return void y(e, t, i);
			if (2 !== r && 1 & u && l)
				if (0 === r) l.beforeEnter(a), n(a, t, i), Kn((() => l.enter(a)), s);
				else {
					const {
						leave: e,
						delayLeave: r,
						afterLeave: s
					} = l, o = () => n(a, t, i), c = () => {
						e(a, (() => {
							o(), s && s()
						}))
					};
					r ? r(a, o, c) : c()
				}
			else n(a, t, i)
		}, W = (e, t, n, i = !1, r = !1) => {
			const {
				type: s,
				props: a,
				ref: o,
				children: l,
				dynamicChildren: c,
				shapeFlag: u,
				patchFlag: h,
				dirs: d
			} = e;
			if (null != o && Qn(o, null, n, e, !0), 256 & u) return void t.ctx.deactivate(e);
			const p = 1 & u && d,
				f = !rn(e);
			let m;
			if (f && (m = a && a.onVnodeBeforeUnmount) && ei(m, t, e), 6 & u) $(e.component, n, i);
			else {
				if (128 & u) return void e.suspense.unmount(n, i);
				p && Yn(e, null, t, "beforeUnmount"), 64 & u ? e.type.remove(e, t, n, r, ne, i) : c && (s !== oi || h > 0 && 64 & h) ? K(c, t, n, !1, !0) : (s === oi && 384 & h || !r && 16 & u) && K(l, t, n), i && j(e)
			}(f && (m = a && a.onVnodeUnmounted) || p) && Kn((() => {
				m && ei(m, t, e), p && Yn(e, null, t, "unmounted")
			}), n)
		}, j = e => {
			const {
				type: t,
				el: n,
				anchor: r,
				transition: s
			} = e;
			if (t === oi) return void Y(n, r);
			if (t === ui) return void x(e);
			const a = () => {
				i(n), s && !s.persisted && s.afterLeave && s.afterLeave()
			};
			if (1 & e.shapeFlag && s && !s.persisted) {
				const {
					leave: t,
					delayLeave: i
				} = s, r = () => t(n, a);
				i ? i(e.el, a, r) : r()
			} else a()
		}, Y = (e, t) => {
			let n;
			for (; e !== t;) n = h(e), i(e), e = n;
			i(t)
		}, $ = (e, t, n) => {
			const {
				bum: i,
				scope: r,
				update: s,
				subTree: a,
				um: o
			} = e;
			i && ee(i), r.stop(), s && (s.active = !1, W(a, e, t, n)), o && Kn(o, t), Kn((() => {
				e.isUnmounted = !0
			}), t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, 0 === t.deps && t.resolve())
		}, K = (e, t, n, i = !1, r = !1, s = 0) => {
			for (let a = s; a < e.length; a++) W(e[a], t, n, i, r)
		}, J = e => 6 & e.shapeFlag ? J(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : h(e.anchor || e.el), Q = (e, t, n) => {
			null == e ? t._vnode && W(t._vnode, null, null, !0) : m(t._vnode || null, e, t, null, null, null, n), _r(), t._vnode = e
		}, ne = {
			p: m,
			um: W,
			m: G,
			r: j,
			mt: N,
			mc: E,
			pc: U,
			pbc: L,
			n: J,
			o: e
		};
		let re, se;
		t && ([re, se] = t(ne));
		return {
			render: Q,
			hydrate: re,
			createApp: Zn(Q, re)
		}
	}(e)
}

function Qn(e, t, n, i, r = !1) {
	if (D(e)) return void e.forEach(((e, s) => Qn(e, t && (D(t) ? t[s] : t), n, i, r)));
	if (rn(i) && !r) return;
	const s = 4 & i.shapeFlag ? Zi(i.component) || i.component.proxy : i.el,
		a = r ? null : s,
		{
			i: o,
			r: l
		} = e,
		c = t && t.r,
		u = o.refs === b ? o.refs = {} : o.refs,
		h = o.setupState;
	if (null != c && c !== l && (F(c) ? (u[c] = null, I(h, c) && (h[c] = null)) : Mt(c) && (c.value = null)), F(l)) {
		const e = () => {
			u[l] = a, I(h, l) && (h[l] = a)
		};
		a ? (e.id = -1, Kn(e, n)) : e()
	} else if (Mt(l)) {
		const e = () => {
			l.value = a
		};
		a ? (e.id = -1, Kn(e, n)) : e()
	} else O(l) && Ki(l, o, 12, [a, u])
}

function ei(e, t, n, i = null) {
	Ji(e, t, 7, [n, i])
}

function ti(e, t, n = !1) {
	const i = e.children,
		r = t.children;
	if (D(i) && D(r))
		for (let s = 0; s < i.length; s++) {
			const e = i[s];
			let t = r[s];
			1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = r[s] = Ii(r[s]), t.el = e.el), n || ti(e, t))
		}
}

function ni(e, t) {
	return si("components", e, !0, t) || e
}
const ii = Symbol();

function ri(e) {
	return F(e) ? si("components", e, !1) || e : e || ii
}

function si(e, t, n = !0, i = !1) {
	const r = Ot || Hi;
	if (r) {
		const n = r.type;
		if ("components" === e) {
			const e = function(e) {
				return O(e) && e.displayName || e.name
			}(n);
			if (e && (e === t || e === X(t) || e === K(X(t)))) return n
		}
		const s = ai(r[e] || n[e], t) || ai(r.appContext[e], t);
		return !s && i ? n : s
	}
}

function ai(e, t) {
	return e && (e[t] || e[X(t)] || e[K(X(t))])
}
const oi = Symbol(void 0),
	li = Symbol(void 0),
	ci = Symbol(void 0),
	ui = Symbol(void 0),
	hi = [];
let di = null;

function pi(e = !1) {
	hi.push(di = e ? null : [])
}
let fi = 1;

function mi(e) {
	fi += e
}

function gi(e) {
	return e.dynamicChildren = fi > 0 ? di || w : null, hi.pop(), di = hi[hi.length - 1] || null, fi > 0 && di && di.push(e), e
}

function vi(e, t, n, i, r, s) {
	return gi(Mi(e, t, n, i, r, s, !0))
}

function _i(e, t, n, i, r) {
	return gi(Ti(e, t, n, i, r, !0))
}

function yi(e) {
	return !!e && !0 === e.__v_isVNode
}

function xi(e, t) {
	return e.type === t.type && e.key === t.key
}
const bi = "__vInternal",
	wi = ({
		key: e
	}) => null != e ? e : null,
	Si = ({
		ref: e
	}) => null != e ? F(e) || Mt(e) || O(e) ? {
		i: Ot,
		r: e
	} : e : null;

function Mi(e, t = null, n = null, i = 0, r = null, s = (e === oi ? 0 : 1), a = !1, o = !1) {
	const l = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: e,
		props: t,
		key: t && wi(t),
		ref: t && Si(t),
		scopeId: Ft,
		slotScopeIds: null,
		children: n,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: s,
		patchFlag: i,
		dynamicProps: r,
		dynamicChildren: null,
		appContext: null
	};
	return o ? (Di(l, n), 128 & s && e.normalize(l)) : n && (l.shapeFlag |= F(n) ? 8 : 16), fi > 0 && !a && di && (l.patchFlag > 0 || 6 & s) && 32 !== l.patchFlag && di.push(l), l
}
const Ti = function(e, t = null, n = null, i = 0, r = null, s = !1) {
	e && e !== ii || (e = ci);
	if (yi(e)) {
		const i = Ci(e, t, !0);
		return n && Di(i, n), i
	}
	a = e, O(a) && "__vccOpts" in a && (e = e.__vccOpts);
	var a;
	if (t) {
		t = function(e) {
			return e ? vt(e) || bi in e ? A({}, e) : e : null
		}(t);
		let {
			class: e,
			style: n
		} = t;
		e && !F(e) && (t.class = g(e)), U(n) && (vt(n) && !D(n) && (n = A({}, n)), t.style = d(n))
	}
	const o = F(e) ? 1 : (e => e.__isSuspense)(e) ? 128 : (e => e.__isTeleport)(e) ? 64 : U(e) ? 4 : O(e) ? 2 : 0;
	return Mi(e, t, n, i, r, o, s, !0)
};

function Ci(e, t, n = !1) {
	const {
		props: i,
		ref: r,
		patchFlag: s,
		children: a
	} = e, o = t ? Ri(i || {}, t) : i;
	return {
		__v_isVNode: !0,
		__v_skip: !0,
		type: e.type,
		props: o,
		key: o && wi(o),
		ref: t && t.ref ? n && r ? D(r) ? r.concat(Si(t)) : [r, Si(t)] : Si(t) : r,
		scopeId: e.scopeId,
		slotScopeIds: e.slotScopeIds,
		children: a,
		target: e.target,
		targetAnchor: e.targetAnchor,
		staticCount: e.staticCount,
		shapeFlag: e.shapeFlag,
		patchFlag: t && e.type !== oi ? -1 === s ? 16 : 16 | s : s,
		dynamicProps: e.dynamicProps,
		dynamicChildren: e.dynamicChildren,
		appContext: e.appContext,
		dirs: e.dirs,
		transition: e.transition,
		component: e.component,
		suspense: e.suspense,
		ssContent: e.ssContent && Ci(e.ssContent),
		ssFallback: e.ssFallback && Ci(e.ssFallback),
		el: e.el,
		anchor: e.anchor
	}
}

function Ei(e = " ", t = 0) {
	return Ti(li, null, e, t)
}

function Ai(e, t) {
	const n = Ti(ui, null, e);
	return n.staticCount = t, n
}

function Pi(e = "", t = !1) {
	return t ? (pi(), _i(ci, null, e)) : Ti(ci, null, e)
}

function Li(e) {
	return null == e || "boolean" == typeof e ? Ti(ci) : D(e) ? Ti(oi, null, e.slice()) : "object" == typeof e ? Ii(e) : Ti(li, null, String(e))
}

function Ii(e) {
	return null === e.el || e.memo ? e : Ci(e)
}

function Di(e, t) {
	let n = 0;
	const {
		shapeFlag: i
	} = e;
	if (null == t) t = null;
	else if (D(t)) n = 16;
	else if ("object" == typeof t) {
		if (65 & i) {
			const n = t.default;
			return void(n && (n._c && (n._d = !1), Di(e, n()), n._c && (n._d = !0)))
		} {
			n = 32;
			const i = t._;
			i || bi in t ? 3 === i && Ot && (1 === Ot.slots._ ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = Ot
		}
	} else O(t) ? (t = {
		default: t,
		_ctx: Ot
	}, n = 32) : (t = String(t), 64 & i ? (n = 16, t = [Ei(t)]) : n = 8);
	e.children = t, e.shapeFlag |= n
}

function Ri(...e) {
	const t = {};
	for (let n = 0; n < e.length; n++) {
		const i = e[n];
		for (const e in i)
			if ("class" === e) t.class !== i.class && (t.class = g([t.class, i.class]));
			else if ("style" === e) t.style = d([t.style, i.style]);
		else if (C(e)) {
			const n = t[e],
				r = i[e];
			n !== r && (t[e] = n ? [].concat(n, r) : r)
		} else "" !== e && (t[e] = i[e])
	}
	return t
}

function ki(e, t, n, i) {
	let r;
	const s = n && n[i];
	if (D(e) || F(e)) {
		r = new Array(e.length);
		for (let n = 0, i = e.length; n < i; n++) r[n] = t(e[n], n, void 0, s && s[n])
	} else if ("number" == typeof e) {
		r = new Array(e);
		for (let n = 0; n < e; n++) r[n] = t(n + 1, n, void 0, s && s[n])
	} else if (U(e))
		if (e[Symbol.iterator]) r = Array.from(e, ((e, n) => t(e, n, void 0, s && s[n])));
		else {
			const n = Object.keys(e);
			r = new Array(n.length);
			for (let i = 0, a = n.length; i < a; i++) {
				const a = n[i];
				r[i] = t(e[a], a, i, s && s[i])
			}
		}
	else r = [];
	return n && (n[i] = r), r
}

function Ni(e, t, n = {}, i, r) {
	if (Ot.isCE) return Ti("slot", "default" === t ? null : {
		name: t
	}, i && i());
	let s = e[t];
	s && s._c && (s._d = !1), pi();
	const a = s && Oi(s(n)),
		o = _i(oi, {
			key: n.key || `_${t}`
		}, a || (i ? i() : []), a && 1 === e._ ? 64 : -2);
	return !r && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), s && s._c && (s._d = !0), o
}

function Oi(e) {
	return e.some((e => !yi(e) || e.type !== ci && !(e.type === oi && !Oi(e.children)))) ? e : null
}
const Fi = e => e ? ji(e) ? Zi(e) || e.proxy : Fi(e.parent) : null,
	zi = A(Object.create(null), {
		$: e => e,
		$el: e => e.vnode.el,
		$data: e => e.data,
		$props: e => e.props,
		$attrs: e => e.attrs,
		$slots: e => e.slots,
		$refs: e => e.refs,
		$parent: e => Fi(e.parent),
		$root: e => Fi(e.root),
		$emit: e => e.emit,
		$options: e => Cn(e),
		$forceUpdate: e => () => fr(e.update),
		$nextTick: e => pr.bind(e.proxy),
		$watch: e => Tr.bind(e)
	}),
	Ui = {
		get({
			_: e
		}, t) {
			const {
				ctx: n,
				setupState: i,
				data: r,
				props: s,
				accessCache: a,
				type: o,
				appContext: l
			} = e;
			let c;
			if ("$" !== t[0]) {
				const o = a[t];
				if (void 0 !== o) switch (o) {
					case 0:
						return i[t];
					case 1:
						return r[t];
					case 3:
						return n[t];
					case 2:
						return s[t]
				} else {
					if (i !== b && I(i, t)) return a[t] = 0, i[t];
					if (r !== b && I(r, t)) return a[t] = 1, r[t];
					if ((c = e.propsOptions[0]) && I(c, t)) return a[t] = 2, s[t];
					if (n !== b && I(n, t)) return a[t] = 3, n[t];
					wn && (a[t] = 4)
				}
			}
			const u = zi[t];
			let h, d;
			return u ? ("$attrs" === t && Se(e, 0, t), u(e)) : (h = o.__cssModules) && (h = h[t]) ? h : n !== b && I(n, t) ? (a[t] = 3, n[t]) : (d = l.config.globalProperties, I(d, t) ? d[t] : void 0)
		},
		set({
			_: e
		}, t, n) {
			const {
				data: i,
				setupState: r,
				ctx: s
			} = e;
			if (r !== b && I(r, t)) r[t] = n;
			else if (i !== b && I(i, t)) i[t] = n;
			else if (I(e.props, t)) return !1;
			return ("$" !== t[0] || !(t.slice(1) in e)) && (s[t] = n, !0)
		},
		has({
			_: {
				data: e,
				setupState: t,
				accessCache: n,
				ctx: i,
				appContext: r,
				propsOptions: s
			}
		}, a) {
			let o;
			return void 0 !== n[a] || e !== b && I(e, a) || t !== b && I(t, a) || (o = s[0]) && I(o, a) || I(i, a) || I(zi, a) || I(r.config.globalProperties, a)
		}
	},
	Bi = Xn();
let Vi = 0;
let Hi = null;
const Gi = () => Hi || Ot,
	Wi = e => {
		Hi = e, e.scope.on()
	},
	qi = () => {
		Hi && Hi.scope.off(), Hi = null
	};

function ji(e) {
	return 4 & e.vnode.shapeFlag
}
let Yi = !1;

function Xi(e, t, n) {
	O(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : U(t) && (e.setupState = Lt(t)), $i(e, n)
}

function $i(e, t, n) {
	const i = e.type;
	e.render || (e.render = i.render || S), Wi(e), be(), Sn(e), we(), qi()
}

function Zi(e) {
	if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Lt(yt(e.exposed)), {
		get: (t, n) => n in t ? t[n] : n in zi ? zi[n](e) : void 0
	}))
}

function Ki(e, t, n, i) {
	let r;
	try {
		r = i ? e(...i) : e()
	} catch (s) {
		Qi(s, t, n)
	}
	return r
}

function Ji(e, t, n, i) {
	if (O(e)) {
		const r = Ki(e, t, n, i);
		return r && B(r) && r.catch((e => {
			Qi(e, t, n)
		})), r
	}
	const r = [];
	for (let s = 0; s < e.length; s++) r.push(Ji(e[s], t, n, i));
	return r
}

function Qi(e, t, n, i = !0) {
	t && t.vnode;
	if (t) {
		let i = t.parent;
		const r = t.proxy,
			s = n;
		for (; i;) {
			const t = i.ec;
			if (t)
				for (let n = 0; n < t.length; n++)
					if (!1 === t[n](e, r, s)) return;
			i = i.parent
		}
		const a = t.appContext.config.errorHandler;
		if (a) return void Ki(a, null, 10, [e, r, s])
	}
}
let er = !1,
	tr = !1;
const nr = [];
let ir = 0;
const rr = [];
let sr = null,
	ar = 0;
const or = [];
let lr = null,
	cr = 0;
const ur = Promise.resolve();
let hr = null,
	dr = null;

function pr(e) {
	const t = hr || ur;
	return e ? t.then(this ? e.bind(this) : e) : t
}

function fr(e) {
	nr.length && nr.includes(e, er && e.allowRecurse ? ir + 1 : ir) || e === dr || (null == e.id ? nr.push(e) : nr.splice(function(e) {
		let t = ir + 1,
			n = nr.length;
		for (; t < n;) {
			const i = t + n >>> 1;
			yr(nr[i]) < e ? t = i + 1 : n = i
		}
		return t
	}(e.id), 0, e), mr())
}

function mr() {
	er || tr || (tr = !0, hr = ur.then(xr))
}

function gr(e, t, n, i) {
	D(e) ? n.push(...e) : t && t.includes(e, e.allowRecurse ? i + 1 : i) || n.push(e), mr()
}

function vr(e, t = null) {
	if (rr.length) {
		for (dr = t, sr = [...new Set(rr)], rr.length = 0, ar = 0; ar < sr.length; ar++) sr[ar]();
		sr = null, ar = 0, dr = null, vr(e, t)
	}
}

function _r(e) {
	if (or.length) {
		const e = [...new Set(or)];
		if (or.length = 0, lr) return void lr.push(...e);
		for (lr = e, lr.sort(((e, t) => yr(e) - yr(t))), cr = 0; cr < lr.length; cr++) lr[cr]();
		lr = null, cr = 0
	}
}
const yr = e => null == e.id ? Infinity : e.id;

function xr(e) {
	tr = !1, er = !0, vr(e), nr.sort(((e, t) => yr(e) - yr(t)));
	try {
		for (ir = 0; ir < nr.length; ir++) {
			const e = nr[ir];
			e && !1 !== e.active && Ki(e, null, 14)
		}
	} finally {
		ir = 0, nr.length = 0, _r(), er = !1, hr = null, (nr.length || rr.length || or.length) && xr(e)
	}
}

function br(e, t) {
	return Mr(e, null, t)
}
const wr = {};

function Sr(e, t, n) {
	return Mr(e, t, n)
}

function Mr(e, t, {
	immediate: n,
	deep: i,
	flush: r,
	onTrack: s,
	onTrigger: a
} = b) {
	const o = Hi;
	let l, c, u = !1,
		h = !1;
	if (Mt(e) ? (l = () => e.value, u = !!e._shallow) : mt(e) ? (l = () => e, i = !0) : D(e) ? (h = !0, u = e.some(mt), l = () => e.map((e => Mt(e) ? e.value : mt(e) ? Er(e) : O(e) ? Ki(e, o, 2) : void 0))) : l = O(e) ? t ? () => Ki(e, o, 2) : () => {
			if (!o || !o.isUnmounted) return c && c(), Ji(e, o, 3, [d])
		} : S, t && i) {
		const e = l;
		l = () => Er(e())
	}
	let d = e => {
		c = g.onStop = () => {
			Ki(e, o, 4)
		}
	};
	if (Yi) return d = S, t ? n && Ji(t, o, 3, [l(), h ? [] : void 0, d]) : l(), S;
	let p = h ? [] : wr;
	const f = () => {
		if (g.active)
			if (t) {
				const e = g.run();
				(i || u || (h ? e.some(((e, t) => Q(e, p[t]))) : Q(e, p))) && (c && c(), Ji(t, o, 3, [e, p === wr ? void 0 : p, d]), p = e)
			} else g.run()
	};
	let m;
	f.allowRecurse = !!t, m = "sync" === r ? f : "post" === r ? () => Kn(f, o && o.suspense) : () => {
		!o || o.isMounted ? function(e) {
			gr(e, sr, rr, ar)
		}(f) : f()
	};
	const g = new ve(l, m);
	return t ? n ? f() : p = g.run() : "post" === r ? Kn(g.run.bind(g), o && o.suspense) : g.run(), () => {
		g.stop(), o && o.scope && P(o.scope.effects, g)
	}
}

function Tr(e, t, n) {
	const i = this.proxy,
		r = F(e) ? e.includes(".") ? Cr(i, e) : () => i[e] : e.bind(i, i);
	let s;
	O(t) ? s = t : (s = t.handler, n = t);
	const a = Hi;
	Wi(this);
	const o = Mr(r, s.bind(i), n);
	return a ? Wi(a) : qi(), o
}

function Cr(e, t) {
	const n = t.split(".");
	return () => {
		let t = e;
		for (let e = 0; e < n.length && t; e++) t = t[n[e]];
		return t
	}
}

function Er(e, t) {
	if (!U(e) || e.__v_skip) return e;
	if ((t = t || new Set).has(e)) return e;
	if (t.add(e), Mt(e)) Er(e.value, t);
	else if (D(e))
		for (let n = 0; n < e.length; n++) Er(e[n], t);
	else if (k(e) || R(e)) e.forEach((e => {
		Er(e, t)
	}));
	else if (G(e))
		for (const n in e) Er(e[n], t);
	return e
}

function Ar(e, t, n) {
	const i = arguments.length;
	return 2 === i ? U(t) && !D(t) ? yi(t) ? Ti(e, null, [t]) : Ti(e, t) : Ti(e, null, t) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === i && yi(n) && (n = [n]), Ti(e, t, n))
}
const Pr = "3.2.19",
	Lr = "undefined" != typeof document ? document : null,
	Ir = new Map,
	Dr = {
		insert: (e, t, n) => {
			t.insertBefore(e, n || null)
		},
		remove: e => {
			const t = e.parentNode;
			t && t.removeChild(e)
		},
		createElement: (e, t, n, i) => {
			const r = t ? Lr.createElementNS("http://www.w3.org/2000/svg", e) : Lr.createElement(e, n ? {
				is: n
			} : void 0);
			return "select" === e && i && null != i.multiple && r.setAttribute("multiple", i.multiple), r
		},
		createText: e => Lr.createTextNode(e),
		createComment: e => Lr.createComment(e),
		setText: (e, t) => {
			e.nodeValue = t
		},
		setElementText: (e, t) => {
			e.textContent = t
		},
		parentNode: e => e.parentNode,
		nextSibling: e => e.nextSibling,
		querySelector: e => Lr.querySelector(e),
		setScopeId(e, t) {
			e.setAttribute(t, "")
		},
		cloneNode(e) {
			const t = e.cloneNode(!0);
			return "_value" in e && (t._value = e._value), t
		},
		insertStaticContent(e, t, n, i) {
			const r = n ? n.previousSibling : t.lastChild;
			let s = Ir.get(e);
			if (!s) {
				const t = Lr.createElement("template");
				if (t.innerHTML = i ? `<svg>${e}</svg>` : e, s = t.content, i) {
					const e = s.firstChild;
					for (; e.firstChild;) s.appendChild(e.firstChild);
					s.removeChild(e)
				}
				Ir.set(e, s)
			}
			return t.insertBefore(s.cloneNode(!0), n), [r ? r.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
		}
	};
const Rr = /\s*!important$/;

function kr(e, t, n) {
	if (D(n)) n.forEach((n => kr(e, t, n)));
	else if (t.startsWith("--")) e.setProperty(t, n);
	else {
		const i = function(e, t) {
			const n = Or[t];
			if (n) return n;
			let i = X(t);
			if ("filter" !== i && i in e) return Or[t] = i;
			i = K(i);
			for (let r = 0; r < Nr.length; r++) {
				const n = Nr[r] + i;
				if (n in e) return Or[t] = n
			}
			return t
		}(e, t);
		Rr.test(n) ? e.setProperty(Z(i), n.replace(Rr, ""), "important") : e[i] = n
	}
}
const Nr = ["Webkit", "Moz", "ms"],
	Or = {};
const Fr = "http://www.w3.org/1999/xlink";
let zr = Date.now,
	Ur = !1;
if ("undefined" != typeof window) {
	zr() > document.createEvent("Event").timeStamp && (zr = () => performance.now());
	const e = navigator.userAgent.match(/firefox\/(\d+)/i);
	Ur = !!(e && Number(e[1]) <= 53)
}
let Br = 0;
const Vr = Promise.resolve(),
	Hr = () => {
		Br = 0
	};

function Gr(e, t, n, i) {
	e.addEventListener(t, n, i)
}

function Wr(e, t, n, i, r = null) {
	const s = e._vei || (e._vei = {}),
		a = s[t];
	if (i && a) a.value = i;
	else {
		const [n, o] = function(e) {
			let t;
			if (qr.test(e)) {
				let n;
				for (t = {}; n = e.match(qr);) e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0
			}
			return [Z(e.slice(2)), t]
		}(t);
		if (i) {
			const a = s[t] = function(e, t) {
				const n = e => {
					const i = e.timeStamp || zr();
					(Ur || i >= n.attached - 1) && Ji(function(e, t) {
						if (D(t)) {
							const n = e.stopImmediatePropagation;
							return e.stopImmediatePropagation = () => {
								n.call(e), e._stopped = !0
							}, t.map((e => t => !t._stopped && e(t)))
						}
						return t
					}(e, n.value), t, 5, [e])
				};
				return n.value = e, n.attached = (() => Br || (Vr.then(Hr), Br = zr()))(), n
			}(i, r);
			Gr(e, n, a, o)
		} else a && (! function(e, t, n, i) {
			e.removeEventListener(t, n, i)
		}(e, n, a, o), s[t] = void 0)
	}
}
const qr = /(?:Once|Passive|Capture)$/;
const jr = /^on[a-z]/;
const Yr = "transition",
	Xr = (e, {
		slots: t
	}) => Ar($t, function(e) {
		const t = {};
		for (const A in e) A in $r || (t[A] = e[A]);
		if (!1 === e.css) return t;
		const {
			name: n = "v",
			type: i,
			duration: r,
			enterFromClass: s = `${n}-enter-from`,
			enterActiveClass: a = `${n}-enter-active`,
			enterToClass: o = `${n}-enter-to`,
			appearFromClass: l = s,
			appearActiveClass: c = a,
			appearToClass: u = o,
			leaveFromClass: h = `${n}-leave-from`,
			leaveActiveClass: d = `${n}-leave-active`,
			leaveToClass: p = `${n}-leave-to`
		} = e, f = function(e) {
			if (null == e) return null;
			if (U(e)) return [Jr(e.enter), Jr(e.leave)]; {
				const t = Jr(e);
				return [t, t]
			}
		}(r), m = f && f[0], g = f && f[1], {
			onBeforeEnter: v,
			onEnter: _,
			onEnterCancelled: y,
			onLeave: x,
			onLeaveCancelled: b,
			onBeforeAppear: w = v,
			onAppear: S = _,
			onAppearCancelled: M = y
		} = t, T = (e, t, n) => {
			es(e, t ? u : o), es(e, t ? c : a), n && n()
		}, C = (e, t) => {
			es(e, p), es(e, d), t && t()
		}, E = e => (t, n) => {
			const r = e ? S : _,
				a = () => T(t, e, n);
			Zr(r, [t, a]), ts((() => {
				es(t, e ? l : s), Qr(t, e ? u : o), Kr(r) || is(t, i, m, a)
			}))
		};
		return A(t, {
			onBeforeEnter(e) {
				Zr(v, [e]), Qr(e, s), Qr(e, a)
			},
			onBeforeAppear(e) {
				Zr(w, [e]), Qr(e, l), Qr(e, c)
			},
			onEnter: E(!1),
			onAppear: E(!0),
			onLeave(e, t) {
				const n = () => C(e, t);
				Qr(e, h), document.body.offsetHeight, Qr(e, d), ts((() => {
					es(e, h), Qr(e, p), Kr(x) || is(e, i, g, n)
				})), Zr(x, [e, n])
			},
			onEnterCancelled(e) {
				T(e, !1), Zr(y, [e])
			},
			onAppearCancelled(e) {
				T(e, !0), Zr(M, [e])
			},
			onLeaveCancelled(e) {
				C(e), Zr(b, [e])
			}
		})
	}(e), t);
Xr.displayName = "Transition";
const $r = {
	name: String,
	type: String,
	css: {
		type: Boolean,
		default: !0
	},
	duration: [String, Number, Object],
	enterFromClass: String,
	enterActiveClass: String,
	enterToClass: String,
	appearFromClass: String,
	appearActiveClass: String,
	appearToClass: String,
	leaveFromClass: String,
	leaveActiveClass: String,
	leaveToClass: String
};
Xr.props = A({}, $t.props, $r);
const Zr = (e, t = []) => {
		D(e) ? e.forEach((e => e(...t))) : e && e(...t)
	},
	Kr = e => !!e && (D(e) ? e.some((e => e.length > 1)) : e.length > 1);

function Jr(e) {
	return ne(e)
}

function Qr(e, t) {
	t.split(/\s+/).forEach((t => t && e.classList.add(t))), (e._vtc || (e._vtc = new Set)).add(t)
}

function es(e, t) {
	t.split(/\s+/).forEach((t => t && e.classList.remove(t)));
	const {
		_vtc: n
	} = e;
	n && (n.delete(t), n.size || (e._vtc = void 0))
}

function ts(e) {
	requestAnimationFrame((() => {
		requestAnimationFrame(e)
	}))
}
let ns = 0;

function is(e, t, n, i) {
	const r = e._endId = ++ns,
		s = () => {
			r === e._endId && i()
		};
	if (n) return setTimeout(s, n);
	const {
		type: a,
		timeout: o,
		propCount: l
	} = function(e, t) {
		const n = window.getComputedStyle(e),
			i = e => (n[e] || "").split(", "),
			r = i("transitionDelay"),
			s = i("transitionDuration"),
			a = rs(r, s),
			o = i("animationDelay"),
			l = i("animationDuration"),
			c = rs(o, l);
		let u = null,
			h = 0,
			d = 0;
		t === Yr ? a > 0 && (u = Yr, h = a, d = s.length) : "animation" === t ? c > 0 && (u = "animation", h = c, d = l.length) : (h = Math.max(a, c), u = h > 0 ? a > c ? Yr : "animation" : null, d = u ? u === Yr ? s.length : l.length : 0);
		const p = u === Yr && /\b(transform|all)(,|$)/.test(n.transitionProperty);
		return {
			type: u,
			timeout: h,
			propCount: d,
			hasTransform: p
		}
	}(e, t);
	if (!a) return i();
	const c = a + "end";
	let u = 0;
	const h = () => {
			e.removeEventListener(c, d), s()
		},
		d = t => {
			t.target === e && ++u >= l && h()
		};
	setTimeout((() => {
		u < l && h()
	}), o + 1), e.addEventListener(c, d)
}

function rs(e, t) {
	for (; e.length < t.length;) e = e.concat(e);
	return Math.max(...t.map(((t, n) => ss(t) + ss(e[n]))))
}

function ss(e) {
	return 1e3 * Number(e.slice(0, -1).replace(",", "."))
}
const as = e => {
	const t = e.props["onUpdate:modelValue"];
	return D(t) ? e => ee(t, e) : t
};

function os(e) {
	e.target.composing = !0
}

function ls(e) {
	const t = e.target;
	t.composing && (t.composing = !1, function(e, t) {
		const n = document.createEvent("HTMLEvents");
		n.initEvent(t, !0, !0), e.dispatchEvent(n)
	}(t, "input"))
}
const cs = {
		created(e, {
			modifiers: {
				lazy: t,
				trim: n,
				number: i
			}
		}, r) {
			e._assign = as(r);
			const s = i || r.props && "number" === r.props.type;
			Gr(e, t ? "change" : "input", (t => {
				if (t.target.composing) return;
				let i = e.value;
				n ? i = i.trim() : s && (i = ne(i)), e._assign(i)
			})), n && Gr(e, "change", (() => {
				e.value = e.value.trim()
			})), t || (Gr(e, "compositionstart", os), Gr(e, "compositionend", ls), Gr(e, "change", ls))
		},
		mounted(e, {
			value: t
		}) {
			e.value = null == t ? "" : t
		},
		beforeUpdate(e, {
			value: t,
			modifiers: {
				lazy: n,
				trim: i,
				number: r
			}
		}, s) {
			if (e._assign = as(s), e.composing) return;
			if (document.activeElement === e) {
				if (n) return;
				if (i && e.value.trim() === t) return;
				if ((r || "number" === e.type) && ne(e.value) === t) return
			}
			const a = null == t ? "" : t;
			e.value !== a && (e.value = a)
		}
	},
	us = {
		deep: !0,
		created(e, t, n) {
			e._assign = as(n), Gr(e, "change", (() => {
				const t = e._modelValue,
					n = function(e) {
						return "_value" in e ? e._value : e.value
					}(e),
					i = e.checked,
					r = e._assign;
				if (D(t)) {
					const e = _(t, n),
						s = -1 !== e;
					if (i && !s) r(t.concat(n));
					else if (!i && s) {
						const n = [...t];
						n.splice(e, 1), r(n)
					}
				} else if (k(t)) {
					const e = new Set(t);
					i ? e.add(n) : e.delete(n), r(e)
				} else r(ds(e, i))
			}))
		},
		mounted: hs,
		beforeUpdate(e, t, n) {
			e._assign = as(n), hs(e, t, n)
		}
	};

function hs(e, {
	value: t,
	oldValue: n
}, i) {
	e._modelValue = t, D(t) ? e.checked = _(t, i.props.value) > -1 : k(t) ? e.checked = t.has(i.props.value) : t !== n && (e.checked = v(t, ds(e, !0)))
}

function ds(e, t) {
	const n = t ? "_trueValue" : "_falseValue";
	return n in e ? e[n] : t
}
const ps = ["ctrl", "shift", "alt", "meta"],
	fs = {
		stop: e => e.stopPropagation(),
		prevent: e => e.preventDefault(),
		self: e => e.target !== e.currentTarget,
		ctrl: e => !e.ctrlKey,
		shift: e => !e.shiftKey,
		alt: e => !e.altKey,
		meta: e => !e.metaKey,
		left: e => "button" in e && 0 !== e.button,
		middle: e => "button" in e && 1 !== e.button,
		right: e => "button" in e && 2 !== e.button,
		exact: (e, t) => ps.some((n => e[`${n}Key`] && !t.includes(n)))
	},
	ms = (e, t) => (n, ...i) => {
		for (let e = 0; e < t.length; e++) {
			const i = fs[t[e]];
			if (i && i(n, t)) return
		}
		return e(n, ...i)
	},
	gs = A({
		patchProp: (e, t, n, i, r = !1, s, a, o, l) => {
			"class" === t ? function(e, t, n) {
				const i = e._vtc;
				i && (t = (t ? [t, ...i] : [...i]).join(" ")), null == t ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t
			}(e, i, r) : "style" === t ? function(e, t, n) {
				const i = e.style,
					r = i.display;
				if (n)
					if (F(n)) t !== n && (i.cssText = n);
					else {
						for (const e in n) kr(i, e, n[e]);
						if (t && !F(t))
							for (const e in t) null == n[e] && kr(i, e, "")
					}
				else e.removeAttribute("style");
				"_vod" in e && (i.display = r)
			}(e, n, i) : C(t) ? E(t) || Wr(e, t, 0, i, a) : ("." === t[0] ? (t = t.slice(1), 1) : "^" === t[0] ? (t = t.slice(1), 0) : function(e, t, n, i) {
				if (i) return "innerHTML" === t || "textContent" === t || !!(t in e && jr.test(t) && O(n));
				if ("spellcheck" === t || "draggable" === t) return !1;
				if ("form" === t) return !1;
				if ("list" === t && "INPUT" === e.tagName) return !1;
				if ("type" === t && "TEXTAREA" === e.tagName) return !1;
				if (jr.test(t) && F(n)) return !1;
				return t in e
			}(e, t, i, r)) ? function(e, t, n, i, r, s, a) {
				if ("innerHTML" === t || "textContent" === t) return i && a(i, r, s), void(e[t] = null == n ? "" : n);
				if ("value" === t && "PROGRESS" !== e.tagName) {
					e._value = n;
					const i = null == n ? "" : n;
					return e.value !== i && (e.value = i), void(null == n && e.removeAttribute(t))
				}
				if ("" === n || null == n) {
					const i = typeof e[t];
					if ("boolean" === i) return void(e[t] = h(n));
					if (null == n && "string" === i) return e[t] = "", void e.removeAttribute(t);
					if ("number" === i) {
						try {
							e[t] = 0
						} catch (o) {}
						return void e.removeAttribute(t)
					}
				}
				try {
					e[t] = n
				} catch (l) {}
			}(e, t, i, s, a, o, l) : ("true-value" === t ? e._trueValue = i : "false-value" === t && (e._falseValue = i), function(e, t, n, i, r) {
				if (i && t.startsWith("xlink:")) null == n ? e.removeAttributeNS(Fr, t.slice(6, t.length)) : e.setAttributeNS(Fr, t, n);
				else {
					const i = u(t);
					null == n || i && !h(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : n)
				}
			}(e, t, i, r))
		}
	}, Dr);
let vs;
const _s = (...e) => {
	const t = (vs || (vs = Jn(gs))).createApp(...e),
		{
			mount: n
		} = t;
	return t.mount = e => {
		const i = function(e) {
			if (F(e)) {
				return document.querySelector(e)
			}
			return e
		}(e);
		if (!i) return;
		const r = t._component;
		O(r) || r.render || r.template || (r.template = i.innerHTML), i.innerHTML = "";
		const s = n(i, !1, i instanceof SVGElement);
		return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), s
	}, t
};

function ys() {
	let e, t;
	const n = [],
		i = [];
	return {
		install: function(n) {
			e = n, t = e.mount.bind(e), e.mount = a.bind(e), e.onBeforeMount = r, e.onAfterMount = s
		}
	};

	function r(e, t) {
		t ? n.unshift(e) : n.push(e)
	}

	function s(e, t) {
		t ? i.unshift(e) : i.push(e)
	}

	function a(r, s) {
		for (const t of n) t(e);
		t(r, s);
		for (const t of i) t(e);
		i.length = n.length = 0
	}
}
const xs = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
	bs = e => xs ? Symbol(e) : "_vr_" + e,
	ws = bs("rvlm"),
	Ss = bs("rvd"),
	Ms = bs("r"),
	Ts = bs("rl"),
	Cs = bs("rvl"),
	Es = "undefined" != typeof window;
const As = Object.assign;

function Ps(e, t) {
	const n = {};
	for (const i in t) {
		const r = t[i];
		n[i] = Array.isArray(r) ? r.map(e) : e(r)
	}
	return n
}
const Ls = () => {};

function Is(e, t, n = "/") {
	let i, r = {},
		s = "",
		a = "";
	const o = t.indexOf("?"),
		l = t.indexOf("#", o > -1 ? o : 0);
	return o > -1 && (i = t.slice(0, o), s = t.slice(o + 1, l > -1 ? l : t.length), r = e(s)), l > -1 && (i = i || t.slice(0, l), a = t.slice(l, t.length)), i = function(e, t) {
		if (e.startsWith("/")) return e;
		if (!e) return t;
		const n = t.split("/"),
			i = e.split("/");
		let r, s, a = n.length - 1;
		for (r = 0; r < i.length; r++)
			if (s = i[r], 1 !== a && "." !== s) {
				if (".." !== s) break;
				a--
			} return n.slice(0, a).join("/") + "/" + i.slice(r - (r === i.length ? 1 : 0)).join("/")
	}(null != i ? i : t, n), {
		fullPath: i + (s && "?") + s + a,
		path: i,
		query: r,
		hash: a
	}
}

function Ds(e, t) {
	return (e.aliasOf || e) === (t.aliasOf || t)
}

function Rs(e, t) {
	if (Object.keys(e).length !== Object.keys(t).length) return !1;
	for (const n in e)
		if (!ks(e[n], t[n])) return !1;
	return !0
}

function ks(e, t) {
	return Array.isArray(e) ? Ns(e, t) : Array.isArray(t) ? Ns(t, e) : e === t
}

function Ns(e, t) {
	return Array.isArray(t) ? e.length === t.length && e.every(((e, n) => e === t[n])) : 1 === e.length && e[0] === t
}
var Os, Fs, zs, Us;
(Fs = Os || (Os = {})).pop = "pop", Fs.push = "push", (Us = zs || (zs = {})).back = "back", Us.forward = "forward", Us.unknown = "";
const Bs = /^[^#]+#/;

function Vs(e, t) {
	return e.replace(Bs, "#") + t
}

function Hs(e) {
	let t;
	if ("el" in e) {
		const n = e.el,
			i = "string" == typeof n && n.startsWith("#"),
			r = "string" == typeof n ? i ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
		if (!r) return;
		t = function(e, t) {
			const n = document.documentElement.getBoundingClientRect(),
				i = e.getBoundingClientRect();
			return {
				behavior: t.behavior,
				left: i.left - n.left - (t.left || 0),
				top: i.top - n.top - (t.top || 0)
			}
		}(r, e)
	} else t = e;
	"scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.pageXOffset, null != t.top ? t.top : window.pageYOffset)
}

function Gs(e, t) {
	return (history.state ? history.state.position - t : -1) + e
}
const Ws = new Map;

function qs(e = "") {
	let t = [],
		n = [""],
		i = 0;

	function r(e) {
		i++, i === n.length || n.splice(i), n.push(e)
	}
	const s = {
		location: "",
		state: {},
		base: e,
		createHref: Vs.bind(null, e),
		replace(e) {
			n.splice(i--, 1), r(e)
		},
		push(e, t) {
			r(e)
		},
		listen: e => (t.push(e), () => {
			const n = t.indexOf(e);
			n > -1 && t.splice(n, 1)
		}),
		destroy() {
			t = [], n = [""], i = 0
		},
		go(e, r = !0) {
			const s = this.location,
				a = e < 0 ? zs.back : zs.forward;
			i = Math.max(0, Math.min(i + e, n.length - 1)), r && function(e, n, {
				direction: i,
				delta: r
			}) {
				const s = {
					direction: i,
					delta: r,
					type: Os.pop
				};
				for (const a of t) a(e, n, s)
			}(this.location, s, {
				direction: a,
				delta: e
			})
		}
	};
	return Object.defineProperty(s, "location", {
		enumerable: !0,
		get: () => n[i]
	}), s
}

function js(e) {
	return "string" == typeof e || "symbol" == typeof e
}
const Ys = {
		path: "/",
		name: void 0,
		params: {},
		query: {},
		hash: "",
		fullPath: "/",
		matched: [],
		meta: {},
		redirectedFrom: void 0
	},
	Xs = bs("nf");
var $s, Zs;

function Ks(e, t) {
	return As(new Error, {
		type: e,
		[Xs]: !0
	}, t)
}

function Js(e, t) {
	return e instanceof Error && Xs in e && (null == t || !!(e.type & t))
}(Zs = $s || ($s = {}))[Zs.aborted = 4] = "aborted", Zs[Zs.cancelled = 8] = "cancelled", Zs[Zs.duplicated = 16] = "duplicated";
const Qs = {
		sensitive: !1,
		strict: !1,
		start: !0,
		end: !0
	},
	ea = /[.+*?^${}()[\]/\\]/g;

function ta(e, t) {
	let n = 0;
	for (; n < e.length && n < t.length;) {
		const i = t[n] - e[n];
		if (i) return i;
		n++
	}
	return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0
}

function na(e, t) {
	let n = 0;
	const i = e.score,
		r = t.score;
	for (; n < i.length && n < r.length;) {
		const e = ta(i[n], r[n]);
		if (e) return e;
		n++
	}
	return r.length - i.length
}
const ia = {
		type: 0,
		value: ""
	},
	ra = /[a-zA-Z0-9_]/;

function sa(e, t, n) {
	const i = function(e, t) {
			const n = As({}, Qs, t),
				i = [];
			let r = n.start ? "^" : "";
			const s = [];
			for (const l of e) {
				const e = l.length ? [] : [90];
				n.strict && !l.length && (r += "/");
				for (let t = 0; t < l.length; t++) {
					const i = l[t];
					let a = 40 + (n.sensitive ? .25 : 0);
					if (0 === i.type) t || (r += "/"), r += i.value.replace(ea, "\\$&"), a += 40;
					else if (1 === i.type) {
						const {
							value: e,
							repeatable: n,
							optional: c,
							regexp: u
						} = i;
						s.push({
							name: e,
							repeatable: n,
							optional: c
						});
						const h = u || "[^/]+?";
						if ("[^/]+?" !== h) {
							a += 10;
							try {
								new RegExp(`(${h})`)
							} catch (o) {
								throw new Error(`Invalid custom RegExp for param "${e}" (${h}): ` + o.message)
							}
						}
						let d = n ? `((?:${h})(?:/(?:${h}))*)` : `(${h})`;
						t || (d = c && l.length < 2 ? `(?:/${d})` : "/" + d), c && (d += "?"), r += d, a += 20, c && (a += -8), n && (a += -20), ".*" === h && (a += -50)
					}
					e.push(a)
				}
				i.push(e)
			}
			if (n.strict && n.end) {
				const e = i.length - 1;
				i[e][i[e].length - 1] += .7000000000000001
			}
			n.strict || (r += "/?"), n.end ? r += "$" : n.strict && (r += "(?:/|$)");
			const a = new RegExp(r, n.sensitive ? "" : "i");
			return {
				re: a,
				score: i,
				keys: s,
				parse: function(e) {
					const t = e.match(a),
						n = {};
					if (!t) return null;
					for (let i = 1; i < t.length; i++) {
						const e = t[i] || "",
							r = s[i - 1];
						n[r.name] = e && r.repeatable ? e.split("/") : e
					}
					return n
				},
				stringify: function(t) {
					let n = "",
						i = !1;
					for (const r of e) {
						i && n.endsWith("/") || (n += "/"), i = !1;
						for (const e of r)
							if (0 === e.type) n += e.value;
							else if (1 === e.type) {
							const {
								value: s,
								repeatable: a,
								optional: o
							} = e, l = s in t ? t[s] : "";
							if (Array.isArray(l) && !a) throw new Error(`Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`);
							const c = Array.isArray(l) ? l.join("/") : l;
							if (!c) {
								if (!o) throw new Error(`Missing required param "${s}"`);
								r.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : i = !0)
							}
							n += c
						}
					}
					return n
				}
			}
		}(function(e) {
			if (!e) return [
				[]
			];
			if ("/" === e) return [
				[ia]
			];
			if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

			function t(e) {
				throw new Error(`ERR (${n})/"${c}": ${e}`)
			}
			let n = 0,
				i = n;
			const r = [];
			let s;

			function a() {
				s && r.push(s), s = []
			}
			let o, l = 0,
				c = "",
				u = "";

			function h() {
				c && (0 === n ? s.push({
					type: 0,
					value: c
				}) : 1 === n || 2 === n || 3 === n ? (s.length > 1 && ("*" === o || "+" === o) && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
					type: 1,
					value: c,
					regexp: u,
					repeatable: "*" === o || "+" === o,
					optional: "*" === o || "?" === o
				})) : t("Invalid state to consume buffer"), c = "")
			}

			function d() {
				c += o
			}
			for (; l < e.length;)
				if (o = e[l++], "\\" !== o || 2 === n) switch (n) {
					case 0:
						"/" === o ? (c && h(), a()) : ":" === o ? (h(), n = 1) : d();
						break;
					case 4:
						d(), n = i;
						break;
					case 1:
						"(" === o ? n = 2 : ra.test(o) ? d() : (h(), n = 0, "*" !== o && "?" !== o && "+" !== o && l--);
						break;
					case 2:
						")" === o ? "\\" == u[u.length - 1] ? u = u.slice(0, -1) + o : n = 3 : u += o;
						break;
					case 3:
						h(), n = 0, "*" !== o && "?" !== o && "+" !== o && l--, u = "";
						break;
					default:
						t("Unknown state")
				} else i = n, n = 4;
			return 2 === n && t(`Unfinished custom RegExp for param "${c}"`), h(), a(), r
		}(e.path), n),
		r = As(i, {
			record: e,
			parent: t,
			children: [],
			alias: []
		});
	return t && !r.record.aliasOf == !t.record.aliasOf && t.children.push(r), r
}

function aa(e, t) {
	const n = [],
		i = new Map;

	function r(e, n, i) {
		const o = !i,
			l = function(e) {
				return {
					path: e.path,
					redirect: e.redirect,
					name: e.name,
					meta: e.meta || {},
					aliasOf: void 0,
					beforeEnter: e.beforeEnter,
					props: oa(e),
					children: e.children || [],
					instances: {},
					leaveGuards: new Set,
					updateGuards: new Set,
					enterCallbacks: {},
					components: "components" in e ? e.components || {} : {
						default: e.component
					}
				}
			}(e);
		l.aliasOf = i && i.record;
		const c = ua(t, e),
			u = [l];
		if ("alias" in e) {
			const t = "string" == typeof e.alias ? [e.alias] : e.alias;
			for (const e of t) u.push(As({}, l, {
				components: i ? i.record.components : l.components,
				path: e,
				aliasOf: i ? i.record : l
			}))
		}
		let h, d;
		for (const t of u) {
			const {
				path: u
			} = t;
			if (n && "/" !== u[0]) {
				const e = n.record.path,
					i = "/" === e[e.length - 1] ? "" : "/";
				t.path = n.record.path + (u && i + u)
			}
			if (h = sa(t, n, c), i ? i.alias.push(h) : (d = d || h, d !== h && d.alias.push(h), o && e.name && !la(h) && s(e.name)), "children" in l) {
				const e = l.children;
				for (let t = 0; t < e.length; t++) r(e[t], h, i && i.children[t])
			}
			i = i || h, a(h)
		}
		return d ? () => {
			s(d)
		} : Ls
	}

	function s(e) {
		if (js(e)) {
			const t = i.get(e);
			t && (i.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(s), t.alias.forEach(s))
		} else {
			const t = n.indexOf(e);
			t > -1 && (n.splice(t, 1), e.record.name && i.delete(e.record.name), e.children.forEach(s), e.alias.forEach(s))
		}
	}

	function a(e) {
		let t = 0;
		for (; t < n.length && na(e, n[t]) >= 0;) t++;
		n.splice(t, 0, e), e.record.name && !la(e) && i.set(e.record.name, e)
	}
	return t = ua({
		strict: !1,
		end: !0,
		sensitive: !1
	}, t), e.forEach((e => r(e))), {
		addRoute: r,
		resolve: function(e, t) {
			let r, s, a, o = {};
			if ("name" in e && e.name) {
				if (r = i.get(e.name), !r) throw Ks(1, {
					location: e
				});
				a = r.record.name, o = As(function(e, t) {
					const n = {};
					for (const i of t) i in e && (n[i] = e[i]);
					return n
				}(t.params, r.keys.filter((e => !e.optional)).map((e => e.name))), e.params), s = r.stringify(o)
			} else if ("path" in e) s = e.path, r = n.find((e => e.re.test(s))), r && (o = r.parse(s), a = r.record.name);
			else {
				if (r = t.name ? i.get(t.name) : n.find((e => e.re.test(t.path))), !r) throw Ks(1, {
					location: e,
					currentLocation: t
				});
				a = r.record.name, o = As({}, t.params, e.params), s = r.stringify(o)
			}
			const l = [];
			let c = r;
			for (; c;) l.unshift(c.record), c = c.parent;
			return {
				name: a,
				path: s,
				params: o,
				matched: l,
				meta: ca(l)
			}
		},
		removeRoute: s,
		getRoutes: function() {
			return n
		},
		getRecordMatcher: function(e) {
			return i.get(e)
		}
	}
}

function oa(e) {
	const t = {},
		n = e.props || !1;
	if ("component" in e) t.default = n;
	else
		for (const i in e.components) t[i] = "boolean" == typeof n ? n : n[i];
	return t
}

function la(e) {
	for (; e;) {
		if (e.record.aliasOf) return !0;
		e = e.parent
	}
	return !1
}

function ca(e) {
	return e.reduce(((e, t) => As(e, t.meta)), {})
}

function ua(e, t) {
	const n = {};
	for (const i in e) n[i] = i in t ? t[i] : e[i];
	return n
}
const ha = /#/g,
	da = /&/g,
	pa = /\//g,
	fa = /=/g,
	ma = /\?/g,
	va = /\+/g,
	_a = /%5B/g,
	ya = /%5D/g,
	xa = /%5E/g,
	ba = /%60/g,
	wa = /%7B/g,
	Sa = /%7C/g,
	Ma = /%7D/g,
	Ta = /%20/g;

function Ca(e) {
	return encodeURI("" + e).replace(Sa, "|").replace(_a, "[").replace(ya, "]")
}

function Ea(e) {
	return Ca(e).replace(va, "%2B").replace(Ta, "+").replace(ha, "%23").replace(da, "%26").replace(ba, "`").replace(wa, "{").replace(Ma, "}").replace(xa, "^")
}

function Aa(e) {
	return null == e ? "" : function(e) {
		return Ca(e).replace(ha, "%23").replace(ma, "%3F")
	}(e).replace(pa, "%2F")
}

function Pa(e) {
	try {
		return decodeURIComponent("" + e)
	} catch (t) {}
	return "" + e
}

function La(e) {
	const t = {};
	if ("" === e || "?" === e) return t;
	const n = ("?" === e[0] ? e.slice(1) : e).split("&");
	for (let i = 0; i < n.length; ++i) {
		const e = n[i].replace(va, " "),
			r = e.indexOf("="),
			s = Pa(r < 0 ? e : e.slice(0, r)),
			a = r < 0 ? null : Pa(e.slice(r + 1));
		if (s in t) {
			let e = t[s];
			Array.isArray(e) || (e = t[s] = [e]), e.push(a)
		} else t[s] = a
	}
	return t
}

function Ia(e) {
	let t = "";
	for (let n in e) {
		const i = e[n];
		if (n = Ea(n).replace(fa, "%3D"), null == i) {
			void 0 !== i && (t += (t.length ? "&" : "") + n);
			continue
		}(Array.isArray(i) ? i.map((e => e && Ea(e))) : [i && Ea(i)]).forEach((e => {
			void 0 !== e && (t += (t.length ? "&" : "") + n, null != e && (t += "=" + e))
		}))
	}
	return t
}

function Da(e) {
	const t = {};
	for (const n in e) {
		const i = e[n];
		void 0 !== i && (t[n] = Array.isArray(i) ? i.map((e => null == e ? null : "" + e)) : null == i ? i : "" + i)
	}
	return t
}

function Ra() {
	let e = [];
	return {
		add: function(t) {
			return e.push(t), () => {
				const n = e.indexOf(t);
				n > -1 && e.splice(n, 1)
			}
		},
		list: () => e,
		reset: function() {
			e = []
		}
	}
}

function ka(e, t, n, i, r) {
	const s = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
	return () => new Promise(((a, o) => {
		const l = e => {
				var l;
				!1 === e ? o(Ks(4, {
					from: n,
					to: t
				})) : e instanceof Error ? o(e) : "string" == typeof(l = e) || l && "object" == typeof l ? o(Ks(2, {
					from: t,
					to: e
				})) : (s && i.enterCallbacks[r] === s && "function" == typeof e && s.push(e), a())
			},
			c = e.call(i && i.instances[r], t, n, l);
		let u = Promise.resolve(c);
		e.length < 3 && (u = u.then(l)), u.catch((e => o(e)))
	}))
}

function Na(e, t, n, i) {
	const r = [];
	for (const a of e)
		for (const e in a.components) {
			let o = a.components[e];
			if ("beforeRouteEnter" === t || a.instances[e])
				if ("object" == typeof(s = o) || "displayName" in s || "props" in s || "__vccOpts" in s) {
					const s = (o.__vccOpts || o)[t];
					s && r.push(ka(s, n, i, a, e))
				} else {
					let s = o();
					r.push((() => s.then((r => {
						if (!r) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${a.path}"`));
						const s = (o = r).__esModule || xs && "Module" === o[Symbol.toStringTag] ? r.default : r;
						var o;
						a.components[e] = s;
						const l = (s.__vccOpts || s)[t];
						return l && ka(l, n, i, a, e)()
					}))))
				}
		}
	var s;
	return r
}

function Oa(e) {
	const t = Yt(Ms),
		n = Yt(Ts),
		i = Dt((() => t.resolve(At(e.to)))),
		r = Dt((() => {
			const {
				matched: e
			} = i.value, {
				length: t
			} = e, r = e[t - 1], s = n.matched;
			if (!r || !s.length) return -1;
			const a = s.findIndex(Ds.bind(null, r));
			if (a > -1) return a;
			const o = za(e[t - 2]);
			return t > 1 && za(r) === o && s[s.length - 1].path !== o ? s.findIndex(Ds.bind(null, e[t - 2])) : a
		})),
		s = Dt((() => r.value > -1 && function(e, t) {
			for (const n in t) {
				const i = t[n],
					r = e[n];
				if ("string" == typeof i) {
					if (i !== r) return !1
				} else if (!Array.isArray(r) || r.length !== i.length || i.some(((e, t) => e !== r[t]))) return !1
			}
			return !0
		}(n.params, i.value.params))),
		a = Dt((() => r.value > -1 && r.value === n.matched.length - 1 && Rs(n.params, i.value.params)));
	return {
		route: i,
		href: Dt((() => i.value.href)),
		isActive: s,
		isExactActive: a,
		navigate: function(n = {}) {
			return function(e) {
				if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
				if (e.defaultPrevented) return;
				if (void 0 !== e.button && 0 !== e.button) return;
				if (e.currentTarget && e.currentTarget.getAttribute) {
					const t = e.currentTarget.getAttribute("target");
					if (/\b_blank\b/i.test(t)) return
				}
				e.preventDefault && e.preventDefault();
				return !0
			}(n) ? t[At(e.replace) ? "replace" : "push"](At(e.to)).catch(Ls) : Promise.resolve()
		}
	}
}
const Fa = nn({
	name: "RouterLink",
	props: {
		to: {
			type: [String, Object],
			required: !0
		},
		replace: Boolean,
		activeClass: String,
		exactActiveClass: String,
		custom: Boolean,
		ariaCurrentValue: {
			type: String,
			default: "page"
		}
	},
	useLink: Oa,
	setup(e, {
		slots: t
	}) {
		const n = dt(Oa(e)),
			{
				options: i
			} = Yt(Ms),
			r = Dt((() => ({
				[Ua(e.activeClass, i.linkActiveClass, "router-link-active")]: n.isActive,
				[Ua(e.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
			})));
		return () => {
			const i = t.default && t.default(n);
			return e.custom ? i : Ar("a", {
				"aria-current": n.isExactActive ? e.ariaCurrentValue : null,
				href: n.href,
				onClick: n.navigate,
				class: r.value
			}, i)
		}
	}
});

function za(e) {
	return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const Ua = (e, t, n) => null != e ? e : null != t ? t : n;

function Ba(e, t) {
	if (!e) return null;
	const n = e(t);
	return 1 === n.length ? n[0] : n
}
const Va = nn({
	name: "RouterView",
	inheritAttrs: !1,
	props: {
		name: {
			type: String,
			default: "default"
		},
		route: Object
	},
	setup(e, {
		attrs: t,
		slots: n
	}) {
		const i = Yt(Cs),
			r = Dt((() => e.route || i.value)),
			s = Yt(Ss, 0),
			a = Dt((() => r.value.matched[s]));
		jt(Ss, s + 1), jt(ws, a), jt(Cs, r);
		const o = Tt();
		return Sr((() => [o.value, a.value, e.name]), (([e, t, n], [i, r, s]) => {
			t && (t.instances[n] = e, r && r !== t && e && e === i && (t.leaveGuards.size || (t.leaveGuards = r.leaveGuards), t.updateGuards.size || (t.updateGuards = r.updateGuards))), !e || !t || r && Ds(t, r) && i || (t.enterCallbacks[n] || []).forEach((t => t(e)))
		}), {
			flush: "post"
		}), () => {
			const i = r.value,
				s = a.value,
				l = s && s.components[e.name],
				c = e.name;
			if (!l) return Ba(n.default, {
				Component: l,
				route: i
			});
			const u = s.props[e.name],
				h = u ? !0 === u ? i.params : "function" == typeof u ? u(i) : u : null,
				d = Ar(l, As({}, h, t, {
					onVnodeUnmounted: e => {
						e.component.isUnmounted && (s.instances[c] = null)
					},
					ref: o
				}));
			return Ba(n.default, {
				Component: d,
				route: i
			}) || d
		}
	}
});

function Ha(e) {
	const t = aa(e.routes, e),
		n = e.parseQuery || La,
		i = e.stringifyQuery || Ia,
		r = e.history,
		s = Ra(),
		a = Ra(),
		o = Ra(),
		l = Ct(Ys, !0);
	let c = Ys;
	Es && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
	const u = Ps.bind(null, (e => "" + e)),
		h = Ps.bind(null, Aa),
		d = Ps.bind(null, Pa);

	function p(e, s) {
		if (s = As({}, s || l.value), "string" == typeof e) {
			const i = Is(n, e, s.path),
				a = t.resolve({
					path: i.path
				}, s),
				o = r.createHref(i.fullPath);
			return As(i, a, {
				params: d(a.params),
				hash: Pa(i.hash),
				redirectedFrom: void 0,
				href: o
			})
		}
		let a;
		if ("path" in e) a = As({}, e, {
			path: Is(n, e.path, s.path).path
		});
		else {
			const t = As({}, e.params);
			for (const e in t) null == t[e] && delete t[e];
			a = As({}, e, {
				params: h(e.params)
			}), s.params = h(s.params)
		}
		const o = t.resolve(a, s),
			c = e.hash || "";
		o.params = u(d(o.params));
		const p = function(e, t) {
			const n = t.query ? e(t.query) : "";
			return t.path + (n && "?") + n + (t.hash || "")
		}(i, As({}, e, {
			hash: (f = c, Ca(f).replace(wa, "{").replace(Ma, "}").replace(xa, "^")),
			path: o.path
		}));
		var f;
		const m = r.createHref(p);
		return As({
			fullPath: p,
			hash: c,
			query: i === Ia ? Da(e.query) : e.query || {}
		}, o, {
			redirectedFrom: void 0,
			href: m
		})
	}

	function f(e) {
		return "string" == typeof e ? Is(n, e, l.value.path) : As({}, e)
	}

	function m(e, t) {
		if (c !== e) return Ks(8, {
			from: t,
			to: e
		})
	}

	function g(e) {
		return _(e)
	}

	function v(e) {
		const t = e.matched[e.matched.length - 1];
		if (t && t.redirect) {
			const {
				redirect: n
			} = t;
			let i = "function" == typeof n ? n(e) : n;
			return "string" == typeof i && (i = i.includes("?") || i.includes("#") ? i = f(i) : {
				path: i
			}, i.params = {}), As({
				query: e.query,
				hash: e.hash,
				params: e.params
			}, i)
		}
	}

	function _(e, t) {
		const n = c = p(e),
			r = l.value,
			s = e.state,
			a = e.force,
			o = !0 === e.replace,
			u = v(n);
		if (u) return _(As(f(u), {
			state: s,
			force: a,
			replace: o
		}), t || n);
		const h = n;
		let d;
		return h.redirectedFrom = t, !a && function(e, t, n) {
			const i = t.matched.length - 1,
				r = n.matched.length - 1;
			return i > -1 && i === r && Ds(t.matched[i], n.matched[r]) && Rs(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
		}(i, r, n) && (d = Ks(16, {
			to: h,
			from: r
		}), L(r, r, !0, !1)), (d ? Promise.resolve(d) : x(h, r)).catch((e => Js(e) ? e : A(e, h, r))).then((e => {
			if (e) {
				if (Js(e, 2)) return _(As(f(e.to), {
					state: s,
					force: a,
					replace: o
				}), t || h)
			} else e = w(h, r, !0, o, s);
			return b(h, r, e), e
		}))
	}

	function y(e, t) {
		const n = m(e, t);
		return n ? Promise.reject(n) : Promise.resolve()
	}

	function x(e, t) {
		let n;
		const [i, r, o] = function(e, t) {
			const n = [],
				i = [],
				r = [],
				s = Math.max(t.matched.length, e.matched.length);
			for (let a = 0; a < s; a++) {
				const s = t.matched[a];
				s && (e.matched.find((e => Ds(e, s))) ? i.push(s) : n.push(s));
				const o = e.matched[a];
				o && (t.matched.find((e => Ds(e, o))) || r.push(o))
			}
			return [n, i, r]
		}(e, t);
		n = Na(i.reverse(), "beforeRouteLeave", e, t);
		for (const s of i) s.leaveGuards.forEach((i => {
			n.push(ka(i, e, t))
		}));
		const l = y.bind(null, e, t);
		return n.push(l), Ga(n).then((() => {
			n = [];
			for (const i of s.list()) n.push(ka(i, e, t));
			return n.push(l), Ga(n)
		})).then((() => {
			n = Na(r, "beforeRouteUpdate", e, t);
			for (const i of r) i.updateGuards.forEach((i => {
				n.push(ka(i, e, t))
			}));
			return n.push(l), Ga(n)
		})).then((() => {
			n = [];
			for (const i of e.matched)
				if (i.beforeEnter && !t.matched.includes(i))
					if (Array.isArray(i.beforeEnter))
						for (const r of i.beforeEnter) n.push(ka(r, e, t));
					else n.push(ka(i.beforeEnter, e, t));
			return n.push(l), Ga(n)
		})).then((() => (e.matched.forEach((e => e.enterCallbacks = {})), n = Na(o, "beforeRouteEnter", e, t), n.push(l), Ga(n)))).then((() => {
			n = [];
			for (const i of a.list()) n.push(ka(i, e, t));
			return n.push(l), Ga(n)
		})).catch((e => Js(e, 8) ? e : Promise.reject(e)))
	}

	function b(e, t, n) {
		for (const i of o.list()) i(e, t, n)
	}

	function w(e, t, n, i, s) {
		const a = m(e, t);
		if (a) return a;
		const o = t === Ys,
			c = Es ? history.state : {};
		n && (i || o ? r.replace(e.fullPath, As({
			scroll: o && c && c.scroll
		}, s)) : r.push(e.fullPath, s)), l.value = e, L(e, t, n, o), P()
	}
	let S;

	function M() {
		S = r.listen(((e, t, n) => {
			const i = p(e),
				s = v(i);
			if (s) return void _(As(s, {
				replace: !0
			}), i).catch(Ls);
			c = i;
			const a = l.value;
			var o, u;
			Es && (o = Gs(a.fullPath, n.delta), u = {
				left: window.pageXOffset,
				top: window.pageYOffset
			}, Ws.set(o, u)), x(i, a).catch((e => Js(e, 12) ? e : Js(e, 2) ? (_(e.to, i).then((e => {
				Js(e, 20) && !n.delta && n.type === Os.pop && r.go(-1, !1)
			})).catch(Ls), Promise.reject()) : (n.delta && r.go(-n.delta, !1), A(e, i, a)))).then((e => {
				(e = e || w(i, a, !1)) && (n.delta ? r.go(-n.delta, !1) : n.type === Os.pop && Js(e, 20) && r.go(-1, !1)), b(i, a, e)
			})).catch(Ls)
		}))
	}
	let T, C = Ra(),
		E = Ra();

	function A(e, t, n) {
		P(e);
		const i = E.list();
		return i.length && i.forEach((i => i(e, t, n))), Promise.reject(e)
	}

	function P(e) {
		T || (T = !0, M(), C.list().forEach((([t, n]) => e ? n(e) : t())), C.reset())
	}

	function L(t, n, i, r) {
		const {
			scrollBehavior: s
		} = e;
		if (!Es || !s) return Promise.resolve();
		const a = !i && function(e) {
			const t = Ws.get(e);
			return Ws.delete(e), t
		}(Gs(t.fullPath, 0)) || (r || !i) && history.state && history.state.scroll || null;
		return pr().then((() => s(t, n, a))).then((e => e && Hs(e))).catch((e => A(e, t, n)))
	}
	const I = e => r.go(e);
	let D;
	const R = new Set;
	return {
		currentRoute: l,
		addRoute: function(e, n) {
			let i, r;
			return js(e) ? (i = t.getRecordMatcher(e), r = n) : r = e, t.addRoute(r, i)
		},
		removeRoute: function(e) {
			const n = t.getRecordMatcher(e);
			n && t.removeRoute(n)
		},
		hasRoute: function(e) {
			return !!t.getRecordMatcher(e)
		},
		getRoutes: function() {
			return t.getRoutes().map((e => e.record))
		},
		resolve: p,
		options: e,
		push: g,
		replace: function(e) {
			return g(As(f(e), {
				replace: !0
			}))
		},
		go: I,
		back: () => I(-1),
		forward: () => I(1),
		beforeEach: s.add,
		beforeResolve: a.add,
		afterEach: o.add,
		onError: E.add,
		isReady: function() {
			return T && l.value !== Ys ? Promise.resolve() : new Promise(((e, t) => {
				C.add([e, t])
			}))
		},
		install(e) {
			e.component("RouterLink", Fa), e.component("RouterView", Va), e.config.globalProperties.$router = this, Object.defineProperty(e.config.globalProperties, "$route", {
				enumerable: !0,
				get: () => At(l)
			}), Es && !D && l.value === Ys && (D = !0, g(r.location).catch((e => {})));
			const t = {};
			for (const i in Ys) t[i] = Dt((() => l.value[i]));
			e.provide(Ms, this), e.provide(Ts, dt(t)), e.provide(Cs, l);
			const n = e.unmount;
			R.add(e), e.unmount = function() {
				R.delete(e), R.size < 1 && (c = Ys, S && S(), l.value = Ys, D = !1, T = !1), n()
			}
		}
	}
}

function Ga(e) {
	return e.reduce(((e, t) => e.then((() => t()))), Promise.resolve())
}

function Wa() {
	return Yt(Ms)
}

function qa() {
	return Yt(Ts)
}
var ja = {
		update: null,
		begin: null,
		loopBegin: null,
		changeBegin: null,
		change: null,
		changeComplete: null,
		loopComplete: null,
		complete: null,
		loop: 1,
		direction: "normal",
		autoplay: !0,
		timelineOffset: 0
	},
	Ya = {
		duration: 1e3,
		delay: 0,
		endDelay: 0,
		easing: "easeOutElastic(1, .5)",
		round: 0
	},
	Xa = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
	$a = {
		CSS: {},
		springs: {}
	};

function Za(e, t, n) {
	return Math.min(Math.max(e, t), n)
}

function Ka(e, t) {
	return e.indexOf(t) > -1
}

function Ja(e, t) {
	return e.apply(null, t)
}
var Qa = {
	arr: function(e) {
		return Array.isArray(e)
	},
	obj: function(e) {
		return Ka(Object.prototype.toString.call(e), "Object")
	},
	pth: function(e) {
		return Qa.obj(e) && e.hasOwnProperty("totalLength")
	},
	svg: function(e) {
		return e instanceof SVGElement
	},
	inp: function(e) {
		return e instanceof HTMLInputElement
	},
	dom: function(e) {
		return e.nodeType || Qa.svg(e)
	},
	str: function(e) {
		return "string" == typeof e
	},
	fnc: function(e) {
		return "function" == typeof e
	},
	und: function(e) {
		return void 0 === e
	},
	nil: function(e) {
		return Qa.und(e) || null === e
	},
	hex: function(e) {
		return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)
	},
	rgb: function(e) {
		return /^rgb/.test(e)
	},
	hsl: function(e) {
		return /^hsl/.test(e)
	},
	col: function(e) {
		return Qa.hex(e) || Qa.rgb(e) || Qa.hsl(e)
	},
	key: function(e) {
		return !ja.hasOwnProperty(e) && !Ya.hasOwnProperty(e) && "targets" !== e && "keyframes" !== e
	}
};

function eo(e) {
	var t = /\(([^)]+)\)/.exec(e);
	return t ? t[1].split(",").map((function(e) {
		return parseFloat(e)
	})) : []
}

function to(e, t) {
	var n = eo(e),
		i = Za(Qa.und(n[0]) ? 1 : n[0], .1, 100),
		r = Za(Qa.und(n[1]) ? 100 : n[1], .1, 100),
		s = Za(Qa.und(n[2]) ? 10 : n[2], .1, 100),
		a = Za(Qa.und(n[3]) ? 0 : n[3], .1, 100),
		o = Math.sqrt(r / i),
		l = s / (2 * Math.sqrt(r * i)),
		c = l < 1 ? o * Math.sqrt(1 - l * l) : 0,
		u = l < 1 ? (l * o - a) / c : -a + o;

	function h(e) {
		var n = t ? t * e / 1e3 : e;
		return n = l < 1 ? Math.exp(-n * l * o) * (1 * Math.cos(c * n) + u * Math.sin(c * n)) : (1 + u * n) * Math.exp(-n * o), 0 === e || 1 === e ? e : 1 - n
	}
	return t ? h : function() {
		var t = $a.springs[e];
		if (t) return t;
		for (var n = 1 / 6, i = 0, r = 0;;)
			if (1 === h(i += n)) {
				if (++r >= 16) break
			} else r = 0;
		var s = i * n * 1e3;
		return $a.springs[e] = s, s
	}
}

function no(e) {
	return void 0 === e && (e = 10),
		function(t) {
			return Math.ceil(Za(t, 1e-6, 1) * e) * (1 / e)
		}
}
var io, ro, so = function() {
		var e = .1;

		function t(e, t) {
			return 1 - 3 * t + 3 * e
		}

		function n(e, t) {
			return 3 * t - 6 * e
		}

		function i(e) {
			return 3 * e
		}

		function r(e, r, s) {
			return ((t(r, s) * e + n(r, s)) * e + i(r)) * e
		}

		function s(e, r, s) {
			return 3 * t(r, s) * e * e + 2 * n(r, s) * e + i(r)
		}
		return function(t, n, i, a) {
			if (0 <= t && t <= 1 && 0 <= i && i <= 1) {
				var o = new Float32Array(11);
				if (t !== n || i !== a)
					for (var l = 0; l < 11; ++l) o[l] = r(l * e, t, i);
				return function(e) {
					return t === n && i === a || 0 === e || 1 === e ? e : r(c(e), n, a)
				}
			}

			function c(n) {
				for (var a = 0, l = 1; 10 !== l && o[l] <= n; ++l) a += e;
				--l;
				var c = a + (n - o[l]) / (o[l + 1] - o[l]) * e,
					u = s(c, t, i);
				return u >= .001 ? function(e, t, n, i) {
					for (var a = 0; a < 4; ++a) {
						var o = s(t, n, i);
						if (0 === o) return t;
						t -= (r(t, n, i) - e) / o
					}
					return t
				}(n, c, t, i) : 0 === u ? c : function(e, t, n, i, s) {
					var a, o, l = 0;
					do {
						(a = r(o = t + (n - t) / 2, i, s) - e) > 0 ? n = o : t = o
					} while (Math.abs(a) > 1e-7 && ++l < 10);
					return o
				}(n, a, a + e, t, i)
			}
		}
	}(),
	ao = (io = {
		linear: function() {
			return function(e) {
				return e
			}
		}
	}, ro = {
		Sine: function() {
			return function(e) {
				return 1 - Math.cos(e * Math.PI / 2)
			}
		},
		Circ: function() {
			return function(e) {
				return 1 - Math.sqrt(1 - e * e)
			}
		},
		Back: function() {
			return function(e) {
				return e * e * (3 * e - 2)
			}
		},
		Bounce: function() {
			return function(e) {
				for (var t, n = 4; e < ((t = Math.pow(2, --n)) - 1) / 11;);
				return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((3 * t - 2) / 22 - e, 2)
			}
		},
		Elastic: function(e, t) {
			void 0 === e && (e = 1), void 0 === t && (t = .5);
			var n = Za(e, 1, 10),
				i = Za(t, .1, 2);
			return function(e) {
				return 0 === e || 1 === e ? e : -n * Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1 - i / (2 * Math.PI) * Math.asin(1 / n)) * (2 * Math.PI) / i)
			}
		}
	}, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach((function(e, t) {
		ro[e] = function() {
			return function(e) {
				return Math.pow(e, t + 2)
			}
		}
	})), Object.keys(ro).forEach((function(e) {
		var t = ro[e];
		io["easeIn" + e] = t, io["easeOut" + e] = function(e, n) {
			return function(i) {
				return 1 - t(e, n)(1 - i)
			}
		}, io["easeInOut" + e] = function(e, n) {
			return function(i) {
				return i < .5 ? t(e, n)(2 * i) / 2 : 1 - t(e, n)(-2 * i + 2) / 2
			}
		}, io["easeOutIn" + e] = function(e, n) {
			return function(i) {
				return i < .5 ? (1 - t(e, n)(1 - 2 * i)) / 2 : (t(e, n)(2 * i - 1) + 1) / 2
			}
		}
	})), io);

function oo(e, t) {
	if (Qa.fnc(e)) return e;
	var n = e.split("(")[0],
		i = ao[n],
		r = eo(e);
	switch (n) {
		case "spring":
			return to(e, t);
		case "cubicBezier":
			return Ja(so, r);
		case "steps":
			return Ja(no, r);
		default:
			return Ja(i, r)
	}
}

function lo(e) {
	try {
		return document.querySelectorAll(e)
	} catch (t) {
		return
	}
}

function co(e, t) {
	for (var n = e.length, i = arguments.length >= 2 ? arguments[1] : void 0, r = [], s = 0; s < n; s++)
		if (s in e) {
			var a = e[s];
			t.call(i, a, s, e) && r.push(a)
		} return r
}

function uo(e) {
	return e.reduce((function(e, t) {
		return e.concat(Qa.arr(t) ? uo(t) : t)
	}), [])
}

function ho(e) {
	return Qa.arr(e) ? e : (Qa.str(e) && (e = lo(e) || e), e instanceof NodeList || e instanceof HTMLCollection ? [].slice.call(e) : [e])
}

function po(e, t) {
	return e.some((function(e) {
		return e === t
	}))
}

function fo(e) {
	var t = {};
	for (var n in e) t[n] = e[n];
	return t
}

function mo(e, t) {
	var n = fo(e);
	for (var i in e) n[i] = t.hasOwnProperty(i) ? t[i] : e[i];
	return n
}

function go(e, t) {
	var n = fo(e);
	for (var i in t) n[i] = Qa.und(e[i]) ? t[i] : e[i];
	return n
}

function vo(e) {
	return Qa.rgb(e) ? (n = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(t = e)) ? "rgba(" + n[1] + ",1)" : t : Qa.hex(e) ? function(e) {
		var t = e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (function(e, t, n, i) {
				return t + t + n + n + i + i
			})),
			n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
		return "rgba(" + parseInt(n[1], 16) + "," + parseInt(n[2], 16) + "," + parseInt(n[3], 16) + ",1)"
	}(e) : Qa.hsl(e) ? function(e) {
		var t, n, i, r = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e),
			s = parseInt(r[1], 10) / 360,
			a = parseInt(r[2], 10) / 100,
			o = parseInt(r[3], 10) / 100,
			l = r[4] || 1;

		function c(e, t, n) {
			return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
		}
		if (0 == a) t = n = i = o;
		else {
			var u = o < .5 ? o * (1 + a) : o + a - o * a,
				h = 2 * o - u;
			t = c(h, u, s + 1 / 3), n = c(h, u, s), i = c(h, u, s - 1 / 3)
		}
		return "rgba(" + 255 * t + "," + 255 * n + "," + 255 * i + "," + l + ")"
	}(e) : void 0;
	var t, n
}

function _o(e) {
	var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(e);
	if (t) return t[1]
}

function yo(e, t) {
	return Qa.fnc(e) ? e(t.target, t.id, t.total) : e
}

function xo(e, t) {
	return e.getAttribute(t)
}

function bo(e, t, n) {
	if (po([n, "deg", "rad", "turn"], _o(t))) return t;
	var i = $a.CSS[t + n];
	if (!Qa.und(i)) return i;
	var r = document.createElement(e.tagName),
		s = e.parentNode && e.parentNode !== document ? e.parentNode : document.body;
	s.appendChild(r), r.style.position = "absolute", r.style.width = 100 + n;
	var a = 100 / r.offsetWidth;
	s.removeChild(r);
	var o = a * parseFloat(t);
	return $a.CSS[t + n] = o, o
}

function wo(e, t, n) {
	if (t in e.style) {
		var i = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
			r = e.style[t] || getComputedStyle(e).getPropertyValue(i) || "0";
		return n ? bo(e, r, n) : r
	}
}

function So(e, t) {
	return Qa.dom(e) && !Qa.inp(e) && (!Qa.nil(xo(e, t)) || Qa.svg(e) && e[t]) ? "attribute" : Qa.dom(e) && po(Xa, t) ? "transform" : Qa.dom(e) && "transform" !== t && wo(e, t) ? "css" : null != e[t] ? "object" : void 0
}

function Mo(e) {
	if (Qa.dom(e)) {
		for (var t, n = e.style.transform || "", i = /(\w+)\(([^)]*)\)/g, r = new Map; t = i.exec(n);) r.set(t[1], t[2]);
		return r
	}
}

function To(e, t, n, i) {
	var r = Ka(t, "scale") ? 1 : 0 + function(e) {
			return Ka(e, "translate") || "perspective" === e ? "px" : Ka(e, "rotate") || Ka(e, "skew") ? "deg" : void 0
		}(t),
		s = Mo(e).get(t) || r;
	return n && (n.transforms.list.set(t, s), n.transforms.last = t), i ? bo(e, s, i) : s
}

function Co(e, t, n, i) {
	switch (So(e, t)) {
		case "transform":
			return To(e, t, i, n);
		case "css":
			return wo(e, t, n);
		case "attribute":
			return xo(e, t);
		default:
			return e[t] || 0
	}
}

function Eo(e, t) {
	var n = /^(\*=|\+=|-=)/.exec(e);
	if (!n) return e;
	var i = _o(e) || 0,
		r = parseFloat(t),
		s = parseFloat(e.replace(n[0], ""));
	switch (n[0][0]) {
		case "+":
			return r + s + i;
		case "-":
			return r - s + i;
		case "*":
			return r * s + i
	}
}

function Ao(e, t) {
	if (Qa.col(e)) return vo(e);
	if (/\s/g.test(e)) return e;
	var n = _o(e),
		i = n ? e.substr(0, e.length - n.length) : e;
	return t ? i + t : i
}

function Po(e, t) {
	return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}

function Lo(e) {
	for (var t, n = e.points, i = 0, r = 0; r < n.numberOfItems; r++) {
		var s = n.getItem(r);
		r > 0 && (i += Po(t, s)), t = s
	}
	return i
}

function Io(e) {
	if (e.getTotalLength) return e.getTotalLength();
	switch (e.tagName.toLowerCase()) {
		case "circle":
			return function(e) {
				return 2 * Math.PI * xo(e, "r")
			}(e);
		case "rect":
			return function(e) {
				return 2 * xo(e, "width") + 2 * xo(e, "height")
			}(e);
		case "line":
			return function(e) {
				return Po({
					x: xo(e, "x1"),
					y: xo(e, "y1")
				}, {
					x: xo(e, "x2"),
					y: xo(e, "y2")
				})
			}(e);
		case "polyline":
			return Lo(e);
		case "polygon":
			return function(e) {
				var t = e.points;
				return Lo(e) + Po(t.getItem(t.numberOfItems - 1), t.getItem(0))
			}(e)
	}
}

function Do(e, t) {
	var n = t || {},
		i = n.el || function(e) {
			for (var t = e.parentNode; Qa.svg(t) && Qa.svg(t.parentNode);) t = t.parentNode;
			return t
		}(e),
		r = i.getBoundingClientRect(),
		s = xo(i, "viewBox"),
		a = r.width,
		o = r.height,
		l = n.viewBox || (s ? s.split(" ") : [0, 0, a, o]);
	return {
		el: i,
		viewBox: l,
		x: l[0] / 1,
		y: l[1] / 1,
		w: a,
		h: o,
		vW: l[2],
		vH: l[3]
	}
}

function Ro(e, t, n) {
	function i(n) {
		void 0 === n && (n = 0);
		var i = t + n >= 1 ? t + n : 0;
		return e.el.getPointAtLength(i)
	}
	var r = Do(e.el, e.svg),
		s = i(),
		a = i(-1),
		o = i(1),
		l = n ? 1 : r.w / r.vW,
		c = n ? 1 : r.h / r.vH;
	switch (e.property) {
		case "x":
			return (s.x - r.x) * l;
		case "y":
			return (s.y - r.y) * c;
		case "angle":
			return 180 * Math.atan2(o.y - a.y, o.x - a.x) / Math.PI
	}
}

function ko(e, t) {
	var n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
		i = Ao(Qa.pth(e) ? e.totalLength : e, t) + "";
	return {
		original: i,
		numbers: i.match(n) ? i.match(n).map(Number) : [0],
		strings: Qa.str(e) || t ? i.split(n) : []
	}
}

function No(e) {
	return co(e ? uo(Qa.arr(e) ? e.map(ho) : ho(e)) : [], (function(e, t, n) {
		return n.indexOf(e) === t
	}))
}

function Oo(e) {
	var t = No(e);
	return t.map((function(e, n) {
		return {
			target: e,
			id: n,
			total: t.length,
			transforms: {
				list: Mo(e)
			}
		}
	}))
}

function Fo(e, t) {
	var n = fo(t);
	if (/^spring/.test(n.easing) && (n.duration = to(n.easing)), Qa.arr(e)) {
		var i = e.length;
		2 === i && !Qa.obj(e[0]) ? e = {
			value: e
		} : Qa.fnc(t.duration) || (n.duration = t.duration / i)
	}
	var r = Qa.arr(e) ? e : [e];
	return r.map((function(e, n) {
		var i = Qa.obj(e) && !Qa.pth(e) ? e : {
			value: e
		};
		return Qa.und(i.delay) && (i.delay = n ? 0 : t.delay), Qa.und(i.endDelay) && (i.endDelay = n === r.length - 1 ? t.endDelay : 0), i
	})).map((function(e) {
		return go(e, n)
	}))
}

function zo(e, t) {
	var n = [],
		i = t.keyframes;
	for (var r in i && (t = go(function(e) {
			for (var t = co(uo(e.map((function(e) {
					return Object.keys(e)
				}))), (function(e) {
					return Qa.key(e)
				})).reduce((function(e, t) {
					return e.indexOf(t) < 0 && e.push(t), e
				}), []), n = {}, i = function(i) {
					var r = t[i];
					n[r] = e.map((function(e) {
						var t = {};
						for (var n in e) Qa.key(n) ? n == r && (t.value = e[n]) : t[n] = e[n];
						return t
					}))
				}, r = 0; r < t.length; r++) i(r);
			return n
		}(i), t)), t) Qa.key(r) && n.push({
		name: r,
		tweens: Fo(t[r], e)
	});
	return n
}

function Uo(e, t) {
	var n;
	return e.tweens.map((function(i) {
		var r = function(e, t) {
				var n = {};
				for (var i in e) {
					var r = yo(e[i], t);
					Qa.arr(r) && 1 === (r = r.map((function(e) {
						return yo(e, t)
					}))).length && (r = r[0]), n[i] = r
				}
				return n.duration = parseFloat(n.duration), n.delay = parseFloat(n.delay), n
			}(i, t),
			s = r.value,
			a = Qa.arr(s) ? s[1] : s,
			o = _o(a),
			l = Co(t.target, e.name, o, t),
			c = n ? n.to.original : l,
			u = Qa.arr(s) ? s[0] : c,
			h = _o(u) || _o(l),
			d = o || h;
		return Qa.und(a) && (a = c), r.from = ko(u, d), r.to = ko(Eo(a, u), d), r.start = n ? n.end : 0, r.end = r.start + r.delay + r.duration + r.endDelay, r.easing = oo(r.easing, r.duration), r.isPath = Qa.pth(s), r.isPathTargetInsideSVG = r.isPath && Qa.svg(t.target), r.isColor = Qa.col(r.from.original), r.isColor && (r.round = 1), n = r, r
	}))
}
var Bo = {
	css: function(e, t, n) {
		return e.style[t] = n
	},
	attribute: function(e, t, n) {
		return e.setAttribute(t, n)
	},
	object: function(e, t, n) {
		return e[t] = n
	},
	transform: function(e, t, n, i, r) {
		if (i.list.set(t, n), t === i.last || r) {
			var s = "";
			i.list.forEach((function(e, t) {
				s += t + "(" + e + ") "
			})), e.style.transform = s
		}
	}
};

function Vo(e, t) {
	Oo(e).forEach((function(e) {
		for (var n in t) {
			var i = yo(t[n], e),
				r = e.target,
				s = _o(i),
				a = Co(r, n, s, e),
				o = Eo(Ao(i, s || _o(a)), a),
				l = So(r, n);
			Bo[l](r, n, o, e.transforms, !0)
		}
	}))
}

function Ho(e, t) {
	return co(uo(e.map((function(e) {
		return t.map((function(t) {
			return function(e, t) {
				var n = So(e.target, t.name);
				if (n) {
					var i = Uo(t, e),
						r = i[i.length - 1];
					return {
						type: n,
						property: t.name,
						animatable: e,
						tweens: i,
						duration: r.end,
						delay: i[0].delay,
						endDelay: r.endDelay
					}
				}
			}(e, t)
		}))
	}))), (function(e) {
		return !Qa.und(e)
	}))
}

function Go(e, t) {
	var n = e.length,
		i = function(e) {
			return e.timelineOffset ? e.timelineOffset : 0
		},
		r = {};
	return r.duration = n ? Math.max.apply(Math, e.map((function(e) {
		return i(e) + e.duration
	}))) : t.duration, r.delay = n ? Math.min.apply(Math, e.map((function(e) {
		return i(e) + e.delay
	}))) : t.delay, r.endDelay = n ? r.duration - Math.max.apply(Math, e.map((function(e) {
		return i(e) + e.duration - e.endDelay
	}))) : t.endDelay, r
}
var Wo = 0;
var qo = [],
	jo = function() {
		var e;

		function t(n) {
			for (var i = qo.length, r = 0; r < i;) {
				var s = qo[r];
				s.paused ? (qo.splice(r, 1), i--) : (s.tick(n), r++)
			}
			e = r > 0 ? requestAnimationFrame(t) : void 0
		}
		return "undefined" != typeof document && document.addEventListener("visibilitychange", (function() {
				Xo.suspendWhenDocumentHidden && (Yo() ? e = cancelAnimationFrame(e) : (qo.forEach((function(e) {
					return e._onDocumentVisibility()
				})), jo()))
			})),
			function() {
				e || Yo() && Xo.suspendWhenDocumentHidden || !(qo.length > 0) || (e = requestAnimationFrame(t))
			}
	}();

function Yo() {
	return !!document && document.hidden
}

function Xo(e) {
	void 0 === e && (e = {});
	var t, n = 0,
		i = 0,
		r = 0,
		s = 0,
		a = null;

	function o(e) {
		var t = window.Promise && new Promise((function(e) {
			return a = e
		}));
		return e.finished = t, t
	}
	var l = function(e) {
		var t = mo(ja, e),
			n = mo(Ya, e),
			i = zo(n, e),
			r = Oo(e.targets),
			s = Ho(r, i),
			a = Go(s, n),
			o = Wo;
		return Wo++, go(t, {
			id: o,
			children: [],
			animatables: r,
			animations: s,
			duration: a.duration,
			delay: a.delay,
			endDelay: a.endDelay
		})
	}(e);

	function c() {
		var e = l.direction;
		"alternate" !== e && (l.direction = "normal" !== e ? "normal" : "reverse"), l.reversed = !l.reversed, t.forEach((function(e) {
			return e.reversed = l.reversed
		}))
	}

	function u(e) {
		return l.reversed ? l.duration - e : e
	}

	function h() {
		n = 0, i = u(l.currentTime) * (1 / Xo.speed)
	}

	function d(e, t) {
		t && t.seek(e - t.timelineOffset)
	}

	function p(e) {
		for (var t = 0, n = l.animations, i = n.length; t < i;) {
			var r = n[t],
				s = r.animatable,
				a = r.tweens,
				o = a.length - 1,
				c = a[o];
			o && (c = co(a, (function(t) {
				return e < t.end
			}))[0] || c);
			for (var u = Za(e - c.start - c.delay, 0, c.duration) / c.duration, h = isNaN(u) ? 1 : c.easing(u), d = c.to.strings, p = c.round, f = [], m = c.to.numbers.length, g = void 0, v = 0; v < m; v++) {
				var _ = void 0,
					y = c.to.numbers[v],
					x = c.from.numbers[v] || 0;
				_ = c.isPath ? Ro(c.value, h * y, c.isPathTargetInsideSVG) : x + h * (y - x), p && (c.isColor && v > 2 || (_ = Math.round(_ * p) / p)), f.push(_)
			}
			var b = d.length;
			if (b) {
				g = d[0];
				for (var w = 0; w < b; w++) {
					d[w];
					var S = d[w + 1],
						M = f[w];
					isNaN(M) || (g += S ? M + S : M + " ")
				}
			} else g = f[0];
			Bo[r.type](s.target, r.property, g, s.transforms), r.currentValue = g, t++
		}
	}

	function f(e) {
		l[e] && !l.passThrough && l[e](l)
	}

	function m(e) {
		var h = l.duration,
			m = l.delay,
			g = h - l.endDelay,
			v = u(e);
		l.progress = Za(v / h * 100, 0, 100), l.reversePlayback = v < l.currentTime, t && function(e) {
			if (l.reversePlayback)
				for (var n = s; n--;) d(e, t[n]);
			else
				for (var i = 0; i < s; i++) d(e, t[i])
		}(v), !l.began && l.currentTime > 0 && (l.began = !0, f("begin")), !l.loopBegan && l.currentTime > 0 && (l.loopBegan = !0, f("loopBegin")), v <= m && 0 !== l.currentTime && p(0), (v >= g && l.currentTime !== h || !h) && p(h), v > m && v < g ? (l.changeBegan || (l.changeBegan = !0, l.changeCompleted = !1, f("changeBegin")), f("change"), p(v)) : l.changeBegan && (l.changeCompleted = !0, l.changeBegan = !1, f("changeComplete")), l.currentTime = Za(v, 0, h), l.began && f("update"), e >= h && (i = 0, l.remaining && !0 !== l.remaining && l.remaining--, l.remaining ? (n = r, f("loopComplete"), l.loopBegan = !1, "alternate" === l.direction && c()) : (l.paused = !0, l.completed || (l.completed = !0, f("loopComplete"), f("complete"), !l.passThrough && "Promise" in window && (a(), o(l)))))
	}
	return o(l), l.reset = function() {
		var e = l.direction;
		l.passThrough = !1, l.currentTime = 0, l.progress = 0, l.paused = !0, l.began = !1, l.loopBegan = !1, l.changeBegan = !1, l.completed = !1, l.changeCompleted = !1, l.reversePlayback = !1, l.reversed = "reverse" === e, l.remaining = l.loop, t = l.children;
		for (var n = s = t.length; n--;) l.children[n].reset();
		(l.reversed && !0 !== l.loop || "alternate" === e && 1 === l.loop) && l.remaining++, p(l.reversed ? l.duration : 0)
	}, l._onDocumentVisibility = h, l.set = function(e, t) {
		return Vo(e, t), l
	}, l.tick = function(e) {
		r = e, n || (n = r), m((r + (i - n)) * Xo.speed)
	}, l.seek = function(e) {
		m(u(e))
	}, l.pause = function() {
		l.paused = !0, h()
	}, l.play = function() {
		l.paused && (l.completed && l.reset(), l.paused = !1, qo.push(l), h(), jo())
	}, l.reverse = function() {
		c(), l.completed = !l.reversed, h()
	}, l.restart = function() {
		l.reset(), l.play()
	}, l.remove = function(e) {
		Zo(No(e), l)
	}, l.reset(), l.autoplay && l.play(), l
}

function $o(e, t) {
	for (var n = t.length; n--;) po(e, t[n].animatable.target) && t.splice(n, 1)
}

function Zo(e, t) {
	var n = t.animations,
		i = t.children;
	$o(e, n);
	for (var r = i.length; r--;) {
		var s = i[r],
			a = s.animations;
		$o(e, a), a.length || s.children.length || i.splice(r, 1)
	}
	n.length || i.length || t.pause()
}
Xo.version = "3.2.1", Xo.speed = 1, Xo.suspendWhenDocumentHidden = !0, Xo.running = qo, Xo.remove = function(e) {
	for (var t = No(e), n = qo.length; n--;) {
		Zo(t, qo[n])
	}
}, Xo.get = Co, Xo.set = Vo, Xo.convertPx = bo, Xo.path = function(e, t) {
	var n = Qa.str(e) ? lo(e)[0] : e,
		i = t || 100;
	return function(e) {
		return {
			property: e,
			el: n,
			svg: Do(n),
			totalLength: Io(n) * (i / 100)
		}
	}
}, Xo.setDashoffset = function(e) {
	var t = Io(e);
	return e.setAttribute("stroke-dasharray", t), t
}, Xo.stagger = function(e, t) {
	void 0 === t && (t = {});
	var n = t.direction || "normal",
		i = t.easing ? oo(t.easing) : null,
		r = t.grid,
		s = t.axis,
		a = t.from || 0,
		o = "first" === a,
		l = "center" === a,
		c = "last" === a,
		u = Qa.arr(e),
		h = u ? parseFloat(e[0]) : parseFloat(e),
		d = u ? parseFloat(e[1]) : 0,
		p = _o(u ? e[1] : e) || 0,
		f = t.start || 0 + (u ? h : 0),
		m = [],
		g = 0;
	return function(e, t, v) {
		if (o && (a = 0), l && (a = (v - 1) / 2), c && (a = v - 1), !m.length) {
			for (var _ = 0; _ < v; _++) {
				if (r) {
					var y = l ? (r[0] - 1) / 2 : a % r[0],
						x = l ? (r[1] - 1) / 2 : Math.floor(a / r[0]),
						b = y - _ % r[0],
						w = x - Math.floor(_ / r[0]),
						S = Math.sqrt(b * b + w * w);
					"x" === s && (S = -b), "y" === s && (S = -w), m.push(S)
				} else m.push(Math.abs(a - _));
				g = Math.max.apply(Math, m)
			}
			i && (m = m.map((function(e) {
				return i(e / g) * g
			}))), "reverse" === n && (m = m.map((function(e) {
				return s ? e < 0 ? -1 * e : -e : Math.abs(g - e)
			})))
		}
		return f + (u ? (d - h) / g : h) * (Math.round(100 * m[t]) / 100) + p
	}
}, Xo.timeline = function(e) {
	void 0 === e && (e = {});
	var t = Xo(e);
	return t.duration = 0, t.add = function(n, i) {
		var r = qo.indexOf(t),
			s = t.children;

		function a(e) {
			e.passThrough = !0
		}
		r > -1 && qo.splice(r, 1);
		for (var o = 0; o < s.length; o++) a(s[o]);
		var l = go(n, mo(Ya, e));
		l.targets = l.targets || e.targets;
		var c = t.duration;
		l.autoplay = !1, l.direction = t.direction, l.timelineOffset = Qa.und(i) ? c : Eo(i, c), a(t), t.seek(l.timelineOffset);
		var u = Xo(l);
		a(u), s.push(u);
		var h = Go(s, e);
		return t.delay = h.delay, t.endDelay = h.endDelay, t.duration = h.duration, t.seek(0), t.reset(), t.autoplay && t.play(), t
	}, t
}, Xo.easing = oo, Xo.penner = ao, Xo.random = function(e, t) {
	return Math.floor(Math.random() * (t - e + 1)) + e
};
const Ko = {
	linear: [.25, .25, .75, .75],
	inSine: [.47, 0, .745, .715],
	outSine: [.39, .575, .565, 1],
	inOutSine: [.445, .05, .55, .95],
	inQuad: [.55, .085, .68, .53],
	outQuad: [.25, .46, .45, .94],
	inOutQuad: [.455, .03, .515, .955],
	inCubic: [.55, .055, .675, .19],
	outCubic: [.215, .61, .355, 1],
	inOutCubic: [.645, .045, .355, 1],
	inQuart: [.895, .03, .685, .22],
	outQuart: [.165, .84, .44, 1],
	inOutQuart: [.77, 0, .175, 1],
	inQuint: [.755, .05, .855, .06],
	outQuint: [.23, 1, .32, 1],
	inOutQuint: [.86, 0, .07, 1],
	inExpo: [.95, .05, .795, .035],
	outExpo: [.19, 1, .22, 1],
	inOutExpo: [1, 0, 0, 1],
	inCirc: [.6, .04, .98, .335],
	outCirc: [.075, .82, .165, 1],
	inOutCirc: [.785, .135, .15, .86],
	outSwift: [.55, 0, .1, 1],
	snap2: [0, .975, 0, 1],
	bounce: [.18, .89, .34, 1.76],
	bounce2: [.865, -.005, 0, 1.47],
	bounce3: [.865, -.005, 0, 1.64],
	bounce4: [0, 1.49, .105, .94],
	hardBounce: [.07, 1.525, .36, .935],
	longKeyframe: [.49, .05, .32, 1.04],
	elastic: [0, .49, .205, 1]
};
var Jo = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
	Qo = "function" == typeof Float32Array;

function el(e, t) {
	return 1 - 3 * t + 3 * e
}

function tl(e, t) {
	return 3 * t - 6 * e
}

function nl(e) {
	return 3 * e
}

function il(e, t, n) {
	return ((el(t, n) * e + tl(t, n)) * e + nl(t)) * e
}

function rl(e, t, n) {
	return 3 * el(t, n) * e * e + 2 * tl(t, n) * e + nl(t)
}

function sl(e) {
	return e
}
var al = function(e, t, n, i) {
	if (!(0 <= e && e <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
	if (e === t && n === i) return sl;
	for (var r = Qo ? new Float32Array(11) : new Array(11), s = 0; s < 11; ++s) r[s] = il(.1 * s, e, n);

	function a(t) {
		for (var i = 0, s = 1; 10 !== s && r[s] <= t; ++s) i += .1;
		--s;
		var a = i + .1 * ((t - r[s]) / (r[s + 1] - r[s])),
			o = rl(a, e, n);
		return o >= .001 ? function(e, t, n, i) {
			for (var r = 0; r < 4; ++r) {
				var s = rl(t, n, i);
				if (0 === s) return t;
				t -= (il(t, n, i) - e) / s
			}
			return t
		}(t, a, e, n) : 0 === o ? a : function(e, t, n, i, r) {
			var s, a, o = 0;
			do {
				(s = il(a = t + (n - t) / 2, i, r) - e) > 0 ? n = a : t = a
			} while (Math.abs(s) > 1e-7 && ++o < 10);
			return a
		}(t, i, i + .1, e, n)
	}
	return function(e) {
		return 0 === e ? 0 : 1 === e ? 1 : il(a(e), t, i)
	}
};
let ol = 0;
const ll = () => ++ol,
	cl = (e, t) => void 0 !== e ? e : t,
	ul = new Set(["opacity", "transform"]),
	hl = new Set(["target", "ease", "duration", "delay", "willChange"]),
	dl = new Map,
	pl = [],
	fl = [],
	ml = [];
let gl = !1;

function vl() {
	let e, t;
	for (e = 0, t = pl.length; e < t; e++) pl[e]();
	for (e = 0, t = fl.length; e < t; e++) fl[e]();
	for (e = 0, t = ml.length; e < t; e++) ml[e]();
	pl.length = 0, fl.length = 0, ml.length = 0, gl = !1
}
const _l = "function" == typeof window.queueMicrotask ? () => queueMicrotask(vl) : () => Promise.resolve().then(vl);
const yl = function(e, t, n) {
	e && pl.push(e), t && fl.push(t), n && ml.push(n), gl || (gl = !0, _l())
};

function xl(e, t = 1e3, n = "linear", i = 0) {
	Ko[n] && (n = Ko[n]);
	return `${e} ${t}ms ${Array.isArray(n)?`cubic-bezier(${n.join(",")})`:n} ${i}ms`
}

function bl(e = {}) {
	let t = e.complete;
	const n = !!e.instant,
		i = !!e.willChange;
	let r = e.target;
	e.selector && (r = r.querySelector(e.selector));
	const s = {
		easing: e.ease || e.easing || "linear",
		duration: e.duration || 1e3,
		delay: e.delay || 0
	};
	r.dataset.csstween || (r.dataset.csstween = ll());
	const a = r.dataset.csstween;
	let o = null,
		l = new Promise((e => o = e));
	e.queue && e.queue.push(l);
	const c = {
			destroy: x,
			stop: x,
			finished: l
		},
		u = new Set;
	let h = null,
		d = !1;
	const p = [],
		f = [],
		m = {},
		g = {};
	let v = 0;
	for (const b in e) {
		if (hl.has(b)) continue;
		if (void 0 === r.style[b]) continue;
		const t = e[b];
		if (null == t) continue;
		const i = "object" != typeof t || Array.isArray(t) ? {
				value: t
			} : t,
			a = cl(i.duration, s.duration),
			o = cl(i.delay, s.delay),
			l = cl(i.easing, s.easing);
		f.push(xl(b, a, l, o)), v = Math.max(v, a + o);
		const c = Array.isArray(i.value) ? i.value : [null, i.value];
		(n || o <= 0 && (!a || a <= 0)) && (c[0] = c[1], c[1] = null), null !== c[0] && (m[b] = c[0]), null !== c[1] && (g[b] = c[1]), ul.has(b) && p.push(b)
	}
	return yl((function() {
		if (d) return;
		dl.has(a) && dl.get(a).destroy();
		dl.set(a, c), r.style.animation = "", i && p.length > 0 && (r.style.willChange = p.join(", "));
		if (Object.keys(m).length > 0)
			for (const e in m) r.style[e] = m[e]
	}), (function() {
		if (d) return;
		r.getBoundingClientRect()
	}), (function() {
		if (d) return;
		if (Object.keys(g).length > 0) {
			r.style.transition = f.join(", ");
			for (const e in g) r.style[e] = g[e], u.add(e);
			r.addEventListener("transitionend", y), r.addEventListener("webkitTransitionEnd", y), h = window.setTimeout(_, 1.1 * v + 200)
		} else _()
	})), c;

	function _() {
		d || (window.clearTimeout(h), t && t(), o(), x())
	}

	function y(e) {
		r.style.willChange = "", u.delete(e.propertyName), u.size < 1 && _()
	}

	function x() {
		d || (window.clearTimeout(h), h = null, r.style.transition = "", r.style.animation = "", r.removeEventListener("transitionend", y), r.removeEventListener("webkitTransitionEnd", y), dl.delete(a), u.clear(), r = null, l = null, t = null, o = null, d = !0)
	}
}

function wl(e = {}) {
	let t = e.complete,
		n = e.start,
		i = e.target;
	e.selector && (i = i.querySelector(e.selector));
	const r = function(e) {
			return e || (e = "linear"), Ko[e] && (e = Ko[e]), Array.isArray(e) ? `cubic-bezier(${e.join(",")})` : e
		}(e.ease || e.easing),
		s = !!e.instant,
		a = !!e.willChange,
		o = e.delay || 0,
		l = s ? "0ms" : e.duration || 1e3,
		c = e.fillMode || "forwards",
		u = e.direction || "normal",
		h = e.animation || e.name || "pop",
		d = l + o,
		p = [h, l + "ms", r, o > 0 ? o + "ms" : null, 1, u, c].filter((e => null !== e)).join(" ");
	i.dataset.csstween || (i.dataset.csstween = ll());
	const f = i.dataset.csstween;
	let m = null,
		g = new Promise((e => m = e));
	e.queue && e.queue.push(g);
	const v = {
		destroy: S,
		stop: S,
		finished: g
	};
	let _ = null,
		y = !1;
	return yl((function() {
		if (y) return;
		dl.has(f) && dl.get(f).destroy();
		dl.set(f, v), i.style.animation = ""
	}), (function() {
		if (y || !i) return;
		i.getBoundingClientRect()
	}), (function() {
		if (y || !i) return;
		i.addEventListener("animationstart", b), i.addEventListener("webkitAnimationStart", b), i.addEventListener("animationend", w), i.addEventListener("webkitAnimationEnd", w), a && (i.style.willChange = "transform, opacity");
		i.style.animation = p, _ = window.setTimeout(x, 1.1 * d + 200)
	})), v;

	function x() {
		y || (window.clearTimeout(_), m && m(), t && t(i), S())
	}

	function b(e) {
		n && n(i, e), n = null, i.removeEventListener("animationstart", b), i.removeEventListener("webkitAnimationStart", b)
	}

	function w() {
		i.style.willChange = "", x()
	}

	function S() {
		y || (window.clearTimeout(_), _ = null, i.removeEventListener("animationend", w), i.removeEventListener("webkitAnimationEnd", w), i.removeEventListener("animationstart", b), i.removeEventListener("webkitAnimationStart", b), dl.delete(f), i = null, g = null, t = null, n = null, m = null, y = !0)
	}
}

function Sl() {
	const e = [];
	return Gi() && vn((() => n())), {
		csstween: function(e) {
			return t(e, bl)
		},
		cssanimate: function(e) {
			return t(e, wl)
		},
		clear: n
	};

	function t(t, n) {
		const i = n(t);
		return (null == t.autoClear || t.autoClear) && e.push(i), i
	}

	function n(t) {
		for (let n = e.length - 1; n >= 0; n--) {
			const i = e[n];
			i && i.destroy ? t && i.target !== t || (i.destroy(), e.splice(n, 1)) : e.splice(n, 1)
		}
	}
}
let Ml = null,
	Tl = {};

function Cl(e) {
	return Ml = _s(e), Tl = Ml.config.globalProperties, Ml.provide("appProps", Tl), Ml
}

function El() {
	return Yt("appProps") || Tl
}

function Al() {
	return Tl
}

function Pl(e) {
	if (!window.isOldBrowser) {
		const t = document;
		"l" === t.readyState[0] ? t.addEventListener("DOMContentLoaded", e) : e()
	}
}
const Ll = new Proxy({}, {
		get: (e, t) => Tl[t]
	}),
	Il = [];
let Dl = {},
	Rl = null;
let kl = null;

function Nl() {
	return kl
}
const Ol = new Proxy({}, {
		get: (e, t) => kl[t]
	}),
	Fl = function(e) {
		Rl && e(Dl), Il.push(e)
	};
var zl = (e, t) => {
	const n = e.__vccOpts || e;
	for (const [i, r] of t) n[i] = r;
	return n
};
var Ul = zl({
	props: {
		to: {
			type: [String, Object],
			default: null
		},
		href: {
			type: String,
			default: null
		},
		text: {
			type: String,
			default: null
		},
		type: {
			type: String,
			default: null
		}
	},
	setup(e, {
		expose: t
	}) {
		const n = e,
			i = Tt();

		function r() {
			const e = Nl();
			e && e.audio.playSound("UI_Hover_Tiny")
		}
		t({
			text: i
		});
		const s = n.to ? Fa : n.href ? "a" : "button";
		return (e, t) => (pi(), _i(ri(At(s)), {
			to: n.to,
			href: n.href,
			class: "cta",
			type: n.type,
			onMouseenter: r
		}, {
			default: Vt((() => [Mi("p", {
				ref: (e, t) => {
					t.text = e, i.value = e
				},
				class: "cta__text"
			}, y(n.text), 513), Ni(e.$slots, "default", {}, void 0, !0)])),
			_: 3
		}, 8, ["to", "href", "type"]))
	}
}, [
	["__scopeId", "data-v-393c1b9c"]
]);
const Bl = e => (Ut("data-v-38f76d36"), e = e(), Bt(), e),
	Vl = ["innerHTML"],
	Hl = {
		class: "borders"
	},
	Gl = Bl((() => Mi("div", null, null, -1))),
	Wl = Bl((() => Mi("div", null, null, -1))),
	ql = {
		key: 0,
		class: "big-line"
	};
var jl = zl({
	props: [
		["icon", String, ""],
		["noBigLine", Boolean, !1],
		["isEmpty", Boolean, !1],
		["transparent", Boolean, !1],
		["to", [String, Object], null],
		["href", String, null],
		["text", String, ""],
		["smallText", Boolean, !1],
		["type", String, null]
	].reduce(((e, t) => (e[t[0]] = {
		value: t[1],
		default: t[2]
	}, e)), {}),
	setup(e) {
		const t = e,
			n = Tt(),
			i = Tt();

		function r() {
			n.value && (i.value.classList.add("hoverIn"), i.value.getBoundingClientRect(), i.value.classList.remove("hoverIn"), bl({
				target: n.value.text,
				transform: ["translateX(-1em)", ""],
				easing: "snap2",
				duration: 2e3
			}))
		}

		function s() {
			n.value && bl({
				target: n.value.text,
				transform: ["scale(0.85)", ""],
				easing: "outQuint",
				duration: 350
			})
		}

		function a() {
			if (!i.value) return;
			const e = Nl();
			e && e.audio.playSound("UI_Validate_Big"), i.value.classList.add("onClick"), i.value.getBoundingClientRect(), i.value.classList.remove("onClick")
		}
		const o = {
			next: '<svg width="43" height="43" viewBox="0 0 43 43" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="21.749" y="1.475" width="28.671" height="28.671" rx="1.5" transform="rotate(45 21.749 1.475)" fill="#fff" stroke="url(#a)"/><path d="M23 21.5 17.886 17H13l4.886 4.5L13 26h4.886L23 21.5Z" fill="#DD2527" fill-opacity=".3"/><path d="M31 21.5 25.886 17H21l4.886 4.5L21 26h4.886L31 21.5Z" fill="#DD2526"/><defs><linearGradient id="a" x1="22.091" y1="30.452" x2="49.668" y2="2.875" gradientUnits="userSpaceOnUse"><stop stop-color="#E1E1E1"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient></defs></svg>',
			play: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 43 43" style="enable-background:new 0 0 43 43" xml:space="preserve"><path d="M28.5 20.6c.5.3.6.9.3 1.4-.1.1-.2.3-.3.3L8.4 34.6c-.5.3-1.1.1-1.4-.3-.1-.2-.1-.3-.1-.5V9.3c0-.6.4-1 1-1 .2 0 .4.1.5.1l20.1 12.2z" style="fill:#fff"/><path d="M37.5 20.6c.5.3.6.9.3 1.4-.1.1-.2.3-.3.3L17.4 34.6c-.5.3-1.1.1-1.4-.3-.1-.2-.1-.3-.1-.5V9.3c0-.6.4-1 1-1 .2 0 .4.1.5.1l20.1 12.2z" style="opacity:.33;fill:#fff;enable-background:new"/></svg>\n'
		} [t.icon];
		return (e, l) => (pi(), vi("div", {
			ref: (e, t) => {
				t.base = e, i.value = e
			},
			class: g(["framed", {
				isSkew: t.skew
			}]),
			onMouseenter: r,
			onMouseleave: s,
			onMousedown: a,
			onTouchdown: a
		}, [t.text.length > 0 ? (pi(), _i(Ul, {
			key: 0,
			ref: (e, t) => {
				t.cta = e, n.value = e
			},
			to: t.to,
			text: t.text,
			href: t.href,
			class: g({
				smallSize: t.smallText
			}),
			type: t.type
		}, null, 8, ["to", "text", "href", "class", "type"])) : Pi("", !0), At(o) ? (pi(), vi("div", {
			key: 1,
			class: "icon",
			innerHTML: At(o)
		}, null, 8, Vl)) : Pi("", !0), Mi("figure", Hl, [Gl, Wl, t.noBigLine ? Pi("", !0) : (pi(), vi("div", ql))])], 34))
	}
}, [
	["__scopeId", "data-v-38f76d36"]
]);
const Yl = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 1250.22 135.73",
		class: "gameLogo"
	},
	Xl = [Ai('<path class="cls-1" d="M55.2,43.47l.09-.58H.58L6.76,3.11H173.38L167,42.89H112.33l-.07.42-14.18,89H41Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-2" d="M220,132.34H163.13L183.73,3.11h56.86L233.47,47l-.1.58h72.79l.07-.42,7.14-44h56.86l-20.6,129.23H292.77l7.48-47.21.09-.58H227.55l-.06.42Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-3" d="M424.65,98.5h91.24l-5.3,33.84H362.79L383.39,3.11H530.13l-5.46,33.48h-90.6L434,37,432.07,49.8l-.08.57h89.35l-5.29,33H426.51l-.07.42-2.28,14.17-.1.58Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-4" d="M564.13,132.77,584.82,3H715c14.88,0,26.52,2.5,34.42,7.55s12.08,12.6,12.08,22.89a30.29,30.29,0,0,1-10.72,23.65c-6.34,5.53-14.65,8.84-22.45,10.32l0,1a35.59,35.59,0,0,1,17.79,10.72l-30.83,49.84-2.39,3.86H689.66c-.48-1.06-.48-2.63,0-5.57h0l2.47-14.77h0c1.16-7.1.34-12.87-3.32-16.86s-10-6-19.61-6H628.14l-.06.42-6.83,42.83Zm69.25-77.29-.1.58H686c5.64,0,9.4-1.43,11.75-3.58A10.14,10.14,0,0,0,701,44.83a7.78,7.78,0,0,0-2.82-6.45c-2-1.6-5.14-2.49-9.7-2.49H636.63l-.07.42Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-5" d="M889.6,76c0,10.45,2,21.6,7.73,31.79,5.49,9.71,14.42,18.52,28.33,25H873.35L867.8,115l-.11-.35h-69l-.15.25-10.45,17.86H730.4L810.71,3H890.3l10.18,28.87a76.06,76.06,0,0,0-9.73,27.93A104.43,104.43,0,0,0,889.6,76Zm-70.06,2.91-.44.76h37.95l-.2-.65L844.31,38.53,844,37.45l-.57,1Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-6" d="M903.64,76h0a97.32,97.32,0,0,1,1.06-14.87c1.84-12.06,6.49-27.18,20.88-39.29S964.17.5,1005.27.5h6.19c37.15,0,59.29,7.21,72.23,16.64l-6.24,39.15h-35.69A16.3,16.3,0,0,0,1036,46.1c-4.87-4.21-13.75-7.92-30-7.92-18.64,0-29.4,5-35.49,11.7s-7.41,15.21-7.41,22c0,6.52,1.93,12.87,7.41,17.59s14.4,7.7,28.25,7.7c16.69,0,26.31-4.11,31.92-8.66a23.92,23.92,0,0,0,7.57-10.5,1.34,1.34,0,0,0,.07-.18H1074L1067,122.19c-14.07,7.63-35.07,13-66.63,13h-6.18c-37.22,0-59.84-7.73-73.14-19S903.64,90.27,903.64,76Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path><path class="cls-7" d="M1143.67,98.78h91.66l-5.33,34H1081.53L1102.22,3h147.41l-5.49,33.64h-91l-.07.42-1.94,12.84-.09.57h89.76l-5.32,33.11h-89.94l-.06.42-2.3,14.24-.09.58Z" stroke-width="1" stroke="#fff" fill="#fff" data-v-7a5f33f4></path>', 7)];
var $l = zl({
	setup: e => (e, t) => (pi(), vi("svg", Yl, Xl))
}, [
	["__scopeId", "data-v-7a5f33f4"]
]);
const Zl = () => {},
	Kl = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(((e, t) => (e[t] = 1, e)), {}),
	Jl = "ARROWUP",
	Ql = [Jl, Jl, "ARROWDOWN", "ARROWDOWN", "ARROWLEFT", "ARROWRIGHT", "ARROWLEFT", "ARROWRIGHT", "B", "A"],
	ec = {};
let tc = 0,
	nc = !1,
	ic = Zl;

function rc() {
	for (const e in ec) ec[e] = !1;
	tc = 0
}

function sc(e) {
	if (Kl[e.tagName]) return;
	const t = e.key.toUpperCase();
	ec[t] || function(e) {
		if (e !== Ql[tc]) return tc = 0;
		tc++, tc >= Ql.length && (tc = 0, ic())
	}(t), ec[t] = !0
}

function ac(e) {
	const t = e.key.toUpperCase();
	ec[t] = !1
}
var oc = {
	start: function() {
		! function(e, t = "log", n = "console") {
			window[n][t]("%c                 %cB  %cA ", "font-size: 16px; background: black; color: #aaa;", "font-size: 16px; background: black; color: #fd605b;", "font-size: 16px; background: black; color: #32c850;")
		}(), nc || (rc(), window.addEventListener("keydown", sc), window.addEventListener("keyup", ac), document.addEventListener("visibilitychange", rc), nc = !0)
	},
	stop: function() {
		nc && (rc(), window.removeEventListener("keydown", sc), window.removeEventListener("keyup", ac), document.removeEventListener("visibilitychange", rc), nc = !1)
	},
	reset: rc,
	get callback() {
		return ic
	},
	set callback(e) {
		ic = e || Zl
	}
};
const lc = {
		class: "home__container"
	},
	cc = {
		class: "home__title"
	},
	uc = (e => (Ut("data-v-20f8a6d9"), e = e(), Bt(), e))((() => Mi("div", {
		class: "legal_trad reference"
	}, " * ", -1))),
	hc = {
		class: "legal_trad mention"
	},
	dc = {
		async beforeRouteEnter() {}
	};
var pc = zl(Object.assign(dc, {
	setup: function(e, {
		expose: t
	}) {
		const {
			csstween: n
		} = Sl();

		function i() {
			Ll.$stats.event({
				name: "start"
			})
		}

		function r() {
			window.KONAMI_ACTIVE = !0, Ll.$router.push({
				name: "qrcode-home"
			})
		}
		return pn((() => {
			oc.start(), oc.callback = r, Ll.$rtcDisplay.disable(), Ll.$stats.pageview({
				title: "home",
				url: "/"
			})
		})), vn((() => {
			oc.callback = null, oc.stop()
		})), t({
			enter: async function(e) {
				Ol.audio.setBgm("intro"), Ll.$stores.isPlaying = !1, Ol.audio.playSound("UI_Title_TheRace", {
					delay: 1500
				}), Xo.timeline().add({
					targets: ".gameLogo",
					translateY: {
						value: [0, 30],
						duration: 1500,
						easing: "cubicBezier(.2,0,.15,1)"
					},
					scale: {
						value: [1.8, 1],
						easing: "cubicBezier(.2,0,.15,1)",
						duration: 1500
					}
				}).add({
					targets: ".gameLogo path",
					strokeDashoffset: [Xo.setDashoffset, 0],
					duration: 1500,
					easing: "cubicBezier(.87,0,.13,1)",
					delay: Xo.stagger(80)
				}, "-=1500").add({
					targets: ".gameLogo path",
					fillOpacity: [0, 1],
					duration: 500,
					easing: "cubicBezier(.87,0,.13,1)",
					delay: Xo.stagger(80)
				}, "-=1400").add({
					targets: ".gameLogo",
					translateY: 0,
					duration: 1e3,
					easing: "cubicBezier(.6,0,0,1)"
				}, "-=500").add({
					targets: ".home__cta",
					translateY: ["50%", "0%"],
					opacity: [0, 1],
					duration: 800,
					easing: "cubicBezier(.2,0,.15,1)"
				}, "-=700")
			},
			leave: async function(e) {
				return n({
					target: e,
					transform: ["", "scale3d(0.6,0.6,0.6)"],
					duration: 800,
					ease: "cubic-bezier(.87,0,.13,1)",
					opacity: ["", 0],
					autoClear: !1
				}).finished
			}
		}), (e, t) => (pi(), vi("section", {
			class: g(["page page-home home", {
				hidden: e.$stores.menuOpen
			}])
		}, [Mi("div", lc, [Mi("h1", cc, [Ti($l), uc]), Ti(jl, {
			to: {
				name: "game"
			},
			text: e.$l("home.cta.start"),
			icon: "next",
			class: "home__cta",
			onClickPassive: i
		}, null, 8, ["text"])]), Mi("div", hc, y(e.$l("home.legal")), 1)], 2))
	}
}), [
	["__scopeId", "data-v-20f8a6d9"]
]);
const fc = {
		"/src/stores/index.js": Object.freeze({
			__proto__: null,
			[Symbol.toStringTag]: "Module",
			default: e => {
				const t = window.__DATA.site.locales[window.__DATA.site.locale],
					n = dt({
						pb: 0,
						muted: !1,
						menuOpen: !1,
						gamePaused: !1,
						needTimer: !1,
						isPlaying: !1,
						cookieVisible: !1,
						cookieAccepted: !1,
						gameTutorialVisible: !1,
						remoteCountDownFinished: !1,
						keysVisible: !1,
						webRtc: !1,
						noForm: !!t.noForm,
						noCookie: !!t.noCookie
					});
				return e.onBeforeMount((() => {
					n.pb = localStorage.getItem("score_highscore") || 0;
					const t = localStorage.getItem("muted");
					n.muted = null != t && !!+t, br((() => {
						const e = n.muted;
						localStorage.setItem("muted", +!!e)
					}));
					const i = e.config.globalProperties;
					br((() => {
						n.gamePaused = n.menuOpen || i.$rtcDisplay.enabled.value && i.$rtcDisplay.error.value
					}))
				})), n
			}
		})
	},
	mc = e => "object" == typeof e && !Array.isArray(e) && null !== e;
let gc = {};

function vc() {
	let e;
	return {
		install: function(t) {
			const n = {};
			for (const e in fc) {
				const i = e.split("/").pop().slice(0, -3);
				n[i] = fc[e].default, "function" == typeof n[i] && (n[i] = n[i](t))
			}
			e = mc(n.index) ? n.index : {};
			for (const i in n) "index" !== i && mc(n[i]) && (e[i] = n[i]);
			e = dt(e), t.config.globalProperties.$stores = e, t.provide("stores", e), gc = e
		}
	}
}

function _c() {
	return Gi() ? Yt("stores") : gc
}
const yc = {},
	xc = {
		class: "separator"
	},
	bc = [(e => (Ut("data-v-2c1274ff"), e = e(), Bt(), e))((() => Mi("svg", {
		width: "72",
		height: "7",
		viewBox: "0 0 72 7",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg"
	}, [Mi("path", {
		class: "sepA",
		d: "M3.496 0H22.8l-3.048 6.108H.448L3.496 0Z"
	}), Mi("path", {
		class: "sepB",
		d: "M27.88 0h19.304l-3.048 6.108H24.832L27.88 0Z"
	}), Mi("path", {
		class: "sepC",
		d: "M52.264 0h19.304L68.52 6.108H49.216L52.264 0Z"
	})], -1)))];
var wc = zl(yc, [
	["render", function(e, t) {
		return pi(), vi("div", xc, bc)
	}],
	["__scopeId", "data-v-2c1274ff"]
]);
const Sc = window;

function Mc() {
	Sc.gaDataLayer.push(arguments)
}

function Tc(e) {
	for (const t in e) null == e[t] && delete e[t];
	return e
}
Sc.gtmDataLayer = Sc.gtmDataLayer || [], Sc.gaDataLayer = Sc.gaDataLayer || [];
const Cc = {
		ga4ID: "G-2420S1FXNZ",
		debug: !0
	},
	Ec = Cc.gtmID || null,
	Ac = Cc.ga4ID || null,
	Pc = {
		send_page_view: !1,
		restricted_data_processing: !0,
		anonymize_ip: !0,
		cookie_prefix: "analytics_ga4",
		cookie_update: !1,
		cookie_expires: 15552e3
	};
let Lc = !1;
const Ic = [];
let Dc;

function Rc(e = {}) {
	let t = null;
	const n = Dc = {
		install: function(t) {
			t.config.globalProperties.$stats = n, t.provide("stats", n), e.autoInit && i();
			delete n.install
		},
		init: i,
		pageview: function e({
			title: n,
			url: i
		}) {
			window.ga && !Lc && (Lc = !0);
			if (!Lc) return void Ic.push((() => e({
				title: n,
				url: i
			})));
			if ((i = (i + "").split("?")[0]) === t) return;
			t = i;
			const r = Tc({
				page_location: i += document.location.search,
				page_title: n
			});
			Mc("event", "page_view", Object.assign({
				send_to: Ac
			}, r)), window.ga && ga("send", "pageview", {
				page: i,
				title: n
			})
		},
		event: function e(t = {}) {
			if ("string" != typeof t.name || t.name.length < 1) return;
			if (!Lc) return void Ic.push((() => e(t)));
			const n = Tc({
				event_category: t.category,
				event_label: t.label,
				value: t.value
			});
			Ec && (i = Object.assign({
				event: t.name
			}, n), Sc.gtmDataLayer.push(i));
			var i;
			Ac && Mc("event", t.name, Object.assign({
				send_to: Ac
			}, n))
		}
	};
	return n;

	function i() {
		if (!Lc) {
			Lc = !0; {
				Mc("js", new Date), Mc("config", Ac, Pc), Mc("set", "allow_ad_personalization_signals", !1), Mc("set", "allow_google_signals", !1);
				const e = document.createElement("script");
				e.type = "text/javascript", e.async = !0, e.src = "https://www.googletagmanager.com/gtag/js?l=gaDataLayer&id=" + Ac, document.head.appendChild(e)
			}
			Ic.forEach((e => e())), Ic.length = 0
		}
	}
}

function kc() {
	return Gi() ? Yt("stats") : Dc
}
const Nc = "undefined" == typeof window ? global : window,
	Oc = [],
	Fc = [],
	zc = [];
let Uc, Bc, Vc = null,
	Hc = null,
	Gc = !1,
	Wc = !1;

function qc() {
	const e = performance.now();
	let t;
	if (null === Hc && (Hc = e), Bc = e - Hc, Uc += Bc, Hc = e, Vc = Gc ? null : Nc.requestAnimationFrame(qc), Gc && (Gc = !1), Wc) {
		for (t = 0; t < zc.length; t++) zc[t](Bc);
		for (t = 0; t < Oc.length; t++) Oc[t](Bc);
		for (t = 0; t < Fc.length; t++) Fc[t](Bc)
	} else
		for (t = 0; t < Oc.length; t++) Oc[t](Bc)
}

function jc() {
	Wc = !!(Fc.length > 0 || zc.length > 0)
}

function Yc(e, t, n) {
	return !(!t || !e) && (!~e.indexOf(t) && ((n = !!n) ? e.unshift(t) : e.push(t), !0))
}

function Xc(e, t) {
	if (!t) return !1;
	const n = e.indexOf(t);
	return !!~n && (e.splice(n, 1), !(0 !== e.length))
}

function $c(e) {
	Gc = !1, Vc || (Hc = null, (e = !!e) ? qc() : Vc = Nc.requestAnimationFrame(qc))
}

function Zc() {
	Vc && (Nc.cancelAnimationFrame(Vc), Vc = null)
}
var Kc = {
	add: function(e, t) {
		Yc(Oc, e, t) && $c()
	},
	addAfter: function(e, t) {
		Yc(Fc, e, t) && jc()
	},
	addBefore: function(e, t) {
		Yc(zc, e, t) && jc()
	},
	remove: function(e) {
		Xc(Oc, e) && Zc()
	},
	removeAfter: function(e) {
		Xc(Fc, e) && jc()
	},
	removeBefore: function(e) {
		Xc(zc, e) && jc()
	},
	start: $c,
	stop: Zc,
	time: Uc,
	dt: Bc,
	requestOnce: function() {
		Vc || (Gc = !0, Hc = null, Vc = Nc.requestAnimationFrame(qc))
	},
	dispose: function() {
		Zc(), Oc.length = 0, Fc.length = 0, zc.length = 0, Wc = !1, Hc = null, Uc = 0, Bc = 0
	}
};
class Jc {
	constructor(e, t, n = {}) {
		const i = void 0 === n.autostart || n.autostart;
		this._standalone = void 0 === n.standalone || n.standalone, this._selfdestruct = void 0 === n.selfdestruct || n.selfdestruct, this._stopped = !0, this._remainder = 0, this._delay = 0 | e, this._remainingTime = e, this._callback = void 0 === t ? function() {} : t;
		const r = this,
			s = this.update,
			a = this.restart;
		this.update = function(e) {
			s.call(r, e)
		}, this.restart = function(e, t) {
			a.call(r, e, t)
		}, i && this.start(), 0 === this._delay && this.stop()
	}
	setCallback(e, t) {
		this._callback = void 0 === e ? function() {} : e, t && this.restart(t)
	}
	stop() {
		this._stopped = !0, this._standalone && Kc.remove(this.update)
	}
	start() {
		this._stopped && this.restart()
	}
	restart(e, t) {
		void 0 === t && (t = !0), void 0 !== e && (this._delay = e), this._standalone && this._stopped && Kc.add(this.update), this._stopped = !1, this._remainingTime = this._delay - this._remainder * +t
	}
	update(e) {
		this._stopped || (this._remainingTime -= e, this._remainingTime <= 0 ? (this._stopped = !0, this._remainder = -this._remainingTime % this._delay, this._callback(this.restart), this._selfdestruct && this.dispose()) : this._remainder = 0)
	}
	dispose() {
		this._standalone && Kc.add(this.update), this._callback = this.restart = null, this.stop(), this._remainder = 0, this._remainingTime = this._delay
	}
}

function Qc(e, t, n) {
	return new Jc(e, t, n)
}
const eu = {
	autostart: !0,
	standalone: !0,
	selfdestruct: !0
};

function tu() {
	const e = [],
		t = [];
	return Gi() && vn(r), {
		setTimeout: n,
		setInterval: function(e, n) {
			const i = window.setInterval(e, n);
			return t.push(i), i
		},
		wait: function(e, t) {
			return new Promise((n => i(e, n, t)))
		},
		timer: i,
		clearTimers: r
	};

	function n(t, n) {
		const i = window.setTimeout(t, n);
		return e.push(i), i
	}

	function i(t, i, r) {
		if (r) {
			const n = Qc(t, i, eu);
			return e.push(n), n
		} {
			const r = n(i, t);
			return e.push(r), r
		}
	}

	function r() {
		for (let t = 0, n = e.length; t < n; t++) {
			const n = e[t];
			n.dispose ? n.dispose() : clearTimeout(n)
		}
		for (let e = 0, n = t.length; e < n; e++) clearInterval(t[e]);
		t.length = 0, e.length = 0
	}
}
const nu = {
		class: "result__container"
	},
	iu = {
		class: "result__frame"
	},
	ru = (e => (Ut("data-v-9ad5651c"), e = e(), Bt(), e))((() => Mi("defs", null, [Mi("linearGradient", {
		id: "a",
		x1: "-1",
		y1: "70.668",
		x2: "276",
		y2: "70.668",
		gradientUnits: "userSpaceOnUse"
	}, [Mi("stop", {
		"stop-color": "#fff"
	}), Mi("stop", {
		offset: "1",
		"stop-color": "#fff",
		"stop-opacity": "0"
	})])], -1))),
	su = ["innerHTML"],
	au = {
		class: "result__content"
	},
	ou = {
		class: "time__value"
	},
	lu = {
		class: "time__unit"
	},
	cu = {
		class: "result__pb"
	},
	uu = {
		class: "pb__text"
	},
	hu = {
		class: "pb__value"
	},
	du = {
		class: "pb__unit"
	},
	pu = {
		key: 0,
		class: "result__buttons"
	},
	fu = {
		key: 1,
		class: "result__webrtc"
	},
	mu = {
		class: "result__webrtc__texts"
	},
	gu = {
		key: 0,
		class: "result__webrtc__title"
	},
	vu = {
		key: 1,
		class: "result__webrtc__description"
	},
	_u = {
		class: "result__webrtc__waiting"
	};
var yu = zl({
		setup(e, {
			expose: t
		}) {
			tu();
			const n = kc(),
				i = Wa(),
				{
					csstween: r
				} = Sl(),
				s = Tt(""),
				a = Tt(""),
				o = Tt(),
				l = Tt(),
				c = Tt(),
				u = _c(),
				h = Ll.$rtcDisplay.enabled.value,
				d = Xo.timeline({});
			let p;
			const f = {
				setUp: function() {
					p = setTimeout((function() {
						i.push({
							name: "qrcode-home"
						}), f.clear()
					}), 1e4)
				},
				clear: function() {
					clearTimeout(p)
				}
			};
			return pn((() => {
				n.pageview({
					title: "result",
					url: "/result"
				}), Ol.audio.setBgm("outro"), u.isPlaying = !1, u.menuOpen = !1, u.score = Ol.game.racetime, u.bestTime = Ol.game.bestTime, s.value = (Math.max(0, Ol.game.racetime || 0) / 1e3).toFixed(2), a.value = (Math.max(0, Ol.game.bestTime || 0) / 1e3).toFixed(2), h && f.setUp()
			})), vn((() => {
				h && f.clear()
			})), t({
				enter: function(e) {
					Ol.audio.playSound("UI_ResulTime", {
						delay: 650
					}), d.add({
						targets: ".result__frame",
						skewX: [-4, -4],
						rotate: [-11, 0],
						scale: [1.4, 1],
						duration: 1500,
						easing: "cubicBezier(.87,0,.13,1)"
					}, "+=500").add({
						targets: ".path",
						strokeDashoffset: [Xo.setDashoffset, 0],
						duration: 1500,
						easing: "cubicBezier(.87,0,.13,1)"
					}, "-=1500").add({
						targets: ".result__icon",
						translateX: ["6px", "6px"],
						scale: [0, 1],
						duration: 1e3,
						easing: "cubicBezier(.64,.01,.11,1.28)"
					}, "-=1000").add({
						targets: ".result__content p",
						opacity: [0, 1],
						translateY: ["40px", "0px"],
						duration: 1e3,
						delay: Xo.stagger(200),
						easing: "cubicBezier(0,0,.13,1)"
					}, "-=700").add({
						targets: ".light",
						opacity: [0, 1],
						duration: 1500,
						easing: "cubicBezier(.87,0,.13,1)"
					}, "-=1300").add({
						targets: ".result__register, .result__again",
						opacity: [0, 1],
						translateX: ["-40px", "0px"],
						duration: 1e3,
						delay: Xo.stagger(150),
						easing: "cubicBezier(0,0,.13,1)"
					}, "-=1200").add({
						targets: ".separator",
						opacity: [0, 1],
						duration: 1e3,
						easing: "cubicBezier(0,0,.13,1)"
					}, "-=1000").add({
						targets: ".result__webrtc__texts div",
						opacity: [0, 1],
						translateY: ["40px", "0px"],
						delay: Xo.stagger(150),
						duration: 1e3,
						easing: "cubicBezier(0,0,.13,1)"
					}, "-=1200")
				},
				leave: async function(e) {
					return r({
						target: e,
						transform: ["", "scale3d(0.6,0.6,0.6)"],
						duration: 800,
						ease: "cubic-bezier(.87,0,.13,1)",
						opacity: ["", 0],
						autoClear: !1
					}).finished
				}
			}), (e, t) => (pi(), vi("section", {
				class: g(["page page-result result", {
					hidden: At(u).menuOpen
				}])
			}, [Mi("div", nu, [Mi("div", {
				class: g(["result__timer", {
					marginB: At(u).webRtc
				}])
			}, [Mi("div", iu, [(pi(), vi("svg", {
				ref: (e, t) => {
					t.square = e, o.value = e
				},
				viewBox: "0 0 293 141",
				fill: "none",
				xmlns: "http://www.w3.org/2000/svg",
				class: "result__square"
			}, [Mi("path", {
				ref: (e, t) => {
					t.path = e, l.value = e
				},
				d: "M16.599 7.711a7.5 7.5 0 0 1 7.438-6.543h260.869c4.521 0 8.015 3.971 7.438 8.456l-15.943 124a7.5 7.5 0 0 1-7.438 6.544H8.094c-4.521 0-8.015-3.972-7.438-8.457l15.943-124Z",
				stroke: "#fff",
				"stroke-opacity": ".2",
				class: "path"
			}, null, 512), Mi("path", {
				ref: (e, t) => {
					t.light = e, c.value = e
				},
				d: "M16.599 7.711a7.5 7.5 0 0 1 7.438-6.543h260.869c4.521 0 8.015 3.971 7.438 8.456l-15.943 124a7.5 7.5 0 0 1-7.438 6.544H8.094c-4.521 0-8.015-3.972-7.438-8.457l15.943-124Z",
				stroke: "url(#a)",
				class: "light"
			}, null, 512), ru], 512))]), Mi("div", {
				class: "result__icon",
				innerHTML: At('<svg viewBox="0 0 39 39" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="19.942" width="26.952" height="26.952" rx="5.256" transform="rotate(45 19.942 0)" fill="#fff"/><rect x="19.942" y=".902" width="25.676" height="25.676" rx="4.618" transform="rotate(45 19.942 .902)" stroke="url(#a)" stroke-opacity=".25" stroke-width="1.275"/><path d="M18.473 11.479a.554.554 0 1 0 0 1.107h.908v1.188a6.288 6.288 0 0 0-3.026 1.089l-.591-.585a.727.727 0 0 0-.996-.025c-.159.141-.311.289-.457.443a.728.728 0 0 0 .016 1.019l.564.557a6.287 6.287 0 1 0 10.072 0l.564-.557a.727.727 0 0 0 .017-1.02 7.74 7.74 0 0 0-.458-.442.727.727 0 0 0-.995.025l-.592.585a6.289 6.289 0 0 0-3.027-1.089v-1.188h.908a.554.554 0 1 0 0-1.107h-2.907Zm1.33 3.336a5.199 5.199 0 0 1 5.32 5.223 5.198 5.198 0 1 1-10.394 0 5.197 5.197 0 0 1 5.073-5.223Z" fill="#DD2526"/><path d="m18.032 17.86-.774-.775a.2.2 0 0 0-.284.284l.775.775a.2.2 0 0 0 .284-.284ZM18.033 22.217l-.775.775a.2.2 0 0 1-.284-.284l.775-.775a.2.2 0 0 1 .284.284ZM17.046 20.24a.201.201 0 0 0 0-.402h-1.095a.201.201 0 0 0 0 .401h1.095ZM19.726 24.015a.201.201 0 0 0 .401 0V22.92a.201.201 0 0 0-.401 0v1.096ZM21.88 23.73a4.178 4.178 0 0 0-1.953-7.87v4.178l1.953 3.692Z" fill="#DD2526"/><defs><linearGradient id="a" x1="21.347" y1="25.651" x2="45.697" y2="1.301" gradientUnits="userSpaceOnUse"><stop stop-color="#BFBFBF"/><stop offset="1" stop-color="#fff" stop-opacity="0"/></linearGradient></defs></svg>\n')
			}, null, 8, su), Mi("div", au, [Mi("p", {
				ref: (e, t) => {
					t.finish = e
				},
				class: "result__time"
			}, [Mi("span", ou, y(s.value), 1), Mi("span", lu, y(e.$l("game_end.time")), 1)], 512), Mi("p", cu, [Mi("span", uu, y(e.$l("game_end.pb")) + "", 1), Mi("span", hu, y(a.value), 1), Mi("span", du, y(e.$l("game_end.time")), 1)])])], 2), e.$rtcDisplay.enabled.value ? Pi("", !0) : (pi(), vi("div", pu, [Ti(jl, {
				"no-big-line": !0,
				to: {
					name: "game"
				},
				text: e.$l("game_end.cta.playagain"),
				icon: "play",
				"small-text": !0,
				class: "result__again",
				onClick: t[0] || (t[0] = e => {
					At(n).event({
						name: "click_again_finish"
					})
				})
			}, null, 8, ["text"]), e.$stores.noForm ? Pi("", !0) : (pi(), _i(jl, {
				key: 0,
				text: e.$l("game_end.cta.register"),
				to: {
					name: "register"
				},
				icon: "next",
				class: "result__register",
				onClick: t[1] || (t[1] = e => {
					At(n).event({
						name: "click_register"
					})
				})
			}, null, 8, ["text"]))])), e.$rtcDisplay.enabled.value ? (pi(), vi("div", fu, [e.$stores.noForm ? Pi("", !0) : (pi(), _i(wc, {
				key: 0
			})), Mi("div", mu, [e.$stores.noForm ? Pi("", !0) : (pi(), vi("div", gu, [Mi("p", null, y(e.$l("webRTC.recap.borne.title")), 1)])), e.$stores.noForm ? Pi("", !0) : (pi(), vi("div", vu, [Mi("p", null, y(e.$l("webRTC.recap.borne.text")), 1)])), Mi("div", _u, [Mi("p", null, y(e.$l("webRTC.recap.borne.wait")), 1)])])])) : Pi("", !0)])], 2))
		}
	}, [
		["__scopeId", "data-v-9ad5651c"]
	]),
	xu = JSON.parse('{"af":"Afghanistan","al":"Albania","dz":"Algeria","as":"American Samoa","ad":"Andorra","ao":"Angola","ai":"Anguilla","aq":"Antarctica","ag":"Antigua and Barbuda","ar":"Argentina","am":"Armenia","aw":"Aruba","au":"Australia","at":"Austria","az":"Azerbaijan","bs":"Bahamas","bh":"Bahrain","bd":"Bangladesh","bb":"Barbados","by":"Belarus","be":"Belgium","bz":"Belize","bj":"Benin","bm":"Bermuda","bt":"Bhutan","bo":"Bolivia","ba":"Bosnia and Herzegovina","bw":"Botswana","br":"Brazil","io":"British Indian Ocean Territory","vg":"British Virgin Islands","bn":"Brunei","bg":"Bulgaria","bf":"Burkina Faso","bi":"Burundi","kh":"Cambodia","cm":"Cameroon","ca":"Canada","cv":"Cape Verde","ky":"Cayman Islands","cf":"Central African Republic","td":"Chad","cl":"Chile","cn":"China","cx":"Christmas Island","cc":"Cocos Islands","co":"Colombia","km":"Comoros","ck":"Cook Islands","cr":"Costa Rica","hr":"Croatia","cu":"Cuba","cw":"Curacao","cy":"Cyprus","cz":"Czech Republic","cd":"Democratic Republic of the Congo","dk":"Denmark","dj":"Djibouti","dm":"Dominica","do":"Dominican Republic","tp":"East Timor","ec":"Ecuador","eg":"Egypt","sv":"El Salvador","gq":"Equatorial Guinea","er":"Eritrea","ee":"Estonia","et":"Ethiopia","fk":"Falkland Islands","fo":"Faroe Islands","fj":"Fiji","fi":"Finland","fr":"France","pf":"French Polynesia","ga":"Gabon","gm":"Gambia","ge":"Georgia","de":"Germany","gh":"Ghana","gi":"Gibraltar","gr":"Greece","gl":"Greenland","gd":"Grenada","gu":"Guam","gt":"Guatemala","gg":"Guernsey","gn":"Guinea","gw":"Guinea-Bissau","gy":"Guyana","ht":"Haiti","hn":"Honduras","hk":"Hong Kong","hu":"Hungary","is":"Iceland","in":"India","id":"Indonesia","ir":"Iran","iq":"Iraq","ie":"Ireland","im":"Isle of Man","il":"Israel","it":"Italy","ci":"Ivory Coast","jm":"Jamaica","jp":"Japan","je":"Jersey","jo":"Jordan","kz":"Kazakhstan","ke":"Kenya","ki":"Kiribati","xk":"Kosovo","kw":"Kuwait","kg":"Kyrgyzstan","la":"Laos","lv":"Latvia","lb":"Lebanon","ls":"Lesotho","lr":"Liberia","ly":"Libya","li":"Liechtenstein","lt":"Lithuania","lu":"Luxembourg","mo":"Macao","mk":"Macedonia","mg":"Madagascar","mw":"Malawi","my":"Malaysia","mv":"Maldives","ml":"Mali","mt":"Malta","mh":"Marshall Islands","mr":"Mauritania","mu":"Mauritius","yt":"Mayotte","mx":"Mexico","fm":"Micronesia","md":"Moldova","mc":"Monaco","mn":"Mongolia","me":"Montenegro","ms":"Montserrat","ma":"Morocco","mz":"Mozambique","mm":"Myanmar","na":"Namibia","nr":"Nauru","np":"Nepal","nl":"Netherlands","an":"Netherlands Antilles","nc":"New Caledonia","nz":"New Zealand","ni":"Nicaragua","ne":"Niger","ng":"Nigeria","nu":"Niue","kp":"North Korea","mp":"Northern Mariana Islands","no":"Norway","om":"Oman","pk":"Pakistan","pw":"Palau","ps":"Palestine","pa":"Panama","pg":"Papua New Guinea","py":"Paraguay","pe":"Peru","ph":"Philippines","pn":"Pitcairn","pl":"Poland","pt":"Portugal","pr":"Puerto Rico","qa":"Qatar","cg":"Republic of the Congo","re":"Reunion","ro":"Romania","ru":"Russia","rw":"Rwanda","bl":"Saint Barthelemy","sh":"Saint Helena","kn":"Saint Kitts and Nevis","lc":"Saint Lucia","mf":"Saint Martin","pm":"Saint Pierre and Miquelon","vc":"Saint Vincent and the Grenadines","ws":"Samoa","sm":"San Marino","st":"Sao Tome and Principe","sa":"Saudi Arabia","sn":"Senegal","rs":"Serbia","sc":"Seychelles","sl":"Sierra Leone","sg":"Singapore","sx":"Sint Maarten","sk":"Slovakia","si":"Slovenia","sb":"Solomon Islands","so":"Somalia","za":"South Africa","kr":"Korea","ss":"South Sudan","es":"Spain","lk":"Sri Lanka","sd":"Sudan","sr":"Suriname","sj":"Svalbard and Jan Mayen","sz":"Swaziland","se":"Sweden","ch":"Switzerland","sy":"Syria","tw":"Taiwan","tj":"Tajikistan","tz":"Tanzania","th":"Thailand","tg":"Togo","tk":"Tokelau","to":"Tonga","tt":"Trinidad and Tobago","tn":"Tunisia","tr":"Turkey","tm":"Turkmenistan","tc":"Turks and Caicos Islands","tv":"Tuvalu","vi":"U.S. Virgin Islands","ug":"Uganda","ua":"Ukraine","ae":"United Arab Emirates","gb":"United Kingdom","us":"United States","uy":"Uruguay","uz":"Uzbekistan","vu":"Vanuatu","va":"Vatican","ve":"Venezuela","vn":"Vietnam","wf":"Wallis and Futuna","eh":"Western Sahara","ye":"Yemen","zm":"Zambia","zw":"Zimbabwe","gp":"Guadeloupe","gf":"French Guiana","mq":"Martinique","tf":"French Southern and Antarctic Lands","gs":"South Georgia and the South Sandwich Islands"}');

function bu() {
	let e, t;
	const n = new Promise(((n, i) => {
		e = n, t = i
	}));
	return n.resolve = e, n.reject = t, n
}

function wu(e, t = 1, n = {}, i) {
	const r = n.bind || null,
		s = null == n.trail || !!n.trail,
		a = null == n.tail || !!n.tail;
	let o, l, c, u = null,
		h = s,
		d = !1;

	function p() {
		u = null, s && !d && (h = !0), e.call(r, o, l, c), i && d && a && (d = !1, u = setTimeout(p, t))
	}
	return function(n, a, f) {
		i || (clearTimeout(u), u = null), o = n, l = a, c = f, s && h && (h = !1, e.call(r, o, l, c)), null === u ? u = setTimeout(p, t) : i && (d = !0)
	}
}
let Su = !1;
const Mu = bu();
let Tu;
window._onRecaptchaLoaded = () => Mu.resolve();
var Cu = {
	token: async function(e, t) {
		let n = null,
			i = !1;
		Tu && document.body.appendChild(Tu);
		try {
			! function(e) {
				if (Su) return;
				Su = !0;
				const t = document,
					n = t.createElement("script");
				n.src = "https://www.recaptcha.net/recaptcha/api.js?onload=_onRecaptchaLoaded&render=" + e, n.async = !0, t.head.appendChild(n)
			}(e), await Mu, await new Promise((e => grecaptcha.ready(e))), grecaptcha.reset(e), n = await grecaptcha.execute(e, t ? {
				action: t
			} : {})
		} catch (r) {
			i = "RecaptchaError"
		}
		return function() {
			const e = document.querySelectorAll(".grecaptcha-badge");
			for (let t = 0; t < e.length; t++) {
				const n = e[t].parentNode;
				n && n.parentNode && (Tu = n, n.parentNode.removeChild(n))
			}
		}(), {
			token: n,
			error: i
		}
	}
};
const Eu = e => (Ut("data-v-3e708368"), e = e(), Bt(), e),
	Au = {
		class: "form__wrapper"
	},
	Pu = {
		class: "form__best"
	},
	Lu = {
		class: "pb__text"
	},
	Iu = {
		class: "form__score"
	},
	Du = {
		class: "score__value"
	},
	Ru = {
		class: "score__unit"
	},
	ku = {
		class: "form__title"
	},
	Nu = {
		class: "form__container"
	},
	Ou = ["onSubmit"],
	Fu = {
		class: "form__names"
	},
	zu = {
		class: "form__input"
	},
	Uu = ["placeholder"],
	Bu = {
		class: "form__input"
	},
	Vu = ["placeholder"],
	Hu = {
		class: "form__input"
	},
	Gu = ["placeholder"],
	Wu = {
		disabled: "",
		selected: "",
		hidden: "",
		value: ""
	},
	qu = ["value"],
	ju = ["innerHTML"],
	Yu = Eu((() => Mi("span", {
		class: "checkmark"
	}, null, -1))),
	Xu = ["innerHTML"],
	$u = Eu((() => Mi("span", {
		class: "checkmark"
	}, null, -1))),
	Zu = {
		class: "form__input submitButton"
	},
	Ku = {
		class: "form__input recaptcha"
	};
var Ju = zl({
	setup(e, {
		expose: t
	}) {
		let n;
		const i = Tt(null),
			r = Tt(),
			s = Tt(null),
			a = Tt(),
			o = Tt(null),
			l = Tt(),
			c = Tt(null),
			u = Tt(),
			h = Tt(!1),
			d = Tt(null),
			p = Tt(!1),
			f = Tt(null),
			m = Tt(!1),
			v = Tt(),
			_ = Tt(!1),
			x = Tt("0.00"),
			b = Tt("0.00"),
			w = _c(),
			S = Wa(),
			M = kc(),
			T = Xo.timeline({});
		pn((() => {
			x.value = (Math.max(0, w.score || 0) / 1e3).toFixed(2), b.value = (Math.max(0, w.bestTime || 0) / 1e3).toFixed(2), u.value.children[0].style.textDecoration = "underline", Ol.audio.setBgm("outro"), M.pageview({
				title: "register",
				url: "/register"
			})
		}));
		const C = (e, t) => {
			t ? e.value.classList.add("fullField") : e.value.classList.remove("fullField")
		};

		function E(e) {
			"" !== e.target.value ? v.value.classList.add("fullField") : v.value.classList.remove("fullField")
		}
		Sr(r, (e => {
			C(i, e)
		})), Sr(a, (e => {
			C(s, e)
		})), Sr(l, (e => {
			C(o, e)
		}));
		const A = async () => {
			try {
				if (_.value) return;
				_.value = !0, n = {
					firstname: r.value,
					lastname: a.value,
					email: l.value,
					country: v.value.value,
					legals: h.value,
					newsletter: p.value,
					score: x.value || "0.00",
					recaptcha: ""
				}, M.event({
					name: "validate_form"
				});
				const e = await Cu.token("6Lc1w4IdAAAAANNLPM1DbJPacVMSv0lQTj1uZ3YN", "submit");
				n.recaptcha = e.token;
				const t = await (async e => {
					const t = await fetch("https://europe-west1-montblanc-race.cloudfunctions.net/register", {
						method: "POST",
						headers: {
							Accept: "application/json",
							"Content-Type": "application/json",
							Authorization: "Bearer VgDa2q5ZPfcyA+Fal9CtlGXqOb+T"
						},
						body: JSON.stringify(e)
					});
					return await t.json()
				})(n);
				if ("saved" !== t.status) throw new Error("object" == typeof t ? JSON.stringify(t, void 0, 2) : t);
				S.push({
					name: "confirmation"
				})
			} catch (e) {} finally {
				_.value = !1
			}
		}, {
			csstween: P
		} = Sl(), L = "cubicBezier(0,0,.13,1) ";
		return t({
			enter: function(e) {
				T.add({
					targets: ".form__best",
					translateY: ["-40px", 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: L
				}, 100).add({
					targets: ".form__score",
					translateY: ["-40px", 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: L
				}, 300).add({
					targets: ".form__title",
					translateY: ["-40px", 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: L
				}, 400).add({
					targets: ".separator",
					translateY: ["-20px", 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: L
				}, 500).add({
					targets: ".form__input",
					translateY: ["-20px", 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: L,
					delay: Xo.stagger(80)
				}, 600)
			},
			leave: async function(e) {
				return P({
					target: e,
					transform: ["", "scale3d(0.6,0.6,0.6)"],
					duration: 800,
					ease: "cubic-bezier(.87,0,.13,1)",
					opacity: ["", 0],
					autoClear: !1
				}).finished
			}
		}), (e, t) => (pi(), vi("section", {
			class: g(["page page-form form", {
				hidden: At(w).menuOpen
			}])
		}, [Mi("div", Au, [Mi("h3", Pu, [Mi("span", Lu, y(e.$l("game_end.myscore")), 1)]), Mi("h1", Iu, [Mi("span", Du, y(x.value), 1), Mi("span", Ru, y(e.$l("game_end.time")), 1)]), Mi("h1", ku, y(e.$l("form.title")), 1), Ti(wc), Mi("div", Nu, [Mi("form", {
			action: "",
			class: "form__content",
			method: "post",
			autocomplete: "off",
			onSubmit: ms(A, ["prevent"])
		}, [Mi("div", Fu, [Mi("div", zu, [jn(Mi("input", {
			ref: (e, t) => {
				t.firstName = e, i.value = e
			},
			"onUpdate:modelValue": t[0] || (t[0] = e => r.value = e),
			required: "true",
			type: "text",
			name: "firstName",
			placeholder: e.$l("form.firstname"),
			class: "form__field",
			maxlength: "40",
			autocorrect: "off",
			autocapitalize: "off",
			autocomplete: "none"
		}, null, 8, Uu), [
			[cs, r.value, void 0, {
				trim: !0
			}]
		])]), Mi("div", Bu, [jn(Mi("input", {
			ref: (e, t) => {
				t.lastName = e, s.value = e
			},
			"onUpdate:modelValue": t[1] || (t[1] = e => a.value = e),
			required: "true",
			type: "text",
			name: "lastName",
			placeholder: e.$l("form.lastname"),
			class: "form__field",
			maxlength: "40",
			autocorrect: "off",
			autocapitalize: "off",
			autocomplete: "none"
		}, null, 8, Vu), [
			[cs, a.value, void 0, {
				trim: !0
			}]
		])])]), Mi("div", Hu, [jn(Mi("input", {
			ref: (e, t) => {
				t.email = e, o.value = e
			},
			"onUpdate:modelValue": t[2] || (t[2] = e => l.value = e),
			required: "true",
			type: "email",
			name: "email",
			placeholder: e.$l("form.email"),
			class: "form__field",
			autocorrect: "off",
			autocapitalize: "off",
			autocomplete: "none"
		}, null, 8, Gu), [
			[cs, l.value, void 0, {
				trim: !0
			}]
		])]), Mi("div", {
			ref: (e, t) => {
				t.select = e, f.value = e
			},
			class: "form__input"
		}, [Mi("select", Ri({
			ref: (e, t) => {
				t.selectField = e, v.value = e
			}
		}, m.value, {
			required: "true",
			name: "countrySelector",
			class: "form__select",
			onChange: E
		}), [Mi("option", Wu, y(e.$l("form.country")), 1), (pi(!0), vi(oi, null, ki(Object.entries(At(xu)), (e => (pi(), vi("option", {
			key: e[0],
			value: e[0]
		}, y(e[1]), 9, qu)))), 128))], 16)], 512), Mi("div", {
			ref: (e, t) => {
				t.newsletter = e, d.value = e
			},
			class: "form__input checkInput"
		}, [Mi("label", {
			for: "subscribe-newsletter",
			innerHTML: e.$l("form.newsletter")
		}, null, 8, ju), jn(Mi("input", {
			id: "subscribe-newsletter",
			"onUpdate:modelValue": t[3] || (t[3] = e => p.value = e),
			name: "promotionnal",
			type: "checkbox",
			class: "checkboxes"
		}, null, 512), [
			[us, p.value]
		]), Yu], 512), Mi("div", {
			ref: (e, t) => {
				t.legals = e, c.value = e
			},
			class: "form__input checkInput"
		}, [Mi("label", {
			ref: (e, t) => {
				t.legalsLabel = e, u.value = e
			},
			for: "accept-conditions",
			innerHTML: e.$l("form.legals")
		}, null, 8, Xu), jn(Mi("input", {
			id: "accept-conditions",
			"onUpdate:modelValue": t[4] || (t[4] = e => h.value = e),
			name: "legals",
			type: "checkbox",
			class: "checkboxes",
			required: ""
		}, null, 512), [
			[us, h.value]
		]), $u], 512), Mi("div", Zu, [Ti(jl, {
			text: e.$l("form.cta"),
			icon: "next",
			type: "submit",
			class: g({
				loading: _.value
			})
		}, null, 8, ["text", "class"])]), Mi("div", Ku, y(e.$l("form.recaptcha")), 1)], 40, Ou)])])], 2))
	}
}, [
	["__scopeId", "data-v-3e708368"]
]);
const Qu = {
		class: "confirmation__title"
	},
	eh = {
		class: "confirmation__text"
	},
	th = {
		class: "confirmation__again"
	},
	nh = {
		class: "confirmation__frame"
	},
	ih = {
		async beforeRouteEnter() {}
	};
var rh = zl(Object.assign(ih, {
	setup: function(e, {
		expose: t
	}) {
		const n = _c(),
			i = kc(),
			{
				csstween: r
			} = Sl(),
			s = "cubic-bezier(.87,0,.13,1)",
			a = "cubic-bezier(0,0,.13,1) ";
		return pn((() => {
			Ol.audio.setBgm("outro"), i.pageview({
				title: "confirmation",
				url: "/confirmation"
			})
		})), t({
			enter: function(e) {
				r({
					target: e,
					selector: ".confirmation__title",
					transform: ["translateY(-40px)", ""],
					duration: 1e3,
					ease: a,
					delay: 400,
					opacity: [0, ""]
				}), r({
					target: e,
					selector: ".separator",
					transform: ["translateY(-40px)", ""],
					duration: 800,
					ease: a,
					delay: 550,
					opacity: [0, ""]
				}), r({
					target: e,
					selector: ".confirmation__text",
					transform: ["translateY(-40px)", ""],
					duration: 1e3,
					ease: a,
					delay: 850,
					opacity: [0, ""]
				}), r({
					target: e,
					selector: ".confirmation__again",
					transform: ["scale3d(0.5,0.5,0.5)", ""],
					duration: 1e3,
					ease: s,
					delay: 950,
					opacity: [0, ""]
				})
			},
			leave: async function(e) {
				return r({
					target: e,
					transform: ["", "scale3d(0.6,0.6,0.6)"],
					duration: 800,
					ease: s,
					opacity: ["", 0],
					autoClear: !1
				}).finished
			}
		}), (e, t) => (pi(), vi("section", {
			class: g(["page page-confirmation confirmation", {
				hidden: At(n).menuOpen
			}])
		}, [Mi("h1", Qu, y(e.$l("form.success.title")), 1), Ti(wc), Mi("p", eh, y(e.$l("form.success.text")), 1), Mi("div", th, [Mi("div", nh, [Ti(jl, {
			to: {
				name: "game"
			},
			text: e.$l("game_end.cta.playagain"),
			icon: "next",
			class: "result__again",
			onClick: t[0] || (t[0] = e => {
				At(i).event({
					name: "click_again_register"
				})
			})
		}, null, 8, ["text"])])])], 2))
	}
}), [
	["__scopeId", "data-v-64a13b25"]
]);
const sh = {},
	ah = {
		viewBox: "0 0 246 179",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		class: "iconThree"
	},
	oh = [Mi("path", {
		d: "M208.225 74.6857L208.165 75.6616C215.937 77.833 224.015 81.5385 230.145 87.5543C236.261 93.5577 240.46 101.883 240.46 113.36C240.46 126.255 236.987 142.298 220.3 155.14C203.581 168.007 173.527 177.72 120.21 177.72H108.94C58.0463 177.72 30.5418 167.09 16.1012 153.703C1.68454 140.339 0.198451 124.139 1.56579 112.735L1.73366 111.56H77.8523C77.8794 113.764 78.2271 118.661 82.6816 123.142C87.5027 127.993 97.0341 132.26 115.84 132.26C134.599 132.26 145.161 130.25 151.048 127.379C154.003 125.939 155.804 124.27 156.86 122.508C157.917 120.746 158.2 118.938 158.2 117.27C158.2 113.944 157.241 111.284 154.556 109.494C151.926 107.74 147.716 106.88 141.37 106.88H89.7455L96.257 65.79H147.81C154.858 65.79 159.349 64.6961 162.09 62.8591C164.875 60.9923 165.79 58.4018 165.79 55.63C165.79 54.1846 165.518 52.7311 164.532 51.3882C163.552 50.053 161.909 48.8847 159.282 47.9159C154.045 45.9849 144.708 44.78 128.26 44.78C109.583 44.78 99.3505 48.0639 93.6864 51.7911C88.4113 55.2623 87.1411 59.0899 86.6952 60.88H11.0867C12.9562 49.3936 16.905 34.6614 32.1412 22.7021C47.6545 10.5253 74.9502 1.16 123.89 1.16H134.24C181.491 1.16 209.283 6.16444 225.247 13.8468C233.218 17.6826 238.217 22.1751 241.229 27.0252C244.24 31.8746 245.29 37.124 245.29 42.52C245.29 53.3699 240.161 60.7595 232.969 65.771C225.756 70.7976 216.469 73.4262 208.225 74.6857Z",
		fill: "#fff",
		stroke: "#fff",
		class: "path"
	}, null, -1)];
var lh = zl(sh, [
	["render", function(e, t) {
		return pi(), vi("svg", ah, oh)
	}]
]);
const ch = {},
	uh = {
		viewBox: "0 0 245 175",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		class: "iconTwo"
	},
	hh = [Mi("path", {
		d: "M1.06914 174.5L4.42332 154.151L4.42345 154.151L4.42504 154.14C6.26133 141.171 9.29122 125.258 23.3273 110.281C37.3729 95.293 62.5002 81.1804 108.674 71.9911C108.675 71.9908 108.676 71.9906 108.678 71.9904L141.324 66.0129C141.325 66.0127 141.326 66.0126 141.327 66.0124C152.134 64.1728 158.026 62.3794 161.22 60.4571C162.832 59.4871 163.788 58.4664 164.329 57.3633C164.868 56.2655 164.97 55.1393 164.97 54.02C164.97 52.6347 164.713 51.2623 163.868 50.0007C163.025 48.7418 161.632 47.6466 159.458 46.7444C155.133 44.9497 147.57 43.86 134.57 43.86C117.485 43.86 108.088 47.6686 102.873 52.2649C97.9092 56.6399 96.8094 61.6631 96.4112 64.56H20.6047C22.4722 51.3774 26.4586 35.7032 41.3102 23.238C56.3897 10.5815 82.7585 1.16 129.74 1.16H140.09C181.922 1.16 207.803 7.02436 223.212 16.0699C230.907 20.5874 235.984 25.8944 239.141 31.6591C242.298 37.4252 243.55 43.6782 243.55 50.11C243.55 58.2827 242.292 65.3035 239.345 71.3862C236.4 77.464 231.752 82.6381 224.917 87.0949C211.22 96.0265 188.781 102.055 153.825 106.654L118.865 111.254L118.857 111.255C100.101 114.017 88.4903 117.014 81.5567 120.032C74.6555 123.035 72.2 126.146 72.2 129.23V129.73H72.7H166.54H166.964L167.033 129.311L169.954 111.56H236.335L226.373 174.5H1.06914Z",
		fill: "#fff",
		stroke: "#fff",
		class: "path"
	}, null, -1)];
var dh = zl(ch, [
	["render", function(e, t) {
		return pi(), vi("svg", uh, hh)
	}]
]);
const ph = {},
	fh = {
		viewBox: "0 0 130 172",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		class: "iconOne"
	},
	mh = [Mi("path", {
		d: "M42.7838 76.1682L42.8754 75.59H42.29H1.01513L7.07167 37.2319C22.5809 36.1581 34.7876 32.5296 44.4807 26.4894C54.1769 20.4472 61.3249 12.0123 66.7469 1.38H129.104L102.123 171.5H27.6954L42.7838 76.1682Z",
		fill: "#fff",
		stroke: "#fff",
		class: "path"
	}, null, -1)];
var gh = zl(ph, [
	["render", function(e, t) {
		return pi(), vi("svg", fh, mh)
	}]
]);
const vh = {},
	_h = {
		viewBox: "0 0 534 179",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		class: "iconGo"
	},
	yh = [Mi("path", {
		d: "M270.857 83.2983L270.858 83.2961C273.149 66.1124 279.383 45.6079 298.458 29.3884C317.54 13.1632 349.549 1.16 403.532 1.16H414.342C464.884 1.16 494.645 11.8447 511.766 26.5691C528.872 41.2799 533.442 60.0939 533.442 76.56C533.442 82.7361 532.755 89.3783 531.838 95.11C529.086 112.082 523.135 132.703 504.346 149.093C485.553 165.487 453.834 177.72 399.392 177.72H388.352C338.848 177.72 309.202 166.979 291.935 152.053C274.682 137.138 269.712 117.976 269.712 100.94C269.712 96.3546 269.941 89.9387 270.857 83.2983ZM455.087 91.5835L455.087 91.5807C455.549 88.3448 455.782 85.5602 455.782 83C455.782 75.048 452.852 66.9572 444.979 60.8695C437.124 54.7956 424.406 50.76 404.912 50.76C383.683 50.76 369.875 55.49 361.134 62.3376C352.385 69.1909 348.768 78.1201 347.836 86.391C347.604 88.2458 347.372 90.5665 347.372 94.04C347.372 101.985 350.239 110.416 358.018 116.85C365.787 123.275 378.394 127.66 397.782 127.66C418.667 127.66 432.359 122.987 441.157 116.111C449.963 109.231 453.807 100.19 455.087 91.5835Z",
		fill: "#fff",
		stroke: "#fff",
		class: "path"
	}, null, -1), Mi("path", {
		d: "M191.695 154.054L191.372 153.481L190.906 153.946C185.016 159.837 163.751 177.72 113.98 177.72H108.69C65.0641 177.72 38.0654 167.158 21.975 152.237C5.88929 137.321 0.630005 117.978 0.630005 100.25C0.630005 94.0663 1.08793 88.1128 2.00371 82.1591C5.21243 62.9094 12.7067 42.6897 31.9242 27.27C51.1514 11.8425 82.188 1.16 132.61 1.16H139.74C195.012 1.16 225.229 11.563 241.512 25.0513C257.559 38.3439 260.153 54.704 259.776 67.32H183.132C182.456 64.9304 180.681 60.4234 174.363 56.4432C167.725 52.2618 156.118 48.69 135.6 48.69C116.32 48.69 103.031 53.1927 94.1777 60.1826C85.3194 67.1759 80.9563 76.615 79.446 86.3729C78.75 90.7811 78.75 93.8015 78.75 95.88C78.75 105.427 81.9562 114.204 89.5073 120.584C97.0467 126.955 108.851 130.88 125.94 130.88C143.938 130.88 156.093 127.65 163.94 123.755C167.863 121.808 170.712 119.694 172.674 117.731C174.629 115.777 175.726 113.95 176.102 112.572L176.275 111.94H175.62H124.913L130.049 78.67H259.213L243.734 174.5H197.906C197.53 171.85 196.748 168.179 195.709 164.514C194.613 160.649 193.22 156.751 191.695 154.054Z",
		fill: "#fff",
		stroke: "#fff",
		class: "path"
	}, null, -1)];
var xh = zl(vh, [
	["render", function(e, t) {
		return pi(), vi("svg", _h, yh)
	}]
]);
const bh = {},
	wh = {
		viewBox: "0 0 690 231",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg"
	},
	Sh = [Mi("g", {
		opacity: ".75",
		fill: "#ffffff"
	}, [Mi("path", {
		d: "M475.196 114.866 342.054 0h-127.22l127.22 114.866-127.22 114.866 127.22-.001 133.142-114.865Z",
		"fill-opacity": ".35"
	}), Mi("path", {
		d: "M261.244 115.188 128.103.323H.883l127.22 114.866L.883 230.054h127.22l133.141-114.866Z",
		"fill-opacity": ".1"
	}), Mi("path", {
		d: "M689.147 114.866 556.006 0H428.785l127.221 114.866-127.221 114.866 127.221-.001 133.141-114.865Z",
		"fill-opacity": ".6"
	})], -1)];
var Mh = zl(bh, [
	["render", function(e, t) {
		return pi(), vi("svg", wh, Sh)
	}]
]);
const Th = {
	then: () => Th,
	catch: () => Th
};

function Ch(e) {
	e && (e.pause && e.pause(), e.animatables.length = 0, e.animations.length = 0, e.children.length = 0, e.finished = Th)
}
const Eh = {
	class: "countdown__container"
};
var Ah = zl({
	setup(e, {
		expose: t
	}) {
		const n = Tt(),
			i = Tt(),
			r = Tt(),
			s = Tt(),
			a = Tt(),
			o = Tt(),
			l = Tt();
		let c, u;

		function h() {
			c && Ch(c), u && u.owner.unwatch(u), u = c = null
		}

		function d() {
			c && !Ol.game.paused.value && c.tick(1 * Ol.game.elapsed)
		}
		return pn((() => {
			n.value.style.display = "none"
		})), vn((() => {
			h()
		})), t({
			show: function() {
				h(), c = Xo.timeline({
					autoplay: !1
				}), u = Ol.hooks.afterFrame.watch(d), n.value && (n.value.style.display = "");
				const e = "cubicBezier(.87,0,.13,1)",
					t = "cubicBezier(.87,0,.13,1)",
					p = "cubicBezier(.7,.01,.17,.82)",
					f = "cubicBezier(.98,.14,.36,.98)",
					m = c.add({
						targets: i.value.querySelectorAll("path"),
						strokeDashoffset: {
							value: [Xo.setDashoffset, 0],
							duration: 1500,
							easing: e
						},
						fillOpacity: {
							value: [0, 1],
							duration: 750,
							delay: 400,
							easing: e
						}
					}).add({
						targets: i.value,
						scale: {
							value: [2.4, .9],
							duration: 2e3,
							easing: t
						},
						rotate: {
							value: ["10deg", "0deg"],
							duration: 2e3,
							easing: t
						},
						opacity: {
							value: [1, 0],
							duration: 1e3,
							easing: e,
							delay: 1400
						}
					}, "-=2000").add({
						targets: r.value.querySelectorAll("path"),
						strokeDashoffset: {
							value: [Xo.setDashoffset, 0],
							duration: 1500,
							easing: e
						},
						fillOpacity: {
							value: [0, 1],
							duration: 750,
							delay: 400,
							easing: e
						}
					}, "-=1000").add({
						targets: r.value,
						scale: {
							value: [2.4, .9],
							duration: 2e3,
							easing: t
						},
						rotate: {
							value: ["10deg", "0deg"],
							duration: 2e3,
							easing: t
						},
						opacity: {
							value: [1, 0],
							duration: 1e3,
							easing: e,
							delay: 1400
						}
					}, "-=2000").add({
						targets: s.value.querySelectorAll("path"),
						strokeDashoffset: {
							value: [Xo.setDashoffset, 0],
							duration: 1500,
							easing: e
						},
						fillOpacity: {
							value: [0, 1],
							duration: 750,
							delay: 400,
							easing: e
						}
					}, "-=1000").add({
						targets: s.value,
						scale: {
							value: [2.4, .9],
							duration: 2e3,
							easing: t
						},
						rotate: {
							value: ["10deg", "0deg"],
							duration: 2e3,
							easing: t
						},
						opacity: {
							value: [1, 0],
							duration: 1e3,
							easing: e,
							delay: 1400
						}
					}, "-=2000").add({
						targets: a.value.querySelectorAll("path"),
						strokeDashoffset: {
							value: [Xo.setDashoffset, 0],
							duration: 1500,
							easing: e
						},
						fillOpacity: {
							value: [0, 1],
							duration: 750,
							delay: 400,
							easing: e
						}
					}, "-=1000").add({
						targets: a.value,
						scale: {
							value: [2.4, .9],
							duration: 2e3,
							easing: t
						},
						rotate: {
							value: ["10deg", "0deg"],
							duration: 2e3,
							easing: t
						},
						opacity: {
							value: [1, 0],
							duration: 1e3,
							easing: e,
							delay: 1400
						}
					}, "-=2000");
				m.add({
					targets: o.value,
					translateX: {
						value: ["-100vw", "-10vw"],
						duration: 1e3,
						easing: p
					},
					translateY: {
						value: ["50vw", "10vw"],
						duration: 1e3,
						easing: p
					},
					translateZ: 0
				}, "-=1800").add({
					targets: o.value,
					translateX: {
						value: "100vw",
						duration: 650,
						easing: f
					},
					translateY: {
						value: "-50vw",
						duration: 650,
						easing: f
					},
					translateZ: 0
				}, "-=800"), m.add({
					targets: l.value,
					scale: [-1, -1],
					translateX: {
						value: ["-100vw", "-10vw"],
						duration: 1e3,
						easing: p
					},
					translateY: {
						value: ["50vw", "10vw"],
						duration: 1e3,
						easing: p
					},
					translateZ: 0
				}, "-=1800").add({
					targets: l.value,
					translateX: {
						value: "100vw",
						duration: 650,
						easing: f
					},
					translateY: {
						value: "-50vw",
						duration: 650,
						easing: f
					},
					translateZ: 0
				}, "-=800"), c.finished.then((() => {
					n.value && (n.value.style.display = "none"), h()
				}))
			},
			hide: function() {
				n.value.style.display = "none"
			}
		}), (e, t) => (pi(), vi("aside", {
			ref: (e, t) => {
				t.base = e, n.value = e
			},
			class: "game-countdown"
		}, [Mi("div", {
			ref: (e, t) => {
				t.topArrow = e, o.value = e
			},
			class: "countdown__arrowTop"
		}, [Ti(Mh)], 512), Mi("div", Eh, [Mi("div", {
			ref: (e, t) => {
				t.three = e, i.value = e
			},
			class: "countdown__show"
		}, [Ti(lh)], 512), Mi("div", {
			ref: (e, t) => {
				t.two = e, r.value = e
			},
			class: "countdown__show"
		}, [Ti(dh)], 512), Mi("div", {
			ref: (e, t) => {
				t.one = e, s.value = e
			},
			class: "countdown__show"
		}, [Ti(gh)], 512), Mi("div", {
			ref: (e, t) => {
				t.go = e, a.value = e
			},
			class: "countdown__show"
		}, [Ti(xh)], 512)]), Mi("div", {
			ref: (e, t) => {
				t.botArrow = e, l.value = e
			},
			class: "countdown__arrowBot"
		}, [Ti(Mh)], 512)], 512))
	}
}, [
	["__scopeId", "data-v-1cc75fb2"]
]);
const Ph = {},
	Lh = {
		viewBox: "0 0 1173 179",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg"
	},
	Ih = [Ai('<path d="M216.075 4.5L209.103 48.81H94.53H94.1046L94.0365 49.23L91.2765 66.25L91.1824 66.83H91.77H204.345L197.373 110.91H84.64H84.2132L84.1462 111.332L74.0932 174.62H0.585551L27.5669 4.5H216.075Z" fill="#fff" stroke="#fff"></path><path d="M205.205 174.62L232.186 4.5H306.844L279.862 174.62H205.205Z" fill="#fff" stroke="#fff"></path><path d="M569.802 4.5L542.82 174.62H467.81L388.38 80.4975L387.675 79.6623L387.504 80.7417L372.62 174.62H298.193L325.174 4.5H408.463L480.763 91.4896L481.471 92.3416L481.641 91.2469L495.146 4.5H569.802Z" fill="#fff" stroke="#fff"></path><path d="M560.986 174.62L587.967 4.5H662.625L635.643 174.62H560.986Z" fill="#fff" stroke="#fff"></path><path d="M896.088 124.302L896.086 124.313L896.084 124.325C893.917 138.587 887.888 151.89 871.056 161.659C854.18 171.453 826.401 177.72 780.659 177.72H755.589C706.875 177.72 681.218 167.778 668.075 155.175C655.128 142.761 654.226 127.665 655.522 116.62H741.291C741.326 120.708 741.856 125.864 745.945 130.04C750.196 134.38 758.182 137.55 773.069 137.55H773.759C788.847 137.55 797.359 135.481 802.109 132.56C804.497 131.092 805.939 129.405 806.779 127.661C807.617 125.921 807.839 124.158 807.839 122.56C807.839 120.569 807.591 118.76 806.705 117.157C805.815 115.547 804.313 114.204 801.916 113.08C797.161 110.849 788.731 109.41 774.02 108.491L774.02 108.491L774.009 108.49L745.723 107.341C745.722 107.341 745.721 107.34 745.721 107.34C714.715 105.847 695.464 99.4183 683.97 90.1434C672.504 80.8908 668.689 68.7488 668.689 55.63C668.689 53.8084 668.803 51.6983 669.002 49.7882C669.203 47.8667 669.486 46.188 669.813 45.2081L669.822 45.1826L669.827 45.1564C672.897 31.0567 680.895 20.1443 697.602 12.732C714.351 5.30066 739.852 1.38998 777.899 1.38998H802.509C848.595 1.38998 873.981 9.03784 887.501 19.6828C900.807 30.1602 902.697 43.6111 901.42 55.82H817.034C816.97 52.6173 816.232 48.7083 812.157 45.5737C807.912 42.3082 800.126 39.95 785.949 39.95H785.029C771.686 39.95 763.775 41.0391 759.189 42.9795C756.882 43.9554 755.381 45.1608 754.464 46.5831C753.547 48.0055 753.249 49.5909 753.249 51.26C753.249 52.8756 753.549 54.4193 754.482 55.8272C755.413 57.2319 756.94 58.449 759.298 59.4806C763.992 61.5339 772.125 62.9144 785.928 63.4896L785.928 63.4896L813.988 64.6396C845.027 65.9041 865.732 70.1003 878.67 77.8231C885.126 81.6767 889.641 86.4047 892.547 92.0863C895.456 97.7723 896.769 104.445 896.769 112.21C896.769 116.596 896.767 120.911 896.088 124.302Z" fill="#fff" stroke="#fff"></path><path d="M1171.59 4.38L1144.61 174.5H1069.95L1079.75 112.288L1079.84 111.71H1079.26H985.42H984.992L984.926 112.132L975.102 174.5H900.445L927.427 4.38H1002.08L992.746 62.2203L992.653 62.8H993.24H1087.08H1087.51L1087.57 62.3797L1096.94 4.38H1171.59Z" fill="#fff" stroke="#fff"></path>', 6)];
var Dh = zl(Ph, [
	["render", function(e, t) {
		return pi(), vi("svg", Lh, Ih)
	}]
]);
const Rh = {},
	kh = {
		xmlns: "http://www.w3.org/2000/svg",
		viewBox: "0 0 1385 207"
	},
	Nh = [Ai('<path fill="#FFFFFF" stroke="#FFFFFF" d="M165.6,177.76H87.44l-12.12,20.8H8.06l92.5-150.26h91.69l52.71,150.26h-72.91L165.6,177.76\n\tz M138.73,89.91l-27.27,46.45h41.6L138.73,89.91z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M315.86,198.57h-66.45L273.25,48.3H422.5c34.54,0,53.72,11.31,53.72,35.55\n\ts-20.4,36.35-38.37,39.59c18.38,5.45,30.09,17.97,27.06,37.57l-3.64,21.61c-1.41,8.69-0.4,12.32,0.4,14.74l-0.2,1.21h-68.26\n\tc-0.61-1.21-0.81-3.64-0.2-7.07l2.83-16.97c2.63-16.16-3.84-25.65-25.65-25.65h-46.45L315.86,198.57z M389.38,109.3\n\tc12.72,0,16.56-6.46,16.56-12.32c0-5.65-3.43-9.69-13.73-9.69h-58.77l-3.64,22.01H389.38z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M538.03,198.57h-66.45L495.41,48.3h149.25c34.54,0,53.72,11.31,53.72,35.55\n\ts-20.4,36.35-38.37,39.59c18.38,5.45,30.09,17.97,27.06,37.57l-3.64,21.61c-1.41,8.69-0.4,12.32,0.4,14.74l-0.2,1.21h-68.26\n\tc-0.61-1.21-0.81-3.64-0.2-7.07l2.83-16.97c2.63-16.16-3.84-25.65-25.65-25.65H545.9L538.03,198.57z M611.54,109.3\n\tc12.72,0,16.56-6.46,16.56-12.32c0-5.65-3.43-9.69-13.73-9.69H555.6l-3.64,22.01H611.54z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M760.19,198.57h-66.45L717.58,48.3h66.45L760.19,198.57z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M788.47,48.3h73.52l30.3,98.56l56.15-98.56h70.28l-87.65,150.26h-92.7L788.47,48.3z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M1193.21,48.3l-6.46,39.79h-104.01l-2.22,14.74h102.6l-6.26,39.18h-102.8l-2.62,16.36\n\th105.43l-6.26,40.19H999.73l23.83-150.26H1193.21z M1078.29,40.63l17.57-32.31h63.42l-23.63,32.31H1078.29z"></path><path fill="#FFFFFF" stroke="#FFFFFF" d="M1377,48.3l-6.46,39.79h-104.01l-2.22,14.74h102.6l-6.26,39.18h-102.8l-2.62,16.36h105.43\n\tl-6.26,40.19h-170.86l23.83-150.26H1377z"></path>', 7)];
var Oh = zl(Rh, [
	["render", function(e, t) {
		return pi(), vi("svg", kh, Nh)
	}]
]);
var Fh = {
	setup(e) {
		const t = __DATA.site.locale,
			n = {
				"fr-fr": Oh,
				default: Dh
			},
			i = n[t] || n.default;
		return (e, t) => (pi(), _i(ri(At(i))))
	}
};
const zh = {
	class: "finish__text"
};
var Uh = zl({
	setup(e, {
		expose: t
	}) {
		const n = Tt(),
			i = Tt(),
			r = Tt();
		let s, a;

		function o() {
			s && Ch(s), a && a.owner.unwatch(a), a = s = null
		}

		function l() {
			s && !Ol.game.paused.value && s.tick(1.5 * Ol.game.elapsed)
		}
		return pn((() => {
			n.value && (n.value.style.display = "none")
		})), vn((() => {
			o()
		})), t({
			hide: function() {
				if (!n.value) return;
				n.value.style.display = "none"
			},
			show: function() {
				const e = "cubicBezier(.7,.01,.17,.82)",
					t = "cubicBezier(.98,.14,.36,.98)";
				o(), s = Xo.timeline({
					autoplay: !1
				}), a = Ol.hooks.afterFrame.watch(l), n.value && (n.value.style.display = "");
				s.add({
					targets: ".finish__text",
					scale: [1.6, .7],
					rotate: [-14, -6],
					easing: "cubicBezier(.87,0,.13,1)",
					duration: 1500,
					delay: 0
				}).add({
					targets: ".finish__text path",
					strokeDashoffset: [Xo.setDashoffset, 0],
					easing: "cubicBezier(.87,0,.13,1)",
					duration: 1500,
					delay: Xo.stagger(100)
				}, "-=1500").add({
					targets: ".finish__text path",
					fillOpacity: [0, 1],
					easing: "cubicBezier(.87,0,.13,1)",
					duration: 900,
					delay: Xo.stagger(50)
				}, "-=1600").add({
					targets: ".finish__text",
					scale: .62,
					easing: "cubicBezier(.02,.01,.74,.94)",
					duration: 2e3
				}, "-=600").add({
					targets: ".finish__text path",
					strokeDashoffset: [0, Xo.setDashoffset],
					easing: "cubicBezier(.87,0,.13,1)",
					duration: 1500,
					delay: Xo.stagger(100, {
						direction: "reverse"
					})
				}, "-=2000").add({
					targets: ".finish__text path",
					fillOpacity: 0,
					easing: "cubicBezier(.87,0,.13,1)",
					duration: 900,
					delay: Xo.stagger(50, {
						direction: "reverse"
					})
				}, "-=1500"), s.add({
					targets: i.value,
					translateX: {
						value: ["-100vw", "-10vw"],
						duration: 2e3,
						easing: e
					},
					translateY: {
						value: ["50vw", "10vw"],
						duration: 2e3,
						easing: e
					}
				}, 110).add({
					targets: i.value,
					translateX: {
						value: "100vw",
						duration: 650,
						easing: t
					},
					translateY: {
						value: "-50vw",
						duration: 650,
						easing: t
					}
				}, "-=1400"), s.add({
					targets: r.value,
					scale: [-1, -1],
					translateX: {
						value: ["-100vw", "-10vw"],
						duration: 2e3,
						easing: e
					},
					translateY: {
						value: ["50vw", "10vw"],
						duration: 2e3,
						easing: e
					}
				}, 180).add({
					targets: r.value,
					translateX: {
						value: "100vw",
						duration: 650,
						easing: t
					},
					translateY: {
						value: "-50vw",
						duration: 650,
						easing: t
					}
				}, "-=1440"), s.finished.then((() => {
					n.value && (n.value.style.display = "none"), o()
				}))
			}
		}), (e, t) => (pi(), vi("section", {
			ref: (e, t) => {
				t.base = e, n.value = e
			},
			class: "game-finish"
		}, [Mi("div", {
			ref: (e, t) => {
				t.topArrow = e, i.value = e
			},
			class: "finish__arrowTop"
		}, [Ti(Mh)], 512), Mi("div", zh, [Ti(Fh)]), Mi("div", {
			ref: (e, t) => {
				t.bottomArrow = e, r.value = e
			},
			class: "finish__arrowBottom"
		}, [Ti(Mh)], 512)], 512))
	}
}, [
	["__scopeId", "data-v-b5f00cce"]
]);
const Bh = e => (Ut("data-v-4acd38e5"), e = e(), Bt(), e),
	Vh = {
		viewBox: "0 0 40 40"
	},
	Hh = Bh((() => Mi("circle", {
		cx: "20",
		cy: "20",
		r: "19"
	}, null, -1))),
	Gh = {
		class: "marks"
	},
	Wh = Bh((() => Mi("circle", {
		cx: "20",
		cy: "20",
		r: "0.7",
		class: "pin"
	}, null, -1)));
var qh = zl({
	setup(e, {
		expose: t
	}) {
		const n = Tt();
		let i = 0;
		return t({
			setTime: function(e) {
				const t = e / 1e3 | 0;
				if (!n.value || t === i) return;
				i = t, n.value.style.transform = "rotate(" + 6 * t + "deg)"
			}
		}), (e, t) => (pi(), vi("svg", Vh, [Hh, Mi("g", Gh, [(pi(), vi(oi, null, ki(12, (e => Mi("line", {
			key: e,
			x1: "15",
			y1: "0",
			x2: "16",
			y2: "0"
		}))), 64))]), Mi("line", {
			ref: (e, t) => {
				t.seconds = e, n.value = e
			},
			x1: "20",
			y1: "20",
			x2: "36",
			y2: "20",
			class: "seconds"
		}, null, 512), Wh]))
	}
}, [
	["__scopeId", "data-v-4acd38e5"]
]);
const jh = {
		class: "timer-value"
	},
	Yh = {
		class: "timer__icon"
	};
var Xh = zl({
	setup(e, {
		expose: t
	}) {
		const {
			csstween: n
		} = Sl(), i = Nl(), r = Tt(), s = Tt(), a = Tt(), o = "cubic-bezier(.64,.01,.11,1.28)", l = "cubic-bezier(0,0,.13,1) ";
		let c = 1e3,
			u = -1;

		function h() {
			if (!r.value) return;
			const e = i.game.racetime;
			if (++c < 3) return;
			c = 0;
			const t = e,
				n = (t / 1e3).toFixed(2);
			n !== u && (u = n, r.value.textContent = n, s.value.setTime(t))
		}
		return pn((() => {
			r.value.textContent = "0", i.hooks.afterFrame.watch(h), i.game.hooks.reset.watch(h), h()
		})), vn((() => {
			i.hooks.afterFrame.unwatch(h), i.game.hooks.reset.unwatch(h)
		})), t({
			show: function() {
				var e;
				a.value && (a.value.style.display = "", e = a.value, n({
					target: e,
					selector: ".timer-value",
					transform: ["translateY(-40px)", ""],
					duration: 1e3,
					ease: l,
					opacity: [0, ""]
				}), n({
					target: e,
					selector: ".timer__icon",
					transform: ["scale3d(0,0,0) rotate(15deg)", ""],
					duration: 1e3,
					ease: o,
					opacity: [0, ""]
				}))
			},
			hide: function() {
				a.value && (a.value.style.display = "none")
			}
		}), (e, t) => (pi(), vi("aside", {
			ref: (e, t) => {
				t.base = e, a.value = e
			},
			class: "game-timer"
		}, [Mi("div", jh, [Mi("p", {
			ref: (e, t) => {
				t.timer = e, r.value = e
			},
			class: "timer-value"
		}, null, 512)]), Mi("div", Yh, [Ti(qh, {
			ref: (e, t) => {
				t.clock = e, s.value = e
			}
		}, null, 512)])], 512))
	}
}, [
	["__scopeId", "data-v-b22c7eb4"]
]);
const $h = e => (Ut("data-v-5beb9de4"), e = e(), Bt(), e),
	Zh = {
		class: "turbo-help"
	},
	Kh = {
		class: "turbo-bar"
	},
	Jh = $h((() => Mi("aside", {
		class: "turbo-label"
	}, null, -1))),
	Qh = {
		class: "turbo-wrapper"
	},
	ed = $h((() => Mi("div", {
		class: "turbo-bt"
	}, null, -1))),
	td = $h((() => Mi("div", {
		class: "turbo-bb"
	}, null, -1)));
var nd = zl({
	setup(e, {
		expose: t
	}) {
		const n = Nl(),
			i = n.game,
			r = Tt(),
			s = Tt();

		function a(e) {
			s.value && s.value
		}

		function o() {
			s.value && (s.value.style.transform = "scaleX(" + i.turbo.progress + ")")
		}
		return pn((() => {
			n.hooks.afterFrame.watch(o), i.turbo.active.watch(a)
		})), vn((() => {
			n.hooks.afterFrame.unwatch(o), i.turbo.active.unwatch(a)
		})), t({
			show: function() {
				r.value && (r.value.style.display = "")
			},
			hide: function() {
				r.value && (r.value.style.display = "none")
			}
		}), (e, t) => (pi(), vi("aside", {
			ref: (e, t) => {
				t.base = e, r.value = e
			},
			class: g(["game-turbo", {
				turboWebRtc: e.$rtcDisplay.enabled.value,
				noCookie: e.$stores.noCookie
			}])
		}, [Mi("div", Zh, y(e.$l("game.help.line")), 1), Mi("div", Kh, [Jh, Mi("figure", Qh, [ed, td, Mi("div", {
			ref: (e, t) => {
				t.progress = e, s.value = e
			},
			class: "turbo-progress"
		}, null, 512)])])], 2))
	}
}, [
	["__scopeId", "data-v-5beb9de4"]
]);
const id = e => (Ut("data-v-21c8ca69"), e = e(), Bt(), e),
	rd = {
		key: 0,
		class: "tutorial-icon__content mobileIcon"
	},
	sd = [Ai('<svg width="122" height="41" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-21c8ca69><path d="M0 20.5 23.523 41H46L23.523 20.5 46 0H23.523L0 20.5Z" fill="#fff" fill-opacity=".15" class="p3" data-v-21c8ca69></path><path d="M37 20.5 61.546 41H85L61.546 20.5 85 0H61.546L37 20.5Z" fill="#fff" fill-opacity=".15" class="p2" data-v-21c8ca69></path><path d="M76 20.5 99.523 41H122L99.523 20.5 122 0H99.523L76 20.5Z" fill="#fff" fill-opacity=".15" class="p1" data-v-21c8ca69></path><defs data-v-21c8ca69><linearGradient id="a" x1="0" y1="20.5" x2="43.5" y2="20.5" gradientUnits="userSpaceOnUse" data-v-21c8ca69><stop stop-color="#fff" data-v-21c8ca69></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-21c8ca69></stop></linearGradient></defs></svg>', 1)],
	ad = [Ai('<svg width="122" height="41" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-21c8ca69><path d="M0 20.5 23.523 41H46L23.523 20.5 46 0H23.523L0 20.5Z" fill="#fff" fill-opacity=".15" class="p3" data-v-21c8ca69></path><path d="M37 20.5 61.546 41H85L61.546 20.5 85 0H61.546L37 20.5Z" fill="#fff" fill-opacity=".15" class="p2" data-v-21c8ca69></path><path d="M76 20.5 99.523 41H122L99.523 20.5 122 0H99.523L76 20.5Z" fill="#fff" fill-opacity=".15" class="p1" data-v-21c8ca69></path><defs data-v-21c8ca69><linearGradient id="a" x1="0" y1="20.5" x2="43.5" y2="20.5" gradientUnits="userSpaceOnUse" data-v-21c8ca69><stop stop-color="#fff" data-v-21c8ca69></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-21c8ca69></stop></linearGradient></defs></svg>', 1)],
	od = {
		key: 1,
		class: "tutorial-icon__content desktopIcon"
	},
	ld = {
		class: "iconContainer"
	},
	cd = {
		width: "340",
		viewBox: "0 0 340 220",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg"
	},
	ud = Ai('<rect x="1" y="121" width="98" height="98" rx="7" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="1" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="1" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="120" width="100" height="100" rx="8" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="121" y="1" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="120" y="120" width="100" height="100" rx="8" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="121" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><path opacity=".2" d="m170.333 177.333-8.333-14h16.667l-8.334 14Z" fill="#fff" data-v-21c8ca69></path><rect x="241" y="121" width="98" height="98" rx="7" fill="#fff" fill-opacity=".1" class="fill__path" data-v-21c8ca69></rect><rect x="241" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect><rect x="241" y="121" width="98" height="98" rx="7" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke__path" data-v-21c8ca69></rect>', 11),
	hd = [id((() => Mi("path", {
		d: "M292.667 169.667 276.985 156H262l14.985 13.667L262 183.333h14.985l15.682-13.666Z",
		fill: "#fff",
		"fill-opacity": ".15",
		class: "p1"
	}, null, -1))), id((() => Mi("path", {
		d: "M317.333 169.667 301.651 156h-14.984l14.984 13.667-14.984 13.666h14.984l15.682-13.666Z",
		fill: "#fff",
		"fill-opacity": ".15",
		class: "p2"
	}, null, -1)))],
	dd = [id((() => Mi("path", {
		d: "m46.667 169.666 15.682 13.667h14.984L62.35 169.666 77.333 156H62.35l-15.682 13.666Z",
		fill: "#fff",
		"fill-opacity": ".15",
		class: "p1"
	}, null, -1))), id((() => Mi("path", {
		d: "m22 169.666 15.682 13.667h14.985l-14.985-13.667L52.667 156H37.682L22 169.666Z",
		fill: "#fff",
		"fill-opacity": ".15",
		class: "p2"
	}, null, -1)))],
	pd = id((() => Mi("path", {
		opacity: ".2",
		d: "m169.667 42.667 8.333 14h-16.667l8.334-14Z",
		fill: "#fff"
	}, null, -1)));
var fd = zl({
	setup(e, {
		expose: t
	}) {
		const {
			wait: n
		} = tu(), i = Tt();
		let r, s;
		return t({
			show: async function(e = 0) {
				e > 0 && await n(e);
				for (let t = 0; t < r.length; t++) r[t] && r[t].classList.remove("animated"), s[t] && s[t].classList.remove("animated");
				i.value.getBoundingClientRect();
				for (let t = 0; t < r.length; t++) r[t] && r[t].classList.add("animated"), s[t] && s[t].classList.add("animated"), await n(100)
			}
		}), pn((() => {
			r = [...i.value.querySelectorAll(".stroke__path")], s = [...i.value.querySelectorAll(".fill__path")]
		})), vn((() => {
			r = s = null
		})), (e, t) => (pi(), vi("div", {
			ref: (e, t) => {
				t.parent = e, i.value = e
			},
			class: "tutorial-icon"
		}, [e.$device.hasTouch ? (pi(), vi("div", rd, [Mi("div", {
			ref: (e, t) => {
				t.leftArrow = e
			},
			class: "iconContainer leftArrow"
		}, sd, 512), Mi("div", {
			ref: (e, t) => {
				t.rightArrow = e
			},
			class: "iconContainer rightArrow"
		}, ad, 512)])) : Pi("", !0), !e.$device.hasTouch || e.$device.hasTouch && e.$device.type.desktop ? (pi(), vi("div", od, [Mi("div", ld, [(pi(), vi("svg", cd, [ud, Mi("g", {
			ref: (e, t) => {
				t.rightArrowDesk = e
			},
			class: "rightArrowDesk"
		}, hd, 512), Mi("g", {
			ref: (e, t) => {
				t.leftArrowDesk = e
			},
			class: "leftArrowDesk"
		}, dd, 512), pd]))])])) : Pi("", !0)], 512))
	}
}, [
	["__scopeId", "data-v-21c8ca69"]
]);
const md = {},
	gd = {
		id: "Calque_1",
		version: "1.1",
		xmlns: "http://www.w3.org/2000/svg",
		"xmlns:xlink": "http://www.w3.org/1999/xlink",
		x: "0px",
		y: "0px",
		viewBox: "0 0 124.8 124.8",
		style: {
			"enable-background": "new 0 0 124.8 124.8"
		},
		"xml:space": "preserve"
	},
	vd = [Ai('<g id="Calque_2_00000012470279984753687110000009903509704728823700_" data-v-1346bdf8><g id="Calque_1-2" data-v-1346bdf8><path class="st0" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="-658.5411" y1="-1101.5081" x2="-729.8611" y2="-1173.198" gradientTransform="matrix(-0.7071 0.7071 -0.7071 -0.7071 -1234.0486 -250.9608)" data-v-1346bdf8><stop offset="0" style="stop-color:#fff;stop-opacity:0.7;" data-v-1346bdf8></stop><stop offset="1" style="stop-color:#fff;stop-opacity:0;" data-v-1346bdf8></stop></linearGradient><path class="st1" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><path class="st2" d="M16.4,57.1l40.7-40.7c2.9-2.9,7.7-2.9,10.6,0l40.7,40.7c2.9,2.9,2.9,7.7,0,10.6l-40.7,40.7\n\t\t\tc-2.9,2.9-7.7,2.9-10.6,0L16.4,67.7C13.5,64.8,13.5,60,16.4,57.1z" data-v-1346bdf8></path><g class="st3" data-v-1346bdf8><linearGradient id="SVGID_00000024693049670814976720000014288652510690531007_" gradientUnits="userSpaceOnUse" x1="-620.7462" y1="-1079.4329" x2="-713.7062" y2="-1172.8829" gradientTransform="matrix(-0.7071 0.7071 -0.7071 -0.7071 -1207.0938 -262.119)" data-v-1346bdf8><stop offset="0" style="stop-color:#fff;" data-v-1346bdf8></stop><stop offset="1" style="stop-color:#fff;stop-opacity:0;" data-v-1346bdf8></stop></linearGradient><path style="fill:none;stroke:url(#SVGID_00000024693049670814976720000014288652510690531007_);" d="M4.2,53.6L53.6,4.2\n\t\t\t\tc4.9-4.9,12.8-4.9,17.7,0l49.4,49.4c4.9,4.9,4.9,12.8,0,17.7l-49.4,49.4c-4.9,4.9-12.8,4.9-17.7,0L4.2,71.2\n\t\t\t\tC-0.7,66.4-0.7,58.4,4.2,53.6z" data-v-1346bdf8></path><path class="st2" d="M4.2,53.6L53.6,4.2c4.9-4.9,12.8-4.9,17.7,0l49.4,49.4c4.9,4.9,4.9,12.8,0,17.7l-49.4,49.4\n\t\t\t\tc-4.9,4.9-12.8,4.9-17.7,0L4.2,71.2C-0.7,66.4-0.7,58.4,4.2,53.6z" data-v-1346bdf8></path></g><path class="st5" d="M51.4,61.9l10.2,8.5h9.8l-9.8-8.5l9.8-8.5h-9.8L51.4,61.9z" data-v-1346bdf8></path></g></g>', 1)];
var _d = zl(md, [
	["render", function(e, t) {
		return pi(), vi("svg", gd, vd)
	}],
	["__scopeId", "data-v-1346bdf8"]
]);
const yd = {
		class: "tutorial__topLine"
	},
	xd = {
		key: 0,
		class: "tutorial__content"
	},
	bd = ["innerHTML"],
	wd = {
		key: 1,
		class: "tutorial__content"
	},
	Sd = {
		class: "keys__left keys"
	},
	Md = {
		class: "keys__right keys"
	},
	Td = {
		class: "tutorial__botLine"
	};
var Cd = zl({
	setup(e, {
		expose: t
	}) {
		const n = El(),
			i = n.$device.hasTouch,
			{
				csstween: r
			} = Sl(),
			{
				wait: s
			} = tu(),
			a = n.$l(`tutorial.${i?"mobile":"desktop"}.desc`),
			o = Tt(),
			l = Tt(),
			c = Tt(),
			u = Tt(),
			h = Tt(),
			d = Tt(),
			p = Tt(),
			f = [];

		function m() {
			for (const e of f) e && e.destroy();
			f.length = 0
		}
		return t({
			show: async function() {
				if (n.$stores.gameTutorialVisible = !0, !o.value) return;
				const e = "cubic-bezier(0,0,.13,1) ";
				let t = 20;
				o.value.style.display = "", o.value.style.opacity = "", m(), f.push(r({
					target: d.value,
					transform: ["scaleY(0)", "scaleY(1)"],
					duration: 1e3,
					ease: e,
					delay: t += 0
				})), f.push(r({
					target: p.value,
					transform: ["scaleY(0)", "scaleY(1)"],
					duration: 800,
					ease: e,
					delay: t += 0
				})), f.push(r({
					target: l.value,
					transform: ["translateY(-40px)", ""],
					duration: 1e3,
					ease: e,
					delay: t += 0,
					opacity: [0, ""]
				})), f.push(r({
					target: c.value,
					transform: ["translateY(-40px)", ""],
					duration: 1e3,
					ease: e,
					delay: i ? t : t += 150,
					opacity: [0, ""]
				})), f.push(r({
					target: u.value,
					duration: 800,
					ease: e,
					delay: t += i ? 350 : 20,
					opacity: [0, ""],
					transform: i ? "" : ["scale3d(0,0,0) rotate(15deg)", ""]
				})), h.value && h.value.show(t += 10);
				await s(t + (i ? 100 : 300))
			},
			hide: async function() {
				if (n.$stores.gameTutorialVisible = !1, !o.value) return;
				m();
				const e = r({
					target: o.value,
					opacity: 0,
					duration: 700
				});
				f.push(e), await e.finished, o.value.style.display = "none"
			}
		}), pn((() => {
			o.value.style.display = "none"
		})), vn((() => {
			m(), n.$stores.gameTutorialVisible = !1
		})), (e, t) => (pi(), vi("div", {
			ref: (e, t) => {
				t.base = e, o.value = e
			},
			class: g(["game-tutorial", {
				tutoWebRtc: e.$rtcDisplay.enabled.value
			}])
		}, [Mi("div", yd, [Mi("div", {
			ref: (e, t) => {
				t.topLineEl = e, d.value = e
			},
			class: "line"
		}, null, 512)]), e.$rtcDisplay.enabled.value ? Pi("", !0) : (pi(), vi("div", xd, [Mi("p", {
			ref: (e, t) => {
				t.titleEl = e, l.value = e
			},
			class: "tutorial__title"
		}, y(e.$l("tutorial.title")), 513), Mi("p", {
			ref: (e, t) => {
				t.textEl = e, c.value = e
			},
			class: "tutorial__text",
			innerHTML: At(a)
		}, null, 8, bd), Mi("div", {
			ref: (e, t) => {
				t.iconEl = e, u.value = e
			},
			class: "tutorial__icon"
		}, [Ti(fd, {
			ref: (e, t) => {
				t.iconInstance = e, h.value = e
			}
		}, null, 512)], 512)])), e.$rtcDisplay.enabled.value ? (pi(), vi("div", wd, [Mi("p", {
			ref: (e, t) => {
				t.titleEl = e, l.value = e
			},
			class: "tutorial__title"
		}, y(e.$l("tutorial.title")), 513), Mi("p", {
			ref: (e, t) => {
				t.textEl = e, c.value = e
			},
			class: "tutorial__text"
		}, y(e.$l("webRTC.tutorial.borne.desc")), 513), Mi("div", {
			ref: (e, t) => {
				t.iconEl = e, u.value = e
			},
			class: "tutorial__icons"
		}, [Mi("div", Sd, [Ti(_d)]), Mi("div", Md, [Ti(_d)])], 512)])) : Pi("", !0), Mi("div", Td, [Mi("div", {
			ref: (e, t) => {
				t.botLineEl = e, p.value = e
			},
			class: "line"
		}, null, 512)])], 2))
	}
}, [
	["__scopeId", "data-v-356cc4a0"]
]);
const Ed = {
	class: "page page-game"
};
var Ad = zl({
	setup(e) {
		Ll.$device.hasTouch;
		const t = Cd,
			n = kc(),
			i = Tt(),
			r = Tt(),
			s = Tt(),
			a = Tt(),
			o = Tt(),
			l = {
				hideAll: function() {
					i.value && i.value.hide();
					r.value && r.value.hide();
					s.value && s.value.hide();
					a.value && a.value.hide();
					o.value && o.value.hide()
				},
				countdown: i,
				finish: r,
				timer: s,
				turbo: a,
				tuto: o
			};
		return pn((() => {
			Ol.game.setView(l), n.pageview({
				title: "game",
				url: "/game"
			})
		})), vn((() => {
			Ol.game.removeView(l)
		})), (e, n) => (pi(), vi("section", Ed, [Ti(Ah, {
			ref: (e, t) => {
				t.countdown = e, i.value = e
			}
		}, null, 512), Ti(Uh, {
			ref: (e, t) => {
				t.finish = e, r.value = e
			}
		}, null, 512), Ti(Xh, {
			ref: (e, t) => {
				t.timer = e, s.value = e
			}
		}, null, 512), Ti(nd, {
			ref: (e, t) => {
				t.turbo = e, a.value = e
			}
		}, null, 512), (pi(), _i(ri(At(t)), {
			ref: (e, t) => {
				t.tuto = e, o.value = e
			}
		}, null, 512)), Ei(" " + y(), 1)]))
	}
}, [
	["__scopeId", "data-v-664552d6"]
]);
const Pd = {},
	Ld = {},
	Id = {
		ref: "square",
		viewBox: "0 0 502 502",
		fill: "none",
		xmlns: "http://www.w3.org/2000/svg",
		class: "icon__frame"
	},
	Dd = {
		ref: "path",
		x: "2",
		y: "2",
		width: "498",
		height: "498",
		rx: "23",
		fill: "#000",
		"fill-opacity": ".1",
		class: "path"
	},
	Rd = Ai('<rect x="2" y="2" width="498" height="498" rx="23" stroke="url(#a)" stroke-width="4" class="stroke s1"></rect><rect x="2" y="2" width="498" height="498" rx="23" stroke="#fff" stroke-opacity=".2" stroke-width="2" class="stroke s2"></rect><defs><linearGradient id="a" x1="0" y1="251" x2="502" y2="251" gradientUnits="userSpaceOnUse"><stop stop-color="#fff"></stop><stop offset="1" stop-color="#fff" stop-opacity="0"></stop></linearGradient></defs>', 3);
var kd = zl(Ld, [
	["render", function(e, t) {
		return pi(), vi("svg", Id, [Mi("rect", Dd, null, 512), Rd], 512)
	}]
]);
const Nd = {
		class: "language-picker"
	},
	Od = ["textContent"],
	Fd = ["value", "selected", "textContent"];
var zd = zl({
	setup(e) {
		const t = Tt(!1),
			n = window.__DATA.site,
			i = n.locales[n.locale],
			r = Object.values(n.locales).map((e => ({
				id: e.id,
				text: e.name,
				selected: e.id === i.id || null
			}))),
			s = i.name;

		function a() {
			const e = t.value,
				n = e.selectedIndex,
				r = e.options[n].value,
				s = __DATA.site.locales[r];
			if (s.id === i.id) return;
			let a = new Date;
			a.setTime(Date.now() + 12096e5), document.cookie = "preferred_language=" + s.id + ";path=/;expires=" + a + ";samesite=lax", window.location.href = window.location.origin + __DATA.config.basepath + (s.default ? "" : s.id + "/")
		}
		return (e, n) => (pi(), vi("div", Nd, [Mi("div", {
			class: "current",
			textContent: y(At(s))
		}, null, 8, Od), Mi("select", {
			ref: (e, n) => {
				n.selector = e, t.value = e
			},
			onInput: a,
			onBlur: a
		}, [(pi(!0), vi(oi, null, ki(At(r), (e => (pi(), vi("option", {
			key: e.id,
			value: e.id,
			selected: e.selected,
			textContent: y(e.text)
		}, null, 8, Fd)))), 128))], 544)]))
	}
}, [
	["__scopeId", "data-v-36c1e9d0"]
]);
const Ud = {
		class: "title"
	},
	Bd = {
		class: "qrContainer"
	};
var Vd = zl({
	setup(e, {
		expose: t
	}) {
		t({
			enter: async function() {
				Nl() && Nl().audio.setBgm("intro");
				const e = Xo.timeline();
				i.value.getBoundingClientRect(), i.value.classList.add("visible"), e.add({
					targets: ".page-qr .title",
					translateY: ["-40px", "0px"],
					opacity: [0, 1],
					duration: 1e3,
					easing: "cubicBezier(0,0,.13,1)"
				}, 0).add({
					targets: ".page-qr .separator",
					translateY: ["-40px", "0px"],
					opacity: [0, 1],
					duration: 1e3,
					easing: "cubicBezier(0,0,.13,1)"
				}, 150).add({
					targets: ".page-qr .qrContainer",
					scale: [1.3, 1],
					rotate: [-5, 0],
					opacity: [0, 1],
					duration: 1e3,
					easing: "cubicBezier(0.000, 0.340, 0.405, 0.995)"
				}, 700).add({
					targets: ".page-qr .square",
					strokeDashoffset: [1970, 0],
					opacity: [1, 1],
					duration: 1500,
					easing: "cubicBezier(0.490, 0.070, 0.080, 1.005)"
				}, 600)
			},
			leave: async function(e) {
				return e.classList.add("leave"), n({
					target: e,
					transform: ["", "scale3d(0.6,0.6,0.6)"],
					duration: 800,
					ease: "cubic-bezier(.87,0,.13,1)",
					opacity: ["", 0],
					autoClear: !1
				}).finished
			}
		});
		const {
			csstween: n
		} = Sl(), i = Tt(), r = Tt(), s = Tt(), a = Tt();
		return pn((async () => {
			Ll.$stats.init(), Ll.$rtcDisplay.enable();
			const [e] = await Promise.all([(t = () => import("./qrious.e5d3c545798ddcc2.js").then((function(e) {
				return e.q
			})), n = [], n && 0 !== n.length ? Promise.all(n.map((e => {
				if ((e = `/${e}`) in Pd) return;
				Pd[e] = !0;
				const t = e.endsWith(".css"),
					n = t ? '[rel="stylesheet"]' : "";
				if (document.querySelector(`link[href="${e}"]${n}`)) return;
				const i = document.createElement("link");
				return i.rel = t ? "stylesheet" : "modulepreload", t || (i.as = "script", i.crossOrigin = ""), i.href = e, document.head.appendChild(i), t ? new Promise(((e, t) => {
					i.addEventListener("load", e), i.addEventListener("error", t)
				})) : void 0
			}))).then((() => t())) : t()), Ll.$rtcDisplay.createRoom()]);
			var t, n;
			i.value && (new e.default({
				element: r.value,
				background: "transparent",
				foreground: "white",
				level: "M",
				size: 200,
				value: Ll.$rtcDisplay.roomURL
			}), i.value.classList.add("qrcode-visible"))
		})), (e, t) => (pi(), vi("section", {
			ref: (e, t) => {
				t.base = e, i.value = e
			},
			class: "page page-qr"
		}, [Mi("div", Ud, [Mi("h1", null, y(e.$l("webRTC.home")), 1)]), Ti(wc), Mi("div", Bd, [Mi("div", {
			ref: (e, t) => {
				t.qrSpinner = e, a.value = e
			},
			class: "loading"
		}, null, 512), Mi("div", {
			ref: (e, t) => {
				t.qrFrame = e, s.value = e
			},
			class: "frame"
		}, [Ti(kd, {
			class: "square"
		})], 512), Mi("canvas", {
			ref: (e, t) => {
				t.qrCode = e, r.value = e
			},
			class: "qrcode"
		}, null, 512)]), Ti(zd)], 512))
	}
}, [
	["__scopeId", "data-v-7edf3d7e"]
]);

function Hd(e) {
	const t = new Uint8Array(e);
	for (let n = 0; n < e; n++) t[n] = 256 * Math.random() | 0;
	return t
}

function Gd() {
	if ("undefined" == typeof globalThis) return null;
	const e = {
		RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
		RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
		RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
	};
	return e.RTCPeerConnection ? e : null
}

function Wd(e, t) {
	return Object.defineProperty(e, "code", {
		value: t,
		enumerable: !0,
		configurable: !0
	}), e
}

function qd(e) {
	return e.replace(/a=ice-options:trickle\s\n/g, "")
}
class jd {
	constructor(e = {}) {
		if (this._map = new Map, this._id = Hd(4).toString("hex").slice(0, 7), this._doDebug = e.debug, this._debug("new peer %o", e), this.channelName = e.initiator ? e.channelName || Hd(20).toString("hex") : null, this.initiator = e.initiator || !1, this.channelConfig = e.channelConfig || jd.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, jd.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || (e => e), this.streams = e.streams || (e.stream ? [e.stream] : []), this.trickle = void 0 === e.trickle || e.trickle, this.allowHalfTrickle = void 0 !== e.allowHalfTrickle && e.allowHalfTrickle, this.iceCompleteTimeout = e.iceCompleteTimeout || 5e3, this.destroyed = !1, this.destroying = !1, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e.wrtc && "object" == typeof e.wrtc ? e.wrtc : Gd(), !this._wrtc) throw "undefined" == typeof window ? Wd(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT") : Wd(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
		this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = !1, this._firstNegotiation = !0, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._senderMap = new Map, this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
		try {
			this._pc = new this._wrtc.RTCPeerConnection(this.config)
		} catch (t) {
			return void this.destroy(Wd(t, "ERR_PC_CONSTRUCTOR"))
		}
		this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
			this._onIceStateChange()
		}, this._pc.onicegatheringstatechange = () => {
			this._onIceStateChange()
		}, this._pc.onconnectionstatechange = () => {
			this._onConnectionStateChange()
		}, this._pc.onsignalingstatechange = () => {
			this._onSignalingStateChange()
		}, this._pc.onicecandidate = e => {
			this._onIceCandidate(e)
		}, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e => {
			this.destroy(Wd(e, "ERR_PC_PEER_IDENTITY"))
		})), this.initiator || this.channelNegotiated ? this._setupData({
			channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
		}) : this._pc.ondatachannel = e => {
			this._setupData(e)
		}, this.streams && this.streams.forEach((e => {
			this.addStream(e)
		})), this._pc.ontrack = e => {
			this._onTrack(e)
		}, this._debug("initial negotiation"), this._needsNegotiation()
	}
	get bufferSize() {
		return this._channel && this._channel.bufferedAmount || 0
	}
	get connected() {
		return this._connected && "open" === this._channel.readyState
	}
	address() {
		return {
			port: this.localPort,
			family: this.localFamily,
			address: this.localAddress
		}
	}
	signal(e) {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
			if ("string" == typeof e) try {
				e = JSON.parse(e)
			} catch (t) {
				e = {}
			}
			this._debug("signal()"), e.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then((() => {
				this.destroyed || (this._pendingCandidates.forEach((e => {
					this._addIceCandidate(e)
				})), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer())
			})).catch((e => {
				this.destroy(Wd(e, "ERR_SET_REMOTE_DESCRIPTION"))
			})), e.sdp || e.candidate || e.renegotiate || e.transceiverRequest || this.destroy(Wd(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"))
		}
	}
	_addIceCandidate(e) {
		const t = new this._wrtc.RTCIceCandidate(e);
		this._pc.addIceCandidate(t).catch((e => {
			!t.address || t.address.endsWith(".local") || this.destroy(Wd(e, "ERR_ADD_ICE_CANDIDATE"))
		}))
	}
	send(e) {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
			this._channel.send(e)
		}
	}
	addTransceiver(e, t) {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
			if (this._debug("addTransceiver()"), this.initiator) try {
				this._pc.addTransceiver(e, t), this._needsNegotiation()
			} catch (n) {
				this.destroy(Wd(n, "ERR_ADD_TRANSCEIVER"))
			} else this.emit("signal", {
				type: "transceiverRequest",
				transceiverRequest: {
					kind: e,
					init: t
				}
			})
		}
	}
	addStream(e) {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
			this._debug("addStream()"), e.getTracks().forEach((t => {
				this.addTrack(t, e)
			}))
		}
	}
	addTrack(e, t) {
		if (this.destroying) return;
		if (this.destroyed) throw Wd(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
		this._debug("addTrack()");
		const n = this._senderMap.get(e) || new Map;
		let i = n.get(t);
		if (i) throw i.removed ? Wd(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED") : Wd(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
		i = this._pc.addTrack(e, t), n.set(t, i), this._senderMap.set(e, n), this._needsNegotiation()
	}
	replaceTrack(e, t, n) {
		if (this.destroying) return;
		if (this.destroyed) throw Wd(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
		this._debug("replaceTrack()");
		const i = this._senderMap.get(e),
			r = i ? i.get(n) : null;
		if (!r) throw Wd(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
		t && this._senderMap.set(t, i), null != r.replaceTrack ? r.replaceTrack(t) : this.destroy(Wd(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"))
	}
	removeTrack(e, t) {
		if (this.destroying) return;
		if (this.destroyed) throw Wd(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
		this._debug("removeSender()");
		const n = this._senderMap.get(e),
			i = n ? n.get(t) : null;
		if (!i) throw Wd(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
		try {
			i.removed = !0, this._pc.removeTrack(i)
		} catch (r) {
			"NS_ERROR_UNEXPECTED" === r.name ? this._sendersAwaitingStable.push(i) : this.destroy(Wd(r, "ERR_REMOVE_TRACK"))
		}
		this._needsNegotiation()
	}
	removeStream(e) {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
			this._debug("removeSenders()"), e.getTracks().forEach((t => {
				this.removeTrack(t, e)
			}))
		}
	}
	_needsNegotiation() {
		this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = !0, queueMicrotask((() => {
			this._batchedNegotiation = !1, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = !1
		})))
	}
	negotiate() {
		if (!this.destroying) {
			if (this.destroyed) throw Wd(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
			this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout((() => {
				this._createOffer()
			}), 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", {
				type: "renegotiate",
				renegotiate: !0
			})), this._isNegotiating = !0
		}
	}
	destroy(e) {
		this.destroyed || this.destroying || (this.destroying = !0, this._debug("destroying (error: %s)", e && (e.message || e)), queueMicrotask((() => {
			if (this.destroyed = !0, this.destroying = !1, this._debug("destroy (error: %s)", e && (e.message || e)), this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._channel) {
				try {
					this._channel.close()
				} catch (t) {}
				this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null
			}
			if (this._pc) {
				try {
					this._pc.close()
				} catch (t) {}
				this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null
			}
			this._pc = null, this._channel = null, e && this.emit("error", e), this.emit("close")
		})))
	}
	_setupData(e) {
		if (!e.channel) return this.destroy(Wd(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
		this._channel = e.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = 65536), this.channelName = this._channel.label, this._channel.onmessage = e => {
			this._onChannelMessage(e)
		}, this._channel.onbufferedamountlow = () => {
			this._onChannelBufferedAmountLow()
		}, this._channel.onopen = () => {
			this._onChannelOpen()
		}, this._channel.onclose = () => {
			this._onChannelClose()
		}, this._channel.onerror = e => {
			this.destroy(Wd(e, "ERR_DATA_CHANNEL"))
		};
		let t = !1;
		this._closingInterval = setInterval((() => {
			this._channel && "closing" === this._channel.readyState ? (t && this._onChannelClose(), t = !0) : t = !1
		}), 5e3)
	}
	_startIceCompleteTimeout() {
		this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout((() => {
			this._iceComplete || (this._iceComplete = !0, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"))
		}), this.iceCompleteTimeout))
	}
	_createOffer() {
		this.destroyed || this._pc.createOffer(this.offerOptions).then((e => {
			if (this.destroyed) return;
			this.trickle || this.allowHalfTrickle || (e.sdp = qd(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
			const t = () => {
				if (this.destroyed) return;
				const t = this._pc.localDescription || e;
				this._debug("signal"), this.emit("signal", {
					type: t.type,
					sdp: t.sdp
				})
			};
			this._pc.setLocalDescription(e).then((() => {
				this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t() : this.once("_iceComplete", t))
			})).catch((e => {
				this.destroy(Wd(e, "ERR_SET_LOCAL_DESCRIPTION"))
			}))
		})).catch((e => {
			this.destroy(Wd(e, "ERR_CREATE_OFFER"))
		}))
	}
	_requestMissingTransceivers() {
		this._pc.getTransceivers && this._pc.getTransceivers().forEach((e => {
			e.mid || !e.sender.track || e.requested || (e.requested = !0, this.addTransceiver(e.sender.track.kind))
		}))
	}
	_createAnswer() {
		this.destroyed || this._pc.createAnswer(this.answerOptions).then((e => {
			if (this.destroyed) return;
			this.trickle || this.allowHalfTrickle || (e.sdp = qd(e.sdp)), e.sdp = this.sdpTransform(e.sdp);
			const t = () => {
				if (this.destroyed) return;
				const t = this._pc.localDescription || e;
				this._debug("signal"), this.emit("signal", {
					type: t.type,
					sdp: t.sdp
				}), this.initiator || this._requestMissingTransceivers()
			};
			this._pc.setLocalDescription(e).then((() => {
				this.destroyed || (this.trickle || this._iceComplete ? t() : this.once("_iceComplete", t))
			})).catch((e => {
				this.destroy(Wd(e, "ERR_SET_LOCAL_DESCRIPTION"))
			}))
		})).catch((e => {
			this.destroy(Wd(e, "ERR_CREATE_ANSWER"))
		}))
	}
	_onConnectionStateChange() {
		this.destroyed || "failed" === this._pc.connectionState && this.destroy(Wd(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"))
	}
	_onIceStateChange() {
		if (this.destroyed) return;
		const e = this._pc.iceConnectionState,
			t = this._pc.iceGatheringState;
		this._debug("iceStateChange (connection: %s) (gathering: %s)", e, t), this.emit("iceStateChange", e, t), "connected" !== e && "completed" !== e || (this._pcReady = !0, this._maybeReady()), "failed" === e && this.destroy(Wd(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e && this.destroy(Wd(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"))
	}
	getStats(e) {
		const t = e => ("[object Array]" === Object.prototype.toString.call(e.values) && e.values.forEach((t => {
			Object.assign(e, t)
		})), e);
		0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n => {
			const i = [];
			n.forEach((e => {
				i.push(t(e))
			})), e(null, i)
		}), (t => e(t))) : this._pc.getStats.length > 0 ? this._pc.getStats((n => {
			if (this.destroyed) return;
			const i = [];
			n.result().forEach((e => {
				const n = {};
				e.names().forEach((t => {
					n[t] = e.stat(t)
				})), n.id = e.id, n.type = e.type, n.timestamp = e.timestamp, i.push(t(n))
			})), e(null, i)
		}), (t => e(t))) : e(null, [])
	}
	_maybeReady() {
		if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady) return;
		this._connecting = !0;
		const e = () => {
			this.destroyed || this.getStats(((t, n) => {
				if (this.destroyed) return;
				t && (n = []);
				const i = {},
					r = {},
					s = {};
				let a = !1;
				n.forEach((e => {
					"remotecandidate" !== e.type && "remote-candidate" !== e.type || (i[e.id] = e), "localcandidate" !== e.type && "local-candidate" !== e.type || (r[e.id] = e), "candidatepair" !== e.type && "candidate-pair" !== e.type || (s[e.id] = e)
				}));
				const o = e => {
					a = !0;
					let t = r[e.localCandidateId];
					t && (t.ip || t.address) ? (this.localAddress = t.ip || t.address, this.localPort = Number(t.port)) : t && t.ipAddress ? (this.localAddress = t.ipAddress, this.localPort = Number(t.portNumber)) : "string" == typeof e.googLocalAddress && (t = e.googLocalAddress.split(":"), this.localAddress = t[0], this.localPort = Number(t[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
					let n = i[e.remoteCandidateId];
					n && (n.ip || n.address) ? (this.remoteAddress = n.ip || n.address, this.remotePort = Number(n.port)) : n && n.ipAddress ? (this.remoteAddress = n.ipAddress, this.remotePort = Number(n.portNumber)) : "string" == typeof e.googRemoteAddress && (n = e.googRemoteAddress.split(":"), this.remoteAddress = n[0], this.remotePort = Number(n[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort)
				};
				if (n.forEach((e => {
						"transport" === e.type && e.selectedCandidatePairId && o(s[e.selectedCandidatePairId]), ("googCandidatePair" === e.type && "true" === e.googActiveConnection || ("candidatepair" === e.type || "candidate-pair" === e.type) && e.selected) && o(e)
					})), a || Object.keys(s).length && !Object.keys(r).length) {
					if (this._connecting = !1, this._connected = !0, this._chunk) {
						try {
							this.send(this._chunk)
						} catch (l) {
							return this.destroy(Wd(l, "ERR_DATA_CHANNEL"))
						}
						this._chunk = null, this._debug('sent chunk from "write before connect"');
						const e = this._cb;
						this._cb = null, e(null)
					}
					"number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval((() => this._onInterval()), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect")
				} else setTimeout(e, 100)
			}))
		};
		e()
	}
	_onInterval() {
		!this._cb || !this._channel || this._channel.bufferedAmount > 65536 || this._onChannelBufferedAmountLow()
	}
	_onSignalingStateChange() {
		this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = !1, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e => {
			this._pc.removeTrack(e), this._queuedNegotiation = !0
		})), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = !1, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState))
	}
	_onIceCandidate(e) {
		this.destroyed || (e.candidate && this.trickle ? this.emit("signal", {
			type: "candidate",
			candidate: {
				candidate: e.candidate.candidate,
				sdpMLineIndex: e.candidate.sdpMLineIndex,
				sdpMid: e.candidate.sdpMid
			}
		}) : e.candidate || this._iceComplete || (this._iceComplete = !0, this.emit("_iceComplete")), e.candidate && this._startIceCompleteTimeout())
	}
	_onChannelMessage(e) {
		if (this.destroyed) return;
		let t = e.data;
		t instanceof ArrayBuffer && (t = new Uint8Array(t)), this.emit("data", t)
	}
	_onChannelBufferedAmountLow() {
		if (this.destroyed || !this._cb) return;
		this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
		const e = this._cb;
		this._cb = null, e(null)
	}
	_onChannelOpen() {
		this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = !0, this._maybeReady())
	}
	_onChannelClose() {
		this.destroyed || (this._debug("on channel close"), this.destroy())
	}
	_onTrack(e) {
		this.destroyed || e.streams.forEach((t => {
			this._debug("on track"), this.emit("track", e.track, t), this._remoteTracks.push({
				track: e.track,
				stream: t
			}), this._remoteStreams.some((e => e.id === t.id)) || (this._remoteStreams.push(t), queueMicrotask((() => {
				this._debug("on stream"), this.emit("stream", t)
			})))
		}))
	}
	_debug(...e) {
		this._doDebug && (e[0] = "[" + this._id + "] " + e[0])
	}
	on(e, t) {
		const n = this._map;
		n.has(e) || n.set(e, new Set), n.get(e).add(t)
	}
	off(e, t) {
		const n = this._map,
			i = n.get(e);
		i && (i.delete(t), 0 === i.size && n.delete(e))
	}
	once(e, t) {
		const n = (...i) => {
			this.off(e, n), t(...i)
		};
		this.on(e, n)
	}
	emit(e, ...t) {
		const n = this._map;
		if (n.has(e))
			for (const r of n.get(e)) try {
				r(...t)
			} catch (i) {}
	}
}
jd.WEBRTC_SUPPORT = !!Gd(), jd.config = {
	iceServers: [{
		urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"]
	}],
	sdpSemantics: "unified-plan"
}, jd.channelConfig = {};
const Yd = !1,
	Xd = "${JSCORE_VERSION}",
	$d = function(e, t) {
		if (!e) throw Zd(t)
	},
	Zd = function(e) {
		return new Error("Firebase Database (" + Xd + ") INTERNAL ASSERT FAILED: " + e)
	},
	Kd = function(e) {
		const t = [];
		let n = 0;
		for (let i = 0; i < e.length; i++) {
			let r = e.charCodeAt(i);
			r < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = 63 & r | 128) : 55296 == (64512 & r) && i + 1 < e.length && 56320 == (64512 & e.charCodeAt(i + 1)) ? (r = 65536 + ((1023 & r) << 10) + (1023 & e.charCodeAt(++i)), t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128) : (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128)
		}
		return t
	},
	Jd = {
		byteToCharMap_: null,
		charToByteMap_: null,
		byteToCharMapWebSafe_: null,
		charToByteMapWebSafe_: null,
		ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
		get ENCODED_VALS() {
			return this.ENCODED_VALS_BASE + "+/="
		},
		get ENCODED_VALS_WEBSAFE() {
			return this.ENCODED_VALS_BASE + "-_."
		},
		HAS_NATIVE_SUPPORT: "function" == typeof atob,
		encodeByteArray(e, t) {
			if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter");
			this.init_();
			const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
				i = [];
			for (let r = 0; r < e.length; r += 3) {
				const t = e[r],
					s = r + 1 < e.length,
					a = s ? e[r + 1] : 0,
					o = r + 2 < e.length,
					l = o ? e[r + 2] : 0,
					c = t >> 2,
					u = (3 & t) << 4 | a >> 4;
				let h = (15 & a) << 2 | l >> 6,
					d = 63 & l;
				o || (d = 64, s || (h = 64)), i.push(n[c], n[u], n[h], n[d])
			}
			return i.join("")
		},
		encodeString(e, t) {
			return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(Kd(e), t)
		},
		decodeString(e, t) {
			return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function(e) {
				const t = [];
				let n = 0,
					i = 0;
				for (; n < e.length;) {
					const r = e[n++];
					if (r < 128) t[i++] = String.fromCharCode(r);
					else if (r > 191 && r < 224) {
						const s = e[n++];
						t[i++] = String.fromCharCode((31 & r) << 6 | 63 & s)
					} else if (r > 239 && r < 365) {
						const s = ((7 & r) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536;
						t[i++] = String.fromCharCode(55296 + (s >> 10)), t[i++] = String.fromCharCode(56320 + (1023 & s))
					} else {
						const s = e[n++],
							a = e[n++];
						t[i++] = String.fromCharCode((15 & r) << 12 | (63 & s) << 6 | 63 & a)
					}
				}
				return t.join("")
			}(this.decodeStringToByteArray(e, t))
		},
		decodeStringToByteArray(e, t) {
			this.init_();
			const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_,
				i = [];
			for (let r = 0; r < e.length;) {
				const t = n[e.charAt(r++)],
					s = r < e.length ? n[e.charAt(r)] : 0;
				++r;
				const a = r < e.length ? n[e.charAt(r)] : 64;
				++r;
				const o = r < e.length ? n[e.charAt(r)] : 64;
				if (++r, null == t || null == s || null == a || null == o) throw Error();
				const l = t << 2 | s >> 4;
				if (i.push(l), 64 !== a) {
					const e = s << 4 & 240 | a >> 2;
					if (i.push(e), 64 !== o) {
						const e = a << 6 & 192 | o;
						i.push(e)
					}
				}
			}
			return i
		},
		init_() {
			if (!this.byteToCharMap_) {
				this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
				for (let e = 0; e < this.ENCODED_VALS.length; e++) this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
			}
		}
	},
	Qd = function(e) {
		try {
			return Jd.decodeString(e, !0)
		} catch (t) {}
		return null
	};

function ep(e) {
	return tp(void 0, e)
}

function tp(e, t) {
	if (!(t instanceof Object)) return t;
	switch (t.constructor) {
		case Date:
			return new Date(t.getTime());
		case Object:
			void 0 === e && (e = {});
			break;
		case Array:
			e = [];
			break;
		default:
			return t
	}
	for (const n in t) t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = tp(e[n], t[n]));
	return e
}
class np {
	constructor() {
		this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise(((e, t) => {
			this.resolve = e, this.reject = t
		}))
	}
	wrapCallback(e) {
		return (t, n) => {
			t ? this.reject(t) : this.resolve(n), "function" == typeof e && (this.promise.catch((() => {})), 1 === e.length ? e(t) : e(t, n))
		}
	}
}

function ip() {
	return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test("undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "")
}

function rp() {
	return !0 === Yd
}
class sp extends Error {
	constructor(e, t, n) {
		super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, sp.prototype), Error.captureStackTrace && Error.captureStackTrace(this, ap.prototype.create)
	}
}
class ap {
	constructor(e, t, n) {
		this.service = e, this.serviceName = t, this.errors = n
	}
	create(e, ...t) {
		const n = t[0] || {},
			i = `${this.service}/${e}`,
			r = this.errors[e],
			s = r ? function(e, t) {
				return e.replace(op, ((e, n) => {
					const i = t[n];
					return null != i ? String(i) : `<${n}?>`
				}))
			}(r, n) : "Error",
			a = `${this.serviceName}: ${s} (${i}).`;
		return new sp(i, a, n)
	}
}
const op = /\{\$([^}]+)}/g;

function lp(e) {
	return JSON.parse(e)
}

function cp(e) {
	return JSON.stringify(e)
}
const up = function(e) {
	let t = {},
		n = {},
		i = {},
		r = "";
	try {
		const s = e.split(".");
		t = lp(Qd(s[0]) || ""), n = lp(Qd(s[1]) || ""), r = s[2], i = n.d || {}, delete n.d
	} catch (s) {}
	return {
		header: t,
		claims: n,
		data: i,
		signature: r
	}
};

function hp(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t)
}

function dp(e, t) {
	return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0
}

function pp(e) {
	for (const t in e)
		if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
	return !0
}

function fp(e, t, n) {
	const i = {};
	for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (i[r] = t.call(n, e[r], r, e));
	return i
}

function mp(e, t) {
	if (e === t) return !0;
	const n = Object.keys(e),
		i = Object.keys(t);
	for (const r of n) {
		if (!i.includes(r)) return !1;
		const n = e[r],
			s = t[r];
		if (gp(n) && gp(s)) {
			if (!mp(n, s)) return !1
		} else if (n !== s) return !1
	}
	for (const r of i)
		if (!n.includes(r)) return !1;
	return !0
}

function gp(e) {
	return null !== e && "object" == typeof e
}
class vp {
	constructor() {
		this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128;
		for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0;
		this.reset()
	}
	reset() {
		this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0
	}
	compress_(e, t) {
		t || (t = 0);
		const n = this.W_;
		if ("string" == typeof e)
			for (let u = 0; u < 16; u++) n[u] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3), t += 4;
		else
			for (let u = 0; u < 16; u++) n[u] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3], t += 4;
		for (let u = 16; u < 80; u++) {
			const e = n[u - 3] ^ n[u - 8] ^ n[u - 14] ^ n[u - 16];
			n[u] = 4294967295 & (e << 1 | e >>> 31)
		}
		let i, r, s = this.chain_[0],
			a = this.chain_[1],
			o = this.chain_[2],
			l = this.chain_[3],
			c = this.chain_[4];
		for (let u = 0; u < 80; u++) {
			u < 40 ? u < 20 ? (i = l ^ a & (o ^ l), r = 1518500249) : (i = a ^ o ^ l, r = 1859775393) : u < 60 ? (i = a & o | l & (a | o), r = 2400959708) : (i = a ^ o ^ l, r = 3395469782);
			const e = (s << 5 | s >>> 27) + i + c + r + n[u] & 4294967295;
			c = l, l = o, o = 4294967295 & (a << 30 | a >>> 2), a = s, s = e
		}
		this.chain_[0] = this.chain_[0] + s & 4294967295, this.chain_[1] = this.chain_[1] + a & 4294967295, this.chain_[2] = this.chain_[2] + o & 4294967295, this.chain_[3] = this.chain_[3] + l & 4294967295, this.chain_[4] = this.chain_[4] + c & 4294967295
	}
	update(e, t) {
		if (null == e) return;
		void 0 === t && (t = e.length);
		const n = t - this.blockSize;
		let i = 0;
		const r = this.buf_;
		let s = this.inbuf_;
		for (; i < t;) {
			if (0 === s)
				for (; i <= n;) this.compress_(e, i), i += this.blockSize;
			if ("string" == typeof e) {
				for (; i < t;)
					if (r[s] = e.charCodeAt(i), ++s, ++i, s === this.blockSize) {
						this.compress_(r), s = 0;
						break
					}
			} else
				for (; i < t;)
					if (r[s] = e[i], ++s, ++i, s === this.blockSize) {
						this.compress_(r), s = 0;
						break
					}
		}
		this.inbuf_ = s, this.total_ += t
	}
	digest() {
		const e = [];
		let t = 8 * this.total_;
		this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
		for (let i = this.blockSize - 1; i >= 56; i--) this.buf_[i] = 255 & t, t /= 256;
		this.compress_(this.buf_);
		let n = 0;
		for (let i = 0; i < 5; i++)
			for (let t = 24; t >= 0; t -= 8) e[n] = this.chain_[i] >> t & 255, ++n;
		return e
	}
}

function _p(e, t) {
	return `${e} failed: ${t} argument `
}
const yp = function(e) {
	let t = 0;
	for (let n = 0; n < e.length; n++) {
		const i = e.charCodeAt(n);
		i < 128 ? t++ : i < 2048 ? t += 2 : i >= 55296 && i <= 56319 ? (t += 4, n++) : t += 3
	}
	return t
};

function xp(e) {
	return e && e._delegate ? e._delegate : e
}
class bp {
	constructor(e, t, n) {
		this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
	}
	setInstantiationMode(e) {
		return this.instantiationMode = e, this
	}
	setMultipleInstances(e) {
		return this.multipleInstances = e, this
	}
	setServiceProps(e) {
		return this.serviceProps = e, this
	}
	setInstanceCreatedCallback(e) {
		return this.onInstanceCreated = e, this
	}
}
class wp {
	constructor(e, t) {
		this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
	}
	get(e) {
		const t = this.normalizeInstanceIdentifier(e);
		if (!this.instancesDeferred.has(t)) {
			const e = new np;
			if (this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()) try {
				const n = this.getOrInitializeService({
					instanceIdentifier: t
				});
				n && e.resolve(n)
			} catch (n) {}
		}
		return this.instancesDeferred.get(t).promise
	}
	getImmediate(e) {
		var t;
		const n = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier),
			i = null !== (t = null == e ? void 0 : e.optional) && void 0 !== t && t;
		if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
			if (i) return null;
			throw Error(`Service ${this.name} is not available`)
		}
		try {
			return this.getOrInitializeService({
				instanceIdentifier: n
			})
		} catch (r) {
			if (i) return null;
			throw r
		}
	}
	getComponent() {
		return this.component
	}
	setComponent(e) {
		if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
		if (this.component) throw Error(`Component for ${this.name} has already been provided`);
		if (this.component = e, this.shouldAutoInitialize()) {
			if (function(e) {
					return "EAGER" === e.instantiationMode
				}(e)) try {
				this.getOrInitializeService({
					instanceIdentifier: "[DEFAULT]"
				})
			} catch (t) {}
			for (const [e, n] of this.instancesDeferred.entries()) {
				const i = this.normalizeInstanceIdentifier(e);
				try {
					const e = this.getOrInitializeService({
						instanceIdentifier: i
					});
					n.resolve(e)
				} catch (t) {}
			}
		}
	}
	clearInstance(e = "[DEFAULT]") {
		this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
	}
	async delete() {
		const e = Array.from(this.instances.values());
		await Promise.all([...e.filter((e => "INTERNAL" in e)).map((e => e.INTERNAL.delete())), ...e.filter((e => "_delete" in e)).map((e => e._delete()))])
	}
	isComponentSet() {
		return null != this.component
	}
	isInitialized(e = "[DEFAULT]") {
		return this.instances.has(e)
	}
	getOptions(e = "[DEFAULT]") {
		return this.instancesOptions.get(e) || {}
	}
	initialize(e = {}) {
		const {
			options: t = {}
		} = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier);
		if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`);
		if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
		const i = this.getOrInitializeService({
			instanceIdentifier: n,
			options: t
		});
		for (const [r, s] of this.instancesDeferred.entries()) {
			n === this.normalizeInstanceIdentifier(r) && s.resolve(i)
		}
		return i
	}
	onInit(e, t) {
		var n;
		const i = this.normalizeInstanceIdentifier(t),
			r = null !== (n = this.onInitCallbacks.get(i)) && void 0 !== n ? n : new Set;
		r.add(e), this.onInitCallbacks.set(i, r);
		const s = this.instances.get(i);
		return s && e(s, i), () => {
			r.delete(e)
		}
	}
	invokeOnInitCallbacks(e, t) {
		const n = this.onInitCallbacks.get(t);
		if (n)
			for (const r of n) try {
				r(e, t)
			} catch (i) {}
	}
	getOrInitializeService({
		instanceIdentifier: e,
		options: t = {}
	}) {
		let n = this.instances.get(e);
		if (!n && this.component && (n = this.component.instanceFactory(this.container, {
				instanceIdentifier: (i = e, "[DEFAULT]" === i ? void 0 : i),
				options: t
			}), this.instances.set(e, n), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated)) try {
			this.component.onInstanceCreated(this.container, e, n)
		} catch (r) {}
		var i;
		return n || null
	}
	normalizeInstanceIdentifier(e = "[DEFAULT]") {
		return this.component ? this.component.multipleInstances ? e : "[DEFAULT]" : e
	}
	shouldAutoInitialize() {
		return !!this.component && "EXPLICIT" !== this.component.instantiationMode
	}
}
class Sp {
	constructor(e) {
		this.name = e, this.providers = new Map
	}
	addComponent(e) {
		const t = this.getProvider(e.name);
		if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
		t.setComponent(e)
	}
	addOrOverwriteComponent(e) {
		this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
	}
	getProvider(e) {
		if (this.providers.has(e)) return this.providers.get(e);
		const t = new wp(e, this);
		return this.providers.set(e, t), t
	}
	getProviders() {
		return Array.from(this.providers.values())
	}
}
var Mp, Tp;
(Tp = Mp || (Mp = {}))[Tp.false = 0] = "false", Tp[Tp.VERBOSE = 1] = "VERBOSE", Tp[Tp.INFO = 2] = "INFO", Tp[Tp.WARN = 3] = "WARN", Tp[Tp.ERROR = 4] = "ERROR", Tp[Tp.SILENT = 5] = "SILENT";
const Cp = {
		debug: Mp.DEBUG,
		verbose: Mp.VERBOSE,
		info: Mp.INFO,
		warn: Mp.WARN,
		error: Mp.ERROR,
		silent: Mp.SILENT
	},
	Ep = Mp.INFO,
	Ap = {
		[Mp.DEBUG]: "log",
		[Mp.VERBOSE]: "log",
		[Mp.INFO]: "info",
		[Mp.WARN]: "warn",
		[Mp.ERROR]: "error"
	},
	Pp = (e, t, ...n) => {
		if (t < e.logLevel) return;
		(new Date).toISOString();
		if (!Ap[t]) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`)
	};
class Lp {
	constructor(e) {
		this.name = e, this._logLevel = Ep, this._logHandler = Pp, this._userLogHandler = null
	}
	get logLevel() {
		return this._logLevel
	}
	set logLevel(e) {
		if (!(e in Mp)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
		this._logLevel = e
	}
	setLogLevel(e) {
		this._logLevel = "string" == typeof e ? Cp[e] : e
	}
	get logHandler() {
		return this._logHandler
	}
	set logHandler(e) {
		if ("function" != typeof e) throw new TypeError("Value assigned to `logHandler` must be a function");
		this._logHandler = e
	}
	get userLogHandler() {
		return this._userLogHandler
	}
	set userLogHandler(e) {
		this._userLogHandler = e
	}
	debug(...e) {
		this._userLogHandler && this._userLogHandler(this, Mp.DEBUG, ...e), this._logHandler(this, Mp.DEBUG, ...e)
	}
	log(...e) {
		this._userLogHandler && this._userLogHandler(this, Mp.VERBOSE, ...e), this._logHandler(this, Mp.VERBOSE, ...e)
	}
	info(...e) {
		this._userLogHandler && this._userLogHandler(this, Mp.INFO, ...e), this._logHandler(this, Mp.INFO, ...e)
	}
	warn(...e) {
		this._userLogHandler && this._userLogHandler(this, Mp.WARN, ...e), this._logHandler(this, Mp.WARN, ...e)
	}
	error(...e) {
		this._userLogHandler && this._userLogHandler(this, Mp.ERROR, ...e), this._logHandler(this, Mp.ERROR, ...e)
	}
}
class Ip {
	constructor(e) {
		this.container = e
	}
	getPlatformInfoString() {
		return this.container.getProviders().map((e => {
			if (function(e) {
					const t = e.getComponent();
					return "VERSION" === (null == t ? void 0 : t.type)
				}(e)) {
				const t = e.getImmediate();
				return `${t.library}/${t.version}`
			}
			return null
		})).filter((e => e)).join(" ")
	}
}
const Dp = "@firebase/app",
	Rp = new Lp("@firebase/app"),
	kp = {
		[Dp]: "fire-core",
		"@firebase/app-compat": "fire-core-compat",
		"@firebase/analytics": "fire-analytics",
		"@firebase/analytics-compat": "fire-analytics-compat",
		"@firebase/app-check": "fire-app-check",
		"@firebase/app-check-compat": "fire-app-check-compat",
		"@firebase/auth": "fire-auth",
		"@firebase/auth-compat": "fire-auth-compat",
		"@firebase/database": "fire-rtdb",
		"@firebase/database-compat": "fire-rtdb-compat",
		"@firebase/functions": "fire-fn",
		"@firebase/functions-compat": "fire-fn-compat",
		"@firebase/installations": "fire-iid",
		"@firebase/installations-compat": "fire-iid-compat",
		"@firebase/messaging": "fire-fcm",
		"@firebase/messaging-compat": "fire-fcm-compat",
		"@firebase/performance": "fire-perf",
		"@firebase/performance-compat": "fire-perf-compat",
		"@firebase/remote-config": "fire-rc",
		"@firebase/remote-config-compat": "fire-rc-compat",
		"@firebase/storage": "fire-gcs",
		"@firebase/storage-compat": "fire-gcs-compat",
		"@firebase/firestore": "fire-fst",
		"@firebase/firestore-compat": "fire-fst-compat",
		"fire-js": "fire-js",
		firebase: "fire-js-all"
	},
	Np = new Map,
	Op = new Map;

function Fp(e, t) {
	try {
		e.container.addComponent(t)
	} catch (n) {
		Rp.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n)
	}
}

function zp(e) {
	const t = e.name;
	if (Op.has(t)) return Rp.debug(`There were multiple attempts to register component ${t}.`), !1;
	Op.set(t, e);
	for (const n of Np.values()) Fp(n, e);
	return !0
}
const Up = new ap("app", "Firebase", {
	"no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
	"bad-app-name": "Illegal App name: '{$appName}",
	"duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
	"app-deleted": "Firebase App named '{$appName}' already deleted",
	"invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
	"invalid-log-argument": "First argument to `onLog` must be null or a function."
});
class Bp {
	constructor(e, t, n) {
		this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new bp("app", (() => this), "PUBLIC"))
	}
	get automaticDataCollectionEnabled() {
		return this.checkDestroyed(), this._automaticDataCollectionEnabled
	}
	set automaticDataCollectionEnabled(e) {
		this.checkDestroyed(), this._automaticDataCollectionEnabled = e
	}
	get name() {
		return this.checkDestroyed(), this._name
	}
	get options() {
		return this.checkDestroyed(), this._options
	}
	get config() {
		return this.checkDestroyed(), this._config
	}
	get container() {
		return this._container
	}
	get isDeleted() {
		return this._isDeleted
	}
	set isDeleted(e) {
		this._isDeleted = e
	}
	checkDestroyed() {
		if (this.isDeleted) throw Up.create("app-deleted", {
			appName: this._name
		})
	}
}

function Vp(e, t, n) {
	var i;
	let r = null !== (i = kp[e]) && void 0 !== i ? i : e;
	n && (r += `-${n}`);
	const s = r.match(/\s|\//),
		a = t.match(/\s|\//);
	if (s || a) {
		const e = [`Unable to register library "${r}" with version "${t}":`];
		return s && e.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && a && e.push("and"), a && e.push(`version name "${t}" contains illegal characters (whitespace or "/")`), void Rp.warn(e.join(" "))
	}
	zp(new bp(`${r}-version`, (() => ({
		library: r,
		version: t
	})), "VERSION"))
}
var Hp;
Hp = "", zp(new bp("platform-logger", (e => new Ip(e)), "PRIVATE")), Vp(Dp, "0.7.8", Hp), Vp(Dp, "0.7.8", "esm2017"), Vp("fire-js", "");

function Gp(e, t, n, i) {
	this.fn = t, this.ctx = n || null, this.owner = e, this.once = !!i
}

function Wp(e, t) {
	t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.ctx = t.fn = t.owner = null, t === e._first && (e._first = t.next), t === e._last && (e._last = t.prev)
}
Vp("firebase", "9.4.1", "app");
class qp {
	constructor() {
		this._first = this._last = null, this._isStoreSignal = !0
	}
	emit(e, t, n) {
		let i = this._first;
		for (; i;) i.fn.call(i.ctx, e, t, n), i.once && this.unwatch(i), i = i.next
	}
	watch(e, t, n) {
		const i = new Gp(this, e, t, n);
		return this._first ? (this._last.next = i, i.prev = this._last, this._last = i) : (this._first = i, this._last = i), i
	}
	watchOnce(e, t) {
		return this.watch(e, t, !0)
	}
	unwatch(e, t) {
		if (e instanceof Gp) return Wp(this, e);
		t || (t = null);
		let n = this._first;
		for (; n;) n.fn === e && n.ctx === t && Wp(this, n), n = n.next
	}
	unwatchAll() {
		let e = this._first;
		for (this._first = this._last = null; e;) Wp(this, e), e = e.next
	}
}

function jp() {
	return new qp
}
class Yp extends qp {
	constructor(e) {
		super(), this.value = e
	}
	get() {
		return this.value
	}
	watchImmediate(e, t) {
		const n = this.watch(e, t);
		return e.call(t, this.value, this.previous), n
	}
}
const Xp = new Set,
	$p = {
		stack: Xp,
		held: !1,
		holdEmits: Zp,
		releaseEmits: Kp,
		batchUpdates: function(e) {
			return function(t, n, i) {
				Zp(), e(t, n, i), Kp()
			}
		}
	};

function Zp() {
	$p.held = !0
}

function Kp() {
	$p.held = !1, Xp.forEach(Jp), Xp.clear()
}

function Jp(e) {
	e._emit()
}
class Qp extends Yp {
	set(e, t) {
		if (t || this.value !== e) {
			if (this.previous = this.value, this.value = e, $p.held) return $p.stack.add(this);
			this._emit()
		}
	}
	_emit() {
		let e = this._first;
		for (; e;) e.fn.call(e.ctx, this.value, this.previous), e.once && this.unwatch(e), e = e.next;
		this.previous = null
	}
	update(e, t) {
		const n = e(this.value);
		this.set(void 0 !== n ? n : this.value, t)
	}
}

function ef(e) {
	return new Qp(e)
}

function tf(e, t, n = {}) {
	if (!e._isStoreSignal || !t) return;
	const i = n.session ? sessionStorage : localStorage,
		r = n.type,
		s = n.boolean || r === Boolean,
		a = n.number || r === Number;
	let o = i.getItem(t);
	return null == o ? o = e.value : s ? o = !!+o : a && (o = isNaN(+o) ? 0 : +o), e.value = o, e.watch((e => {
		let n = e;
		s ? n = n ? 1 : 0 : a && (n = isNaN(+n) ? 0 : +n), i.setItem(t, n)
	})), e
}
const nf = $p.holdEmits,
	rf = $p.releaseEmits,
	sf = "@firebase/database";
let af = "";
class of {
	constructor(e) {
		this.domStorage_ = e, this.prefix_ = "firebase:"
	}
	set(e, t) {
		null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), cp(t))
	}
	get(e) {
		const t = this.domStorage_.getItem(this.prefixedName_(e));
		return null == t ? null : lp(t)
	}
	remove(e) {
		this.domStorage_.removeItem(this.prefixedName_(e))
	}
	prefixedName_(e) {
		return this.prefix_ + e
	}
	toString() {
		return this.domStorage_.toString()
	}
}
class lf {
	constructor() {
		this.cache_ = {}, this.isInMemoryStorage = !0
	}
	set(e, t) {
		null == t ? delete this.cache_[e] : this.cache_[e] = t
	}
	get(e) {
		return hp(this.cache_, e) ? this.cache_[e] : null
	}
	remove(e) {
		delete this.cache_[e]
	}
}
const cf = function(e) {
		try {
			if ("undefined" != typeof window && void 0 !== window[e]) {
				const t = window[e];
				return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new of (t)
			}
		} catch (t) {}
		return new lf
	},
	uf = cf("localStorage"),
	hf = cf("sessionStorage"),
	df = new Lp("@firebase/database"),
	pf = function() {
		let e = 1;
		return function() {
			return e++
		}
	}(),
	ff = function(e) {
		const t = function(e) {
				const t = [];
				let n = 0;
				for (let i = 0; i < e.length; i++) {
					let r = e.charCodeAt(i);
					if (r >= 55296 && r <= 56319) {
						const t = r - 55296;
						i++, $d(i < e.length, "Surrogate pair missing trail surrogate."), r = 65536 + (t << 10) + (e.charCodeAt(i) - 56320)
					}
					r < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = 63 & r | 128) : r < 65536 ? (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128) : (t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128)
				}
				return t
			}(e),
			n = new vp;
		n.update(t);
		const i = n.digest();
		return Jd.encodeByteArray(i)
	},
	mf = function(...e) {
		let t = "";
		for (let n = 0; n < e.length; n++) {
			const i = e[n];
			Array.isArray(i) || i && "object" == typeof i && "number" == typeof i.length ? t += mf.apply(null, i) : t += "object" == typeof i ? cp(i) : i, t += " "
		}
		return t
	};
let gf = null,
	vf = !0;
const _f = function(...e) {
		var t, n;
		if (!0 === vf && (vf = !1, null === gf && !0 === hf.get("logging_enabled") && (t = !0, $d(!n || !0 === t || !1 === t, "Can't turn on custom loggers persistently."), !0 === t ? (df.logLevel = Mp.VERBOSE, gf = df.log.bind(df), n && hf.set("logging_enabled", !0)) : "function" == typeof t ? gf = t : (gf = null, hf.remove("logging_enabled")))), gf) {
			const t = mf.apply(null, e);
			gf(t)
		}
	},
	yf = function(e) {
		return function(...t) {
			_f(e, ...t)
		}
	},
	xf = function(...e) {
		const t = "FIREBASE INTERNAL ERROR: " + mf(...e);
		df.error(t)
	},
	bf = function(...e) {
		const t = `FIREBASE FATAL ERROR: ${mf(...e)}`;
		throw df.error(t), new Error(t)
	},
	wf = function(...e) {
		const t = "FIREBASE WARNING: " + mf(...e);
		df.warn(t)
	},
	Sf = function(e) {
		return "number" == typeof e && (e != e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY)
	},
	Mf = "[MIN_NAME]",
	Tf = "[MAX_NAME]",
	Cf = function(e, t) {
		if (e === t) return 0;
		if (e === Mf || t === Tf) return -1;
		if (t === Mf || e === Tf) return 1; {
			const n = kf(e),
				i = kf(t);
			return null !== n ? null !== i ? n - i == 0 ? e.length - t.length : n - i : -1 : null !== i ? 1 : e < t ? -1 : 1
		}
	},
	Ef = function(e, t) {
		return e === t ? 0 : e < t ? -1 : 1
	},
	Af = function(e, t) {
		if (t && e in t) return t[e];
		throw new Error("Missing required key (" + e + ") in object: " + cp(t))
	},
	Pf = function(e) {
		if ("object" != typeof e || null === e) return cp(e);
		const t = [];
		for (const i in e) t.push(i);
		t.sort();
		let n = "{";
		for (let i = 0; i < t.length; i++) 0 !== i && (n += ","), n += cp(t[i]), n += ":", n += Pf(e[t[i]]);
		return n += "}", n
	},
	Lf = function(e, t) {
		const n = e.length;
		if (n <= t) return [e];
		const i = [];
		for (let r = 0; r < n; r += t) r + t > n ? i.push(e.substring(r, n)) : i.push(e.substring(r, r + t));
		return i
	};

function If(e, t) {
	for (const n in e) e.hasOwnProperty(n) && t(n, e[n])
}
const Df = function(e) {
	$d(!Sf(e), "Invalid JSON number");
	const t = 1023;
	let n, i, r, s, a;
	0 === e ? (i = 0, r = 0, n = 1 / e == -Infinity ? 1 : 0) : (n = e < 0, (e = Math.abs(e)) >= Math.pow(2, -1022) ? (s = Math.min(Math.floor(Math.log(e) / Math.LN2), t), i = s + t, r = Math.round(e * Math.pow(2, 52 - s) - Math.pow(2, 52))) : (i = 0, r = Math.round(e / Math.pow(2, -1074))));
	const o = [];
	for (a = 52; a; a -= 1) o.push(r % 2 ? 1 : 0), r = Math.floor(r / 2);
	for (a = 11; a; a -= 1) o.push(i % 2 ? 1 : 0), i = Math.floor(i / 2);
	o.push(n ? 1 : 0), o.reverse();
	const l = o.join("");
	let c = "";
	for (a = 0; a < 64; a += 8) {
		let e = parseInt(l.substr(a, 8), 2).toString(16);
		1 === e.length && (e = "0" + e), c += e
	}
	return c.toLowerCase()
};
const Rf = new RegExp("^-?(0*)\\d{1,10}$"),
	kf = function(e) {
		if (Rf.test(e)) {
			const t = Number(e);
			if (t >= -2147483648 && t <= 2147483647) return t
		}
		return null
	},
	Nf = function(e) {
		try {
			e()
		} catch (t) {
			setTimeout((() => {
				const e = t.stack || "";
				throw wf("Exception was thrown by user callback.", e), t
			}), Math.floor(0))
		}
	},
	Of = function(e, t) {
		const n = setTimeout(e, t);
		return "object" == typeof n && n.unref && n.unref(), n
	};
class Ff {
	constructor(e, t) {
		this.appName_ = e, this.appCheckProvider = t, this.appCheck = null == t ? void 0 : t.getImmediate({
			optional: !0
		}), this.appCheck || null == t || t.get().then((e => this.appCheck = e))
	}
	getToken(e) {
		return this.appCheck ? this.appCheck.getToken(e) : new Promise(((t, n) => {
			setTimeout((() => {
				this.appCheck ? this.getToken(e).then(t, n) : t(null)
			}), 0)
		}))
	}
	addTokenChangeListener(e) {
		var t;
		null === (t = this.appCheckProvider) || void 0 === t || t.get().then((t => t.addTokenListener(e)))
	}
	notifyForInvalidToken() {
		wf(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`)
	}
}
class zf {
	constructor(e, t, n) {
		this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = n, this.auth_ = null, this.auth_ = n.getImmediate({
			optional: !0
		}), this.auth_ || n.onInit((e => this.auth_ = e))
	}
	getToken(e) {
		return this.auth_ ? this.auth_.getToken(e).catch((e => e && "auth/token-not-initialized" === e.code ? (_f("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(e))) : new Promise(((t, n) => {
			setTimeout((() => {
				this.auth_ ? this.getToken(e).then(t, n) : t(null)
			}), 0)
		}))
	}
	addTokenChangeListener(e) {
		this.auth_ ? this.auth_.addAuthTokenListener(e) : this.authProvider_.get().then((t => t.addAuthTokenListener(e)))
	}
	removeTokenChangeListener(e) {
		this.authProvider_.get().then((t => t.removeAuthTokenListener(e)))
	}
	notifyForInvalidToken() {
		let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
		"credential" in this.firebaseOptions_ ? e += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? e += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : e += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', wf(e)
	}
}
class Uf {
	constructor(e) {
		this.accessToken = e
	}
	getToken(e) {
		return Promise.resolve({
			accessToken: this.accessToken
		})
	}
	addTokenChangeListener(e) {
		e(this.accessToken)
	}
	removeTokenChangeListener(e) {}
	notifyForInvalidToken() {}
}
Uf.OWNER = "owner";
const Bf = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
class Vf {
	constructor(e, t, n, i, r = !1, s = "", a = !1) {
		this.secure = t, this.namespace = n, this.webSocketOnly = i, this.nodeAdmin = r, this.persistenceKey = s, this.includeNamespaceInQueryParams = a, this._host = e.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = uf.get("host:" + e) || this._host
	}
	isCacheableHost() {
		return "s-" === this.internalHost.substr(0, 2)
	}
	isCustomHost() {
		return "firebaseio.com" !== this._domain && "firebaseio-demo.com" !== this._domain
	}
	get host() {
		return this._host
	}
	set host(e) {
		e !== this.internalHost && (this.internalHost = e, this.isCacheableHost() && uf.set("host:" + this._host, this.internalHost))
	}
	toString() {
		let e = this.toURLString();
		return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e
	}
	toURLString() {
		const e = this.secure ? "https://" : "http://",
			t = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
		return `${e}${this.host}/${t}`
	}
}

function Hf(e, t, n) {
	let i;
	if ($d("string" == typeof t, "typeof type must == string"), $d("object" == typeof n, "typeof params must == object"), "websocket" === t) i = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?";
	else {
		if ("long_polling" !== t) throw new Error("Unknown connection type: " + t);
		i = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?"
	}(function(e) {
		return e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams
	})(e) && (n.ns = e.namespace);
	const r = [];
	return If(n, ((e, t) => {
		r.push(e + "=" + t)
	})), i + r.join("&")
}
class Gf {
	constructor() {
		this.counters_ = {}
	}
	incrementCounter(e, t = 1) {
		hp(this.counters_, e) || (this.counters_[e] = 0), this.counters_[e] += t
	}
	get() {
		return ep(this.counters_)
	}
}
const Wf = {},
	qf = {};

function jf(e) {
	const t = e.toString();
	return Wf[t] || (Wf[t] = new Gf), Wf[t]
}
class Yf {
	constructor(e) {
		this.onMessage_ = e, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null
	}
	closeAfter(e, t) {
		this.closeAfterResponse = e, this.onClose = t, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null)
	}
	handleResponse(e, t) {
		for (this.pendingResponses[e] = t; this.pendingResponses[this.currentResponseNum];) {
			const e = this.pendingResponses[this.currentResponseNum];
			delete this.pendingResponses[this.currentResponseNum];
			for (let t = 0; t < e.length; ++t) e[t] && Nf((() => {
				this.onMessage_(e[t])
			}));
			if (this.currentResponseNum === this.closeAfterResponse) {
				this.onClose && (this.onClose(), this.onClose = null);
				break
			}
			this.currentResponseNum++
		}
	}
}
class Xf {
	constructor(e, t, n, i, r, s, a) {
		this.connId = e, this.repoInfo = t, this.applicationId = n, this.appCheckToken = i, this.authToken = r, this.transportSessionId = s, this.lastSessionId = a, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = yf(e), this.stats_ = jf(t), this.urlFn = e => (this.appCheckToken && (e.ac = this.appCheckToken), Hf(t, "long_polling", e))
	}
	open(e, t) {
		this.curSegmentNum = 0, this.onDisconnect_ = t, this.myPacketOrderer = new Yf(e), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout((() => {
				this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null
			}), Math.floor(3e4)),
			function(e) {
				if ("complete" === document.readyState) e();
				else {
					let t = !1;
					const n = function() {
						document.body ? t || (t = !0, e()) : setTimeout(n, Math.floor(10))
					};
					document.addEventListener ? (document.addEventListener("DOMContentLoaded", n, !1), window.addEventListener("load", n, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", (() => {
						"complete" === document.readyState && n()
					})), window.attachEvent("onload", n))
				}
			}((() => {
				if (this.isClosed_) return;
				this.scriptTagHolder = new $f(((...e) => {
					const [t, n, i, r, s] = e;
					if (this.incrementIncomingBytes_(e), this.scriptTagHolder)
						if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, "start" === t) this.id = n, this.password = i;
						else {
							if ("close" !== t) throw new Error("Unrecognized command received: " + t);
							n ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(n, (() => {
								this.onClosed_()
							}))) : this.onClosed_()
						}
				}), ((...e) => {
					const [t, n] = e;
					this.incrementIncomingBytes_(e), this.myPacketOrderer.handleResponse(t, n)
				}), (() => {
					this.onClosed_()
				}), this.urlFn);
				const e = {
					start: "t"
				};
				e.ser = Math.floor(1e8 * Math.random()), this.scriptTagHolder.uniqueCallbackIdentifier && (e.cb = this.scriptTagHolder.uniqueCallbackIdentifier), e.v = "5", this.transportSessionId && (e.s = this.transportSessionId), this.lastSessionId && (e.ls = this.lastSessionId), this.applicationId && (e.p = this.applicationId), this.appCheckToken && (e.ac = this.appCheckToken), "undefined" != typeof location && location.hostname && Bf.test(location.hostname) && (e.r = "f");
				const t = this.urlFn(e);
				this.log_("Connecting via long-poll to " + t), this.scriptTagHolder.addTag(t, (() => {}))
			}))
	}
	start() {
		this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password)
	}
	static forceAllow() {
		Xf.forceAllow_ = !0
	}
	static forceDisallow() {
		Xf.forceDisallow_ = !0
	}
	static isAvailable() {
		return !!Xf.forceAllow_ || !(Xf.forceDisallow_ || "undefined" == typeof document || null == document.createElement || "object" == typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href) || "object" == typeof Windows && "object" == typeof Windows.UI)
	}
	markConnectionHealthy() {}
	shutdown_() {
		this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null)
	}
	onClosed_() {
		this.isClosed_ || (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null))
	}
	close() {
		this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_())
	}
	send(e) {
		const t = cp(e);
		this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
		const n = function(e) {
				const t = Kd(e);
				return Jd.encodeByteArray(t, !0)
			}(t),
			i = Lf(n, 1840);
		for (let r = 0; r < i.length; r++) this.scriptTagHolder.enqueueSegment(this.curSegmentNum, i.length, i[r]), this.curSegmentNum++
	}
	addDisconnectPingFrame(e, t) {
		this.myDisconnFrame = document.createElement("iframe");
		const n = {
			dframe: "t"
		};
		n.id = e, n.pw = t, this.myDisconnFrame.src = this.urlFn(n), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame)
	}
	incrementIncomingBytes_(e) {
		const t = cp(e).length;
		this.bytesReceived += t, this.stats_.incrementCounter("bytes_received", t)
	}
}
class $f {
	constructor(e, t, n, i) {
		this.onDisconnect = n, this.urlFn = i, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(1e8 * Math.random()), this.sendNewPolls = !0; {
			this.uniqueCallbackIdentifier = pf(), window["pLPCommand" + this.uniqueCallbackIdentifier] = e, window["pRTLPCB" + this.uniqueCallbackIdentifier] = t, this.myIFrame = $f.createIFrame_();
			let n = "";
			if (this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, "javascript:".length)) {
				n = '<script>document.domain="' + document.domain + '";<\/script>'
			}
			const i = "<html><body>" + n + "</body></html>";
			try {
				this.myIFrame.doc.open(), this.myIFrame.doc.write(i), this.myIFrame.doc.close()
			} catch (r) {
				_f("frame writing exception"), r.stack && _f(r.stack), _f(r)
			}
		}
	}
	static createIFrame_() {
		const e = document.createElement("iframe");
		if (e.style.display = "none", !document.body) throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
		document.body.appendChild(e);
		try {
			e.contentWindow.document || _f("No IE domain setting required")
		} catch (t) {
			const n = document.domain;
			e.src = "javascript:void((function(){document.open();document.domain='" + n + "';document.close();})())"
		}
		return e.contentDocument ? e.doc = e.contentDocument : e.contentWindow ? e.doc = e.contentWindow.document : e.document && (e.doc = e.document), e
	}
	close() {
		this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.innerHTML = "", setTimeout((() => {
			null !== this.myIFrame && (document.body.removeChild(this.myIFrame), this.myIFrame = null)
		}), Math.floor(0)));
		const e = this.onDisconnect;
		e && (this.onDisconnect = null, e())
	}
	startLongPoll(e, t) {
		for (this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_(););
	}
	newRequest_() {
		if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
			this.currentSerial++;
			const e = {};
			e.id = this.myID, e.pw = this.myPW, e.ser = this.currentSerial;
			let t = this.urlFn(e),
				n = "",
				i = 0;
			for (; this.pendingSegs.length > 0;) {
				if (!(this.pendingSegs[0].d.length + 30 + n.length <= 1870)) break; {
					const e = this.pendingSegs.shift();
					n = n + "&seg" + i + "=" + e.seg + "&ts" + i + "=" + e.ts + "&d" + i + "=" + e.d, i++
				}
			}
			return t += n, this.addLongPollTag_(t, this.currentSerial), !0
		}
		return !1
	}
	enqueueSegment(e, t, n) {
		this.pendingSegs.push({
			seg: e,
			ts: t,
			d: n
		}), this.alive && this.newRequest_()
	}
	addLongPollTag_(e, t) {
		this.outstandingRequests.add(t);
		const n = () => {
				this.outstandingRequests.delete(t), this.newRequest_()
			},
			i = setTimeout(n, Math.floor(25e3));
		this.addTag(e, (() => {
			clearTimeout(i), n()
		}))
	}
	addTag(e, t) {
		setTimeout((() => {
			try {
				if (!this.sendNewPolls) return;
				const n = this.myIFrame.doc.createElement("script");
				n.type = "text/javascript", n.async = !0, n.src = e, n.onload = n.onreadystatechange = function() {
					const e = n.readyState;
					e && "loaded" !== e && "complete" !== e || (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), t())
				}, n.onerror = () => {
					_f("Long-poll script failed to load: " + e), this.sendNewPolls = !1, this.close()
				}, this.myIFrame.doc.body.appendChild(n)
			} catch (n) {}
		}), Math.floor(1))
	}
}
let Zf = null;
"undefined" != typeof MozWebSocket ? Zf = MozWebSocket : "undefined" != typeof WebSocket && (Zf = WebSocket);
class Kf {
	constructor(e, t, n, i, r, s, a) {
		this.connId = e, this.applicationId = n, this.appCheckToken = i, this.authToken = r, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = yf(this.connId), this.stats_ = jf(t), this.connURL = Kf.connectionURL_(t, s, a, i), this.nodeAdmin = t.nodeAdmin
	}
	static connectionURL_(e, t, n, i) {
		const r = {
			v: "5"
		};
		return "undefined" != typeof location && location.hostname && Bf.test(location.hostname) && (r.r = "f"), t && (r.s = t), n && (r.ls = n), i && (r.ac = i), Hf(e, "websocket", r)
	}
	open(e, t) {
		this.onDisconnect = t, this.onMessage = e, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, uf.set("previous_websocket_failure", !0);
		try {
			if (rp());
			else {
				const e = {
					headers: {
						"X-Firebase-GMPID": this.applicationId || "",
						"X-Firebase-AppCheck": this.appCheckToken || ""
					}
				};
				this.mySock = new Zf(this.connURL, [], e)
			}
		} catch (n) {
			this.log_("Error instantiating WebSocket.");
			const e = n.message || n.data;
			return e && this.log_(e), void this.onClosed_()
		}
		this.mySock.onopen = () => {
			this.log_("Websocket connected."), this.everConnected_ = !0
		}, this.mySock.onclose = () => {
			this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_()
		}, this.mySock.onmessage = e => {
			this.handleIncomingFrame(e)
		}, this.mySock.onerror = e => {
			this.log_("WebSocket error.  Closing connection.");
			const t = e.message || e.data;
			t && this.log_(t), this.onClosed_()
		}
	}
	start() {}
	static forceDisallow() {
		Kf.forceDisallow_ = !0
	}
	static isAvailable() {
		let e = !1;
		if ("undefined" != typeof navigator && navigator.userAgent) {
			const t = /Android ([0-9]{0,}\.[0-9]{0,})/,
				n = navigator.userAgent.match(t);
			n && n.length > 1 && parseFloat(n[1]) < 4.4 && (e = !0)
		}
		return !e && null !== Zf && !Kf.forceDisallow_
	}
	static previouslyFailed() {
		return uf.isInMemoryStorage || !0 === uf.get("previous_websocket_failure")
	}
	markConnectionHealthy() {
		uf.remove("previous_websocket_failure")
	}
	appendFrame_(e) {
		if (this.frames.push(e), this.frames.length === this.totalFrames) {
			const e = this.frames.join("");
			this.frames = null;
			const t = lp(e);
			this.onMessage(t)
		}
	}
	handleNewFrameCount_(e) {
		this.totalFrames = e, this.frames = []
	}
	extractFrameCount_(e) {
		if ($d(null === this.frames, "We already have a frame buffer"), e.length <= 6) {
			const t = Number(e);
			if (!isNaN(t)) return this.handleNewFrameCount_(t), null
		}
		return this.handleNewFrameCount_(1), e
	}
	handleIncomingFrame(e) {
		if (null === this.mySock) return;
		const t = e.data;
		if (this.bytesReceived += t.length, this.stats_.incrementCounter("bytes_received", t.length), this.resetKeepAlive(), null !== this.frames) this.appendFrame_(t);
		else {
			const e = this.extractFrameCount_(t);
			null !== e && this.appendFrame_(e)
		}
	}
	send(e) {
		this.resetKeepAlive();
		const t = cp(e);
		this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
		const n = Lf(t, 16384);
		n.length > 1 && this.sendString_(String(n.length));
		for (let i = 0; i < n.length; i++) this.sendString_(n[i])
	}
	shutdown_() {
		this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null)
	}
	onClosed_() {
		this.isClosed_ || (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null))
	}
	close() {
		this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_())
	}
	resetKeepAlive() {
		clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval((() => {
			this.mySock && this.sendString_("0"), this.resetKeepAlive()
		}), Math.floor(45e3))
	}
	sendString_(e) {
		try {
			this.mySock.send(e)
		} catch (t) {
			this.log_("Exception thrown from WebSocket.send():", t.message || t.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0)
		}
	}
}
Kf.responsesRequiredToBeHealthy = 2, Kf.healthyTimeout = 3e4;
class Jf {
	constructor(e) {
		this.initTransports_(e)
	}
	static get ALL_TRANSPORTS() {
		return [Xf, Kf]
	}
	initTransports_(e) {
		const t = Kf && Kf.isAvailable();
		let n = t && !Kf.previouslyFailed();
		if (e.webSocketOnly && (t || wf("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), n = !0), n) this.transports_ = [Kf];
		else {
			const e = this.transports_ = [];
			for (const t of Jf.ALL_TRANSPORTS) t && t.isAvailable() && e.push(t)
		}
	}
	initialTransport() {
		if (this.transports_.length > 0) return this.transports_[0];
		throw new Error("No transports available")
	}
	upgradeTransport() {
		return this.transports_.length > 1 ? this.transports_[1] : null
	}
}
class Qf {
	constructor(e, t, n, i, r, s, a, o, l, c) {
		this.id = e, this.repoInfo_ = t, this.applicationId_ = n, this.appCheckToken_ = i, this.authToken_ = r, this.onMessage_ = s, this.onReady_ = a, this.onDisconnect_ = o, this.onKill_ = l, this.lastSessionId = c, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = yf("c:" + this.id + ":"), this.transportManager_ = new Jf(t), this.log_("Connection created"), this.start_()
	}
	start_() {
		const e = this.transportManager_.initialTransport();
		this.conn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
		const t = this.connReceiver_(this.conn_),
			n = this.disconnReceiver_(this.conn_);
		this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout((() => {
			this.conn_ && this.conn_.open(t, n)
		}), Math.floor(0));
		const i = e.healthyTimeout || 0;
		i > 0 && (this.healthyTimeout_ = Of((() => {
			this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > 102400 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > 10240 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close()))
		}), Math.floor(i)))
	}
	nextTransportId_() {
		return "c:" + this.id + ":" + this.connectionCount++
	}
	disconnReceiver_(e) {
		return t => {
			e === this.conn_ ? this.onConnectionLost_(t) : e === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection")
		}
	}
	connReceiver_(e) {
		return t => {
			2 !== this.state_ && (e === this.rx_ ? this.onPrimaryMessageReceived_(t) : e === this.secondaryConn_ ? this.onSecondaryMessageReceived_(t) : this.log_("message on old connection"))
		}
	}
	sendRequest(e) {
		const t = {
			t: "d",
			d: e
		};
		this.sendData_(t)
	}
	tryCleanupConnection() {
		this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null)
	}
	onSecondaryControl_(e) {
		if ("t" in e) {
			const t = e.t;
			"a" === t ? this.upgradeIfSecondaryHealthy_() : "r" === t ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), this.tx_ !== this.secondaryConn_ && this.rx_ !== this.secondaryConn_ || this.close()) : "o" === t && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_())
		}
	}
	onSecondaryMessageReceived_(e) {
		const t = Af("t", e),
			n = Af("d", e);
		if ("c" === t) this.onSecondaryControl_(n);
		else {
			if ("d" !== t) throw new Error("Unknown protocol layer: " + t);
			this.pendingDataMessages.push(n)
		}
	}
	upgradeIfSecondaryHealthy_() {
		this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({
			t: "c",
			d: {
				t: "p",
				d: {}
			}
		}))
	}
	proceedWithUpgrade_() {
		this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({
			t: "c",
			d: {
				t: "a",
				d: {}
			}
		}), this.log_("Ending transmission on primary"), this.conn_.send({
			t: "c",
			d: {
				t: "n",
				d: {}
			}
		}), this.tx_ = this.secondaryConn_, this.tryCleanupConnection()
	}
	onPrimaryMessageReceived_(e) {
		const t = Af("t", e),
			n = Af("d", e);
		"c" === t ? this.onControl_(n) : "d" === t && this.onDataMessage_(n)
	}
	onDataMessage_(e) {
		this.onPrimaryResponse_(), this.onMessage_(e)
	}
	onPrimaryResponse_() {
		this.isHealthy_ || (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()))
	}
	onControl_(e) {
		const t = Af("t", e);
		if ("d" in e) {
			const n = e.d;
			if ("h" === t) this.onHandshake_(n);
			else if ("n" === t) {
				this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_;
				for (let e = 0; e < this.pendingDataMessages.length; ++e) this.onDataMessage_(this.pendingDataMessages[e]);
				this.pendingDataMessages = [], this.tryCleanupConnection()
			} else "s" === t ? this.onConnectionShutdown_(n) : "r" === t ? this.onReset_(n) : "e" === t ? xf("Server Error: " + n) : "o" === t ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : xf("Unknown control packet command: " + t)
		}
	}
	onHandshake_(e) {
		const t = e.ts,
			n = e.v,
			i = e.h;
		this.sessionId = e.s, this.repoInfo_.host = i, 0 === this.state_ && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, t), "5" !== n && wf("Protocol version mismatch detected"), this.tryStartUpgrade_())
	}
	tryStartUpgrade_() {
		const e = this.transportManager_.upgradeTransport();
		e && this.startUpgrade_(e)
	}
	startUpgrade_(e) {
		this.secondaryConn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
		const t = this.connReceiver_(this.secondaryConn_),
			n = this.disconnReceiver_(this.secondaryConn_);
		this.secondaryConn_.open(t, n), Of((() => {
			this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close())
		}), Math.floor(6e4))
	}
	onReset_(e) {
		this.log_("Reset packet received.  New host: " + e), this.repoInfo_.host = e, 1 === this.state_ ? this.close() : (this.closeConnections_(), this.start_())
	}
	onConnectionEstablished_(e, t) {
		this.log_("Realtime connection established."), this.conn_ = e, this.state_ = 1, this.onReady_ && (this.onReady_(t, this.sessionId), this.onReady_ = null), 0 === this.primaryResponsesRequired_ ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : Of((() => {
			this.sendPingOnPrimaryIfNecessary_()
		}), Math.floor(5e3))
	}
	sendPingOnPrimaryIfNecessary_() {
		this.isHealthy_ || 1 !== this.state_ || (this.log_("sending ping on primary."), this.sendData_({
			t: "c",
			d: {
				t: "p",
				d: {}
			}
		}))
	}
	onSecondaryConnectionLost_() {
		const e = this.secondaryConn_;
		this.secondaryConn_ = null, this.tx_ !== e && this.rx_ !== e || this.close()
	}
	onConnectionLost_(e) {
		this.conn_ = null, e || 0 !== this.state_ ? 1 === this.state_ && this.log_("Realtime connection lost.") : (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (uf.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)), this.close()
	}
	onConnectionShutdown_(e) {
		this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(e), this.onKill_ = null), this.onDisconnect_ = null, this.close()
	}
	sendData_(e) {
		if (1 !== this.state_) throw "Connection is not connected";
		this.tx_.send(e)
	}
	close() {
		2 !== this.state_ && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null))
	}
	closeConnections_() {
		this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null)
	}
}
class em {
	put(e, t, n, i) {}
	merge(e, t, n, i) {}
	refreshAuthToken(e) {}
	refreshAppCheckToken(e) {}
	onDisconnectPut(e, t, n) {}
	onDisconnectMerge(e, t, n) {}
	onDisconnectCancel(e, t) {}
	reportStats(e) {}
}
class tm {
	constructor(e) {
		this.allowedEvents_ = e, this.listeners_ = {}, $d(Array.isArray(e) && e.length > 0, "Requires a non-empty array")
	}
	trigger(e, ...t) {
		if (Array.isArray(this.listeners_[e])) {
			const n = [...this.listeners_[e]];
			for (let e = 0; e < n.length; e++) n[e].callback.apply(n[e].context, t)
		}
	}
	on(e, t, n) {
		this.validateEventType_(e), this.listeners_[e] = this.listeners_[e] || [], this.listeners_[e].push({
			callback: t,
			context: n
		});
		const i = this.getInitialEvent(e);
		i && t.apply(n, i)
	}
	off(e, t, n) {
		this.validateEventType_(e);
		const i = this.listeners_[e] || [];
		for (let r = 0; r < i.length; r++)
			if (i[r].callback === t && (!n || n === i[r].context)) return void i.splice(r, 1)
	}
	validateEventType_(e) {
		$d(this.allowedEvents_.find((t => t === e)), "Unknown event: " + e)
	}
}
class nm extends tm {
	constructor() {
		super(["online"]), this.online_ = !0, "undefined" == typeof window || void 0 === window.addEventListener || ip() || (window.addEventListener("online", (() => {
			this.online_ || (this.online_ = !0, this.trigger("online", !0))
		}), !1), window.addEventListener("offline", (() => {
			this.online_ && (this.online_ = !1, this.trigger("online", !1))
		}), !1))
	}
	static getInstance() {
		return new nm
	}
	getInitialEvent(e) {
		return $d("online" === e, "Unknown event type: " + e), [this.online_]
	}
	currentlyOnline() {
		return this.online_
	}
}
class im {
	constructor(e, t) {
		if (void 0 === t) {
			this.pieces_ = e.split("/");
			let t = 0;
			for (let e = 0; e < this.pieces_.length; e++) this.pieces_[e].length > 0 && (this.pieces_[t] = this.pieces_[e], t++);
			this.pieces_.length = t, this.pieceNum_ = 0
		} else this.pieces_ = e, this.pieceNum_ = t
	}
	toString() {
		let e = "";
		for (let t = this.pieceNum_; t < this.pieces_.length; t++) "" !== this.pieces_[t] && (e += "/" + this.pieces_[t]);
		return e || "/"
	}
}

function rm() {
	return new im("")
}

function sm(e) {
	return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_]
}

function am(e) {
	return e.pieces_.length - e.pieceNum_
}

function om(e) {
	let t = e.pieceNum_;
	return t < e.pieces_.length && t++, new im(e.pieces_, t)
}

function lm(e) {
	return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null
}

function cm(e, t = 0) {
	return e.pieces_.slice(e.pieceNum_ + t)
}

function um(e) {
	if (e.pieceNum_ >= e.pieces_.length) return null;
	const t = [];
	for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++) t.push(e.pieces_[n]);
	return new im(t, 0)
}

function hm(e, t) {
	const n = [];
	for (let i = e.pieceNum_; i < e.pieces_.length; i++) n.push(e.pieces_[i]);
	if (t instanceof im)
		for (let i = t.pieceNum_; i < t.pieces_.length; i++) n.push(t.pieces_[i]);
	else {
		const e = t.split("/");
		for (let t = 0; t < e.length; t++) e[t].length > 0 && n.push(e[t])
	}
	return new im(n, 0)
}

function dm(e) {
	return e.pieceNum_ >= e.pieces_.length
}

function pm(e, t) {
	const n = sm(e),
		i = sm(t);
	if (null === n) return t;
	if (n === i) return pm(om(e), om(t));
	throw new Error("INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")")
}

function fm(e, t) {
	if (am(e) !== am(t)) return !1;
	for (let n = e.pieceNum_, i = t.pieceNum_; n <= e.pieces_.length; n++, i++)
		if (e.pieces_[n] !== t.pieces_[i]) return !1;
	return !0
}

function mm(e, t) {
	let n = e.pieceNum_,
		i = t.pieceNum_;
	if (am(e) > am(t)) return !1;
	for (; n < e.pieces_.length;) {
		if (e.pieces_[n] !== t.pieces_[i]) return !1;
		++n, ++i
	}
	return !0
}
class gm {
	constructor(e, t) {
		this.errorPrefix_ = t, this.parts_ = cm(e, 0), this.byteLength_ = Math.max(1, this.parts_.length);
		for (let n = 0; n < this.parts_.length; n++) this.byteLength_ += yp(this.parts_[n]);
		vm(this)
	}
}

function vm(e) {
	if (e.byteLength_ > 768) throw new Error(e.errorPrefix_ + "has a key path longer than 768 bytes (" + e.byteLength_ + ").");
	if (e.parts_.length > 32) throw new Error(e.errorPrefix_ + "path specified exceeds the maximum depth that can be written (32) or object contains a cycle " + _m(e))
}

function _m(e) {
	return 0 === e.parts_.length ? "" : "in property '" + e.parts_.join(".") + "'"
}
class ym extends tm {
	constructor() {
		let e, t;
		super(["visible"]), "undefined" != typeof document && void 0 !== document.addEventListener && (void 0 !== document.hidden ? (t = "visibilitychange", e = "hidden") : void 0 !== document.mozHidden ? (t = "mozvisibilitychange", e = "mozHidden") : void 0 !== document.msHidden ? (t = "msvisibilitychange", e = "msHidden") : void 0 !== document.webkitHidden && (t = "webkitvisibilitychange", e = "webkitHidden")), this.visible_ = !0, t && document.addEventListener(t, (() => {
			const t = !document[e];
			t !== this.visible_ && (this.visible_ = t, this.trigger("visible", t))
		}), !1)
	}
	static getInstance() {
		return new ym
	}
	getInitialEvent(e) {
		return $d("visible" === e, "Unknown event type: " + e), [this.visible_]
	}
}
class xm extends em {
	constructor(e, t, n, i, r, s, a, o) {
		if (super(), this.repoInfo_ = e, this.applicationId_ = t, this.onDataUpdate_ = n, this.onConnectStatus_ = i, this.onServerInfoUpdate_ = r, this.authTokenProvider_ = s, this.appCheckTokenProvider_ = a, this.authOverride_ = o, this.id = xm.nextPersistentConnectionId_++, this.log_ = yf("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = 1e3, this.maxReconnectDelay_ = 3e5, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, o && !rp()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
		ym.getInstance().on("visible", this.onVisible_, this), -1 === e.host.indexOf("fblocal") && nm.getInstance().on("online", this.onOnline_, this)
	}
	sendRequest(e, t, n) {
		const i = ++this.requestNumber_,
			r = {
				r: i,
				a: e,
				b: t
			};
		this.log_(cp(r)), $d(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(r), n && (this.requestCBHash_[i] = n)
	}
	get(e) {
		this.initConnection_();
		const t = new np,
			n = {
				p: e._path.toString(),
				q: e._queryObject
			},
			i = {
				action: "g",
				request: n,
				onComplete: e => {
					const i = e.d;
					"ok" === e.s ? (this.onDataUpdate_(n.p, i, !1, null), t.resolve(i)) : t.reject(i)
				}
			};
		this.outstandingGets_.push(i), this.outstandingGetCount_++;
		const r = this.outstandingGets_.length - 1;
		return this.connected_ || setTimeout((() => {
			const e = this.outstandingGets_[r];
			void 0 !== e && i === e && (delete this.outstandingGets_[r], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), this.log_("get " + r + " timed out on connection"), t.reject(new Error("Client is offline.")))
		}), 3e3), this.connected_ && this.sendGet_(r), t.promise
	}
	listen(e, t, n, i) {
		this.initConnection_();
		const r = e._queryIdentifier,
			s = e._path.toString();
		this.log_("Listen called for " + s + " " + r), this.listens.has(s) || this.listens.set(s, new Map), $d(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "listen() called for non-default but complete query"), $d(!this.listens.get(s).has(r), "listen() called twice for same path/queryId.");
		const a = {
			onComplete: i,
			hashFn: t,
			query: e,
			tag: n
		};
		this.listens.get(s).set(r, a), this.connected_ && this.sendListen_(a)
	}
	sendGet_(e) {
		const t = this.outstandingGets_[e];
		this.sendRequest("g", t.request, (n => {
			delete this.outstandingGets_[e], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), t.onComplete && t.onComplete(n)
		}))
	}
	sendListen_(e) {
		const t = e.query,
			n = t._path.toString(),
			i = t._queryIdentifier;
		this.log_("Listen on " + n + " for " + i);
		const r = {
			p: n
		};
		e.tag && (r.q = t._queryObject, r.t = e.tag), r.h = e.hashFn(), this.sendRequest("q", r, (r => {
			const s = r.d,
				a = r.s;
			xm.warnOnListenWarnings_(s, t);
			(this.listens.get(n) && this.listens.get(n).get(i)) === e && (this.log_("listen response", r), "ok" !== a && this.removeListen_(n, i), e.onComplete && e.onComplete(a, s))
		}))
	}
	static warnOnListenWarnings_(e, t) {
		if (e && "object" == typeof e && hp(e, "w")) {
			const n = dp(e, "w");
			if (Array.isArray(n) && ~n.indexOf("no_index")) {
				const e = '".indexOn": "' + t._queryParams.getIndex().toString() + '"',
					n = t._path.toString();
				wf(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${e} at ${n} to your security rules for better performance.`)
			}
		}
	}
	refreshAuthToken(e) {
		this.authToken_ = e, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, (() => {})), this.reduceReconnectDelayIfAdminCredential_(e)
	}
	reduceReconnectDelayIfAdminCredential_(e) {
		(e && 40 === e.length || function(e) {
			const t = up(e).claims;
			return "object" == typeof t && !0 === t.admin
		}(e)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = 3e4)
	}
	refreshAppCheckToken(e) {
		this.appCheckToken_ = e, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, (() => {}))
	}
	tryAuth() {
		if (this.connected_ && this.authToken_) {
			const e = this.authToken_,
				t = function(e) {
					const t = up(e).claims;
					return !!t && "object" == typeof t && t.hasOwnProperty("iat")
				}(e) ? "auth" : "gauth",
				n = {
					cred: e
				};
			null === this.authOverride_ ? n.noauth = !0 : "object" == typeof this.authOverride_ && (n.authvar = this.authOverride_), this.sendRequest(t, n, (t => {
				const n = t.s,
					i = t.d || "error";
				this.authToken_ === e && ("ok" === n ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(n, i))
			}))
		}
	}
	tryAppCheck() {
		this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", {
			token: this.appCheckToken_
		}, (e => {
			const t = e.s,
				n = e.d || "error";
			"ok" === t ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(t, n)
		}))
	}
	unlisten(e, t) {
		const n = e._path.toString(),
			i = e._queryIdentifier;
		this.log_("Unlisten called for " + n + " " + i), $d(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
		this.removeListen_(n, i) && this.connected_ && this.sendUnlisten_(n, i, e._queryObject, t)
	}
	sendUnlisten_(e, t, n, i) {
		this.log_("Unlisten on " + e + " for " + t);
		const r = {
			p: e
		};
		i && (r.q = n, r.t = i), this.sendRequest("n", r)
	}
	onDisconnectPut(e, t, n) {
		this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", e, t, n) : this.onDisconnectRequestQueue_.push({
			pathString: e,
			action: "o",
			data: t,
			onComplete: n
		})
	}
	onDisconnectMerge(e, t, n) {
		this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", e, t, n) : this.onDisconnectRequestQueue_.push({
			pathString: e,
			action: "om",
			data: t,
			onComplete: n
		})
	}
	onDisconnectCancel(e, t) {
		this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", e, null, t) : this.onDisconnectRequestQueue_.push({
			pathString: e,
			action: "oc",
			data: null,
			onComplete: t
		})
	}
	sendOnDisconnect_(e, t, n, i) {
		const r = {
			p: t,
			d: n
		};
		this.log_("onDisconnect " + e, r), this.sendRequest(e, r, (e => {
			i && setTimeout((() => {
				i(e.s, e.d)
			}), Math.floor(0))
		}))
	}
	put(e, t, n, i) {
		this.putInternal("p", e, t, n, i)
	}
	merge(e, t, n, i) {
		this.putInternal("m", e, t, n, i)
	}
	putInternal(e, t, n, i, r) {
		this.initConnection_();
		const s = {
			p: t,
			d: n
		};
		void 0 !== r && (s.h = r), this.outstandingPuts_.push({
			action: e,
			request: s,
			onComplete: i
		}), this.outstandingPutCount_++;
		const a = this.outstandingPuts_.length - 1;
		this.connected_ ? this.sendPut_(a) : this.log_("Buffering put: " + t)
	}
	sendPut_(e) {
		const t = this.outstandingPuts_[e].action,
			n = this.outstandingPuts_[e].request,
			i = this.outstandingPuts_[e].onComplete;
		this.outstandingPuts_[e].queued = this.connected_, this.sendRequest(t, n, (n => {
			this.log_(t + " response", n), delete this.outstandingPuts_[e], this.outstandingPutCount_--, 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []), i && i(n.s, n.d)
		}))
	}
	reportStats(e) {
		if (this.connected_) {
			const t = {
				c: e
			};
			this.log_("reportStats", t), this.sendRequest("s", t, (e => {
				if ("ok" !== e.s) {
					const t = e.d;
					this.log_("reportStats", "Error sending stats: " + t)
				}
			}))
		}
	}
	onDataMessage_(e) {
		if ("r" in e) {
			this.log_("from server: " + cp(e));
			const t = e.r,
				n = this.requestCBHash_[t];
			n && (delete this.requestCBHash_[t], n(e.b))
		} else {
			if ("error" in e) throw "A server-side error has occurred: " + e.error;
			"a" in e && this.onDataPush_(e.a, e.b)
		}
	}
	onDataPush_(e, t) {
		this.log_("handleServerMessage", e, t), "d" === e ? this.onDataUpdate_(t.p, t.d, !1, t.t) : "m" === e ? this.onDataUpdate_(t.p, t.d, !0, t.t) : "c" === e ? this.onListenRevoked_(t.p, t.q) : "ac" === e ? this.onAuthRevoked_(t.s, t.d) : "apc" === e ? this.onAppCheckRevoked_(t.s, t.d) : "sd" === e ? this.onSecurityDebugPacket_(t) : xf("Unrecognized action received from server: " + cp(e) + "\nAre you using the latest client?")
	}
	onReady_(e, t) {
		this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = (new Date).getTime(), this.handleTimestamp_(e), this.lastSessionId = t, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0)
	}
	scheduleConnect_(e) {
		$d(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout((() => {
			this.establishConnectionTimer_ = null, this.establishConnection_()
		}), Math.floor(e))
	}
	initConnection_() {
		!this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0)
	}
	onVisible_(e) {
		e && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = e
	}
	onOnline_(e) {
		e ? (this.log_("Browser went online."), this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close())
	}
	onRealtimeDisconnect_() {
		if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) {
			if (this.visible_) {
				if (this.lastConnectionEstablishedTime_) {
					(new Date).getTime() - this.lastConnectionEstablishedTime_ > 3e4 && (this.reconnectDelay_ = 1e3), this.lastConnectionEstablishedTime_ = null
				}
			} else this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = (new Date).getTime();
			const e = (new Date).getTime() - this.lastConnectionAttemptTime_;
			let t = Math.max(0, this.reconnectDelay_ - e);
			t = Math.random() * t, this.log_("Trying to reconnect in " + t + "ms"), this.scheduleConnect_(t), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, 1.3 * this.reconnectDelay_)
		}
		this.onConnectStatus_(!1)
	}
	async establishConnection_() {
		if (this.shouldReconnect_()) {
			this.log_("Making a connection attempt"), this.lastConnectionAttemptTime_ = (new Date).getTime(), this.lastConnectionEstablishedTime_ = null;
			const t = this.onDataMessage_.bind(this),
				n = this.onReady_.bind(this),
				i = this.onRealtimeDisconnect_.bind(this),
				r = this.id + ":" + xm.nextConnectionId_++,
				s = this.lastSessionId;
			let a = !1,
				o = null;
			const l = function() {
					o ? o.close() : (a = !0, i())
				},
				c = function(e) {
					$d(o, "sendRequest call when we're not connected not allowed."), o.sendRequest(e)
				};
			this.realtime_ = {
				close: l,
				sendRequest: c
			};
			const u = this.forceTokenRefresh_;
			this.forceTokenRefresh_ = !1;
			try {
				const [e, l] = await Promise.all([this.authTokenProvider_.getToken(u), this.appCheckTokenProvider_.getToken(u)]);
				a ? _f("getToken() completed but was canceled") : (_f("getToken() completed. Creating connection."), this.authToken_ = e && e.accessToken, this.appCheckToken_ = l && l.token, o = new Qf(r, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, t, n, i, (e => {
					wf(e + " (" + this.repoInfo_.toString() + ")"), this.interrupt("server_kill")
				}), s))
			} catch (e) {
				this.log_("Failed to get token: " + e), a || (this.repoInfo_.nodeAdmin && wf(e), l())
			}
		}
	}
	interrupt(e) {
		_f("Interrupting connection for reason: " + e), this.interruptReasons_[e] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_())
	}
	resume(e) {
		_f("Resuming connection for reason: " + e), delete this.interruptReasons_[e], pp(this.interruptReasons_) && (this.reconnectDelay_ = 1e3, this.realtime_ || this.scheduleConnect_(0))
	}
	handleTimestamp_(e) {
		const t = e - (new Date).getTime();
		this.onServerInfoUpdate_({
			serverTimeOffset: t
		})
	}
	cancelSentTransactions_() {
		for (let e = 0; e < this.outstandingPuts_.length; e++) {
			const t = this.outstandingPuts_[e];
			t && "h" in t.request && t.queued && (t.onComplete && t.onComplete("disconnect"), delete this.outstandingPuts_[e], this.outstandingPutCount_--)
		}
		0 === this.outstandingPutCount_ && (this.outstandingPuts_ = [])
	}
	onListenRevoked_(e, t) {
		let n;
		n = t ? t.map((e => Pf(e))).join("$") : "default";
		const i = this.removeListen_(e, n);
		i && i.onComplete && i.onComplete("permission_denied")
	}
	removeListen_(e, t) {
		const n = new im(e).toString();
		let i;
		if (this.listens.has(n)) {
			const e = this.listens.get(n);
			i = e.get(t), e.delete(t), 0 === e.size && this.listens.delete(n)
		} else i = void 0;
		return i
	}
	onAuthRevoked_(e, t) {
		_f("Auth token revoked: " + e + "/" + t), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), "invalid_token" !== e && "permission_denied" !== e || (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= 3 && (this.reconnectDelay_ = 3e4, this.authTokenProvider_.notifyForInvalidToken()))
	}
	onAppCheckRevoked_(e, t) {
		_f("App check token revoked: " + e + "/" + t), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, "invalid_token" !== e && "permission_denied" !== e || (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= 3 && this.appCheckTokenProvider_.notifyForInvalidToken())
	}
	onSecurityDebugPacket_(e) {
		this.securityDebugCallback_ && this.securityDebugCallback_(e)
	}
	restoreState_() {
		this.tryAuth(), this.tryAppCheck();
		for (const e of this.listens.values())
			for (const t of e.values()) this.sendListen_(t);
		for (let e = 0; e < this.outstandingPuts_.length; e++) this.outstandingPuts_[e] && this.sendPut_(e);
		for (; this.onDisconnectRequestQueue_.length;) {
			const e = this.onDisconnectRequestQueue_.shift();
			this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete)
		}
		for (let e = 0; e < this.outstandingGets_.length; e++) this.outstandingGets_[e] && this.sendGet_(e)
	}
	sendConnectStats_() {
		const e = {};
		e["sdk.js." + af.replace(/\./g, "-")] = 1, ip() ? e["framework.cordova"] = 1 : "object" == typeof navigator && "ReactNative" === navigator.product && (e["framework.reactnative"] = 1), this.reportStats(e)
	}
	shouldReconnect_() {
		const e = nm.getInstance().currentlyOnline();
		return pp(this.interruptReasons_) && e
	}
}
xm.nextPersistentConnectionId_ = 0, xm.nextConnectionId_ = 0;
class bm {
	constructor(e, t) {
		this.name = e, this.node = t
	}
	static Wrap(e, t) {
		return new bm(e, t)
	}
}
class wm {
	getCompare() {
		return this.compare.bind(this)
	}
	indexedValueChanged(e, t) {
		const n = new bm(Mf, e),
			i = new bm(Mf, t);
		return 0 !== this.compare(n, i)
	}
	minPost() {
		return bm.MIN
	}
}
let Sm;
class Mm extends wm {
	static get __EMPTY_NODE() {
		return Sm
	}
	static set __EMPTY_NODE(e) {
		Sm = e
	}
	compare(e, t) {
		return Cf(e.name, t.name)
	}
	isDefinedOn(e) {
		throw Zd("KeyIndex.isDefinedOn not expected to be called.")
	}
	indexedValueChanged(e, t) {
		return !1
	}
	minPost() {
		return bm.MIN
	}
	maxPost() {
		return new bm(Tf, Sm)
	}
	makePost(e, t) {
		return $d("string" == typeof e, "KeyIndex indexValue must always be a string."), new bm(e, Sm)
	}
	toString() {
		return ".key"
	}
}
const Tm = new Mm;
class Cm {
	constructor(e, t, n, i, r = null) {
		this.isReverse_ = i, this.resultGenerator_ = r, this.nodeStack_ = [];
		let s = 1;
		for (; !e.isEmpty();)
			if (e = e, s = t ? n(e.key, t) : 1, i && (s *= -1), s < 0) e = this.isReverse_ ? e.left : e.right;
			else {
				if (0 === s) {
					this.nodeStack_.push(e);
					break
				}
				this.nodeStack_.push(e), e = this.isReverse_ ? e.right : e.left
			}
	}
	getNext() {
		if (0 === this.nodeStack_.length) return null;
		let e, t = this.nodeStack_.pop();
		if (e = this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : {
				key: t.key,
				value: t.value
			}, this.isReverse_)
			for (t = t.left; !t.isEmpty();) this.nodeStack_.push(t), t = t.right;
		else
			for (t = t.right; !t.isEmpty();) this.nodeStack_.push(t), t = t.left;
		return e
	}
	hasNext() {
		return this.nodeStack_.length > 0
	}
	peek() {
		if (0 === this.nodeStack_.length) return null;
		const e = this.nodeStack_[this.nodeStack_.length - 1];
		return this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : {
			key: e.key,
			value: e.value
		}
	}
}
class Em {
	constructor(e, t, n, i, r) {
		this.key = e, this.value = t, this.color = null != n ? n : Em.RED, this.left = null != i ? i : Am.EMPTY_NODE, this.right = null != r ? r : Am.EMPTY_NODE
	}
	copy(e, t, n, i, r) {
		return new Em(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != i ? i : this.left, null != r ? r : this.right)
	}
	count() {
		return this.left.count() + 1 + this.right.count()
	}
	isEmpty() {
		return !1
	}
	inorderTraversal(e) {
		return this.left.inorderTraversal(e) || !!e(this.key, this.value) || this.right.inorderTraversal(e)
	}
	reverseTraversal(e) {
		return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
	}
	min_() {
		return this.left.isEmpty() ? this : this.left.min_()
	}
	minKey() {
		return this.min_().key
	}
	maxKey() {
		return this.right.isEmpty() ? this.key : this.right.maxKey()
	}
	insert(e, t, n) {
		let i = this;
		const r = n(e, i.key);
		return i = r < 0 ? i.copy(null, null, null, i.left.insert(e, t, n), null) : 0 === r ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, n)), i.fixUp_()
	}
	removeMin_() {
		if (this.left.isEmpty()) return Am.EMPTY_NODE;
		let e = this;
		return e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()), e = e.copy(null, null, null, e.left.removeMin_(), null), e.fixUp_()
	}
	remove(e, t) {
		let n, i;
		if (n = this, t(e, n.key) < 0) n.left.isEmpty() || n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_()), n = n.copy(null, null, null, n.left.remove(e, t), null);
		else {
			if (n.left.isRed_() && (n = n.rotateRight_()), n.right.isEmpty() || n.right.isRed_() || n.right.left.isRed_() || (n = n.moveRedRight_()), 0 === t(e, n.key)) {
				if (n.right.isEmpty()) return Am.EMPTY_NODE;
				i = n.right.min_(), n = n.copy(i.key, i.value, null, null, n.right.removeMin_())
			}
			n = n.copy(null, null, null, null, n.right.remove(e, t))
		}
		return n.fixUp_()
	}
	isRed_() {
		return this.color
	}
	fixUp_() {
		let e = this;
		return e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()), e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()), e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()), e
	}
	moveRedLeft_() {
		let e = this.colorFlip_();
		return e.right.left.isRed_() && (e = e.copy(null, null, null, null, e.right.rotateRight_()), e = e.rotateLeft_(), e = e.colorFlip_()), e
	}
	moveRedRight_() {
		let e = this.colorFlip_();
		return e.left.left.isRed_() && (e = e.rotateRight_(), e = e.colorFlip_()), e
	}
	rotateLeft_() {
		const e = this.copy(null, null, Em.RED, null, this.right.left);
		return this.right.copy(null, null, this.color, e, null)
	}
	rotateRight_() {
		const e = this.copy(null, null, Em.RED, this.left.right, null);
		return this.left.copy(null, null, this.color, null, e)
	}
	colorFlip_() {
		const e = this.left.copy(null, null, !this.left.color, null, null),
			t = this.right.copy(null, null, !this.right.color, null, null);
		return this.copy(null, null, !this.color, e, t)
	}
	checkMaxDepth_() {
		const e = this.check_();
		return Math.pow(2, e) <= this.count() + 1
	}
	check_() {
		if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
		if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
		const e = this.left.check_();
		if (e !== this.right.check_()) throw new Error("Black depths differ");
		return e + (this.isRed_() ? 0 : 1)
	}
}
Em.RED = !0, Em.BLACK = !1;
class Am {
	constructor(e, t = Am.EMPTY_NODE) {
		this.comparator_ = e, this.root_ = t
	}
	insert(e, t) {
		return new Am(this.comparator_, this.root_.insert(e, t, this.comparator_).copy(null, null, Em.BLACK, null, null))
	}
	remove(e) {
		return new Am(this.comparator_, this.root_.remove(e, this.comparator_).copy(null, null, Em.BLACK, null, null))
	}
	get(e) {
		let t, n = this.root_;
		for (; !n.isEmpty();) {
			if (t = this.comparator_(e, n.key), 0 === t) return n.value;
			t < 0 ? n = n.left : t > 0 && (n = n.right)
		}
		return null
	}
	getPredecessorKey(e) {
		let t, n = this.root_,
			i = null;
		for (; !n.isEmpty();) {
			if (t = this.comparator_(e, n.key), 0 === t) {
				if (n.left.isEmpty()) return i ? i.key : null;
				for (n = n.left; !n.right.isEmpty();) n = n.right;
				return n.key
			}
			t < 0 ? n = n.left : t > 0 && (i = n, n = n.right)
		}
		throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")
	}
	isEmpty() {
		return this.root_.isEmpty()
	}
	count() {
		return this.root_.count()
	}
	minKey() {
		return this.root_.minKey()
	}
	maxKey() {
		return this.root_.maxKey()
	}
	inorderTraversal(e) {
		return this.root_.inorderTraversal(e)
	}
	reverseTraversal(e) {
		return this.root_.reverseTraversal(e)
	}
	getIterator(e) {
		return new Cm(this.root_, null, this.comparator_, !1, e)
	}
	getIteratorFrom(e, t) {
		return new Cm(this.root_, e, this.comparator_, !1, t)
	}
	getReverseIteratorFrom(e, t) {
		return new Cm(this.root_, e, this.comparator_, !0, t)
	}
	getReverseIterator(e) {
		return new Cm(this.root_, null, this.comparator_, !0, e)
	}
}

function Pm(e, t) {
	return Cf(e.name, t.name)
}

function Lm(e, t) {
	return Cf(e, t)
}
let Im;
Am.EMPTY_NODE = new class {
	copy(e, t, n, i, r) {
		return this
	}
	insert(e, t, n) {
		return new Em(e, t, null)
	}
	remove(e, t) {
		return this
	}
	count() {
		return 0
	}
	isEmpty() {
		return !0
	}
	inorderTraversal(e) {
		return !1
	}
	reverseTraversal(e) {
		return !1
	}
	minKey() {
		return null
	}
	maxKey() {
		return null
	}
	check_() {
		return 0
	}
	isRed_() {
		return !1
	}
};
const Dm = function(e) {
		return "number" == typeof e ? "number:" + Df(e) : "string:" + e
	},
	Rm = function(e) {
		if (e.isLeafNode()) {
			const t = e.val();
			$d("string" == typeof t || "number" == typeof t || "object" == typeof t && hp(t, ".sv"), "Priority must be a string or number.")
		} else $d(e === Im || e.isEmpty(), "priority of unexpected type.");
		$d(e === Im || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.")
	};
let km, Nm, Om;
class Fm {
	constructor(e, t = Fm.__childrenNodeConstructor.EMPTY_NODE) {
		this.value_ = e, this.priorityNode_ = t, this.lazyHash_ = null, $d(void 0 !== this.value_ && null !== this.value_, "LeafNode shouldn't be created with null/undefined value."), Rm(this.priorityNode_)
	}
	static set __childrenNodeConstructor(e) {
		km = e
	}
	static get __childrenNodeConstructor() {
		return km
	}
	isLeafNode() {
		return !0
	}
	getPriority() {
		return this.priorityNode_
	}
	updatePriority(e) {
		return new Fm(this.value_, e)
	}
	getImmediateChild(e) {
		return ".priority" === e ? this.priorityNode_ : Fm.__childrenNodeConstructor.EMPTY_NODE
	}
	getChild(e) {
		return dm(e) ? this : ".priority" === sm(e) ? this.priorityNode_ : Fm.__childrenNodeConstructor.EMPTY_NODE
	}
	hasChild() {
		return !1
	}
	getPredecessorChildName(e, t) {
		return null
	}
	updateImmediateChild(e, t) {
		return ".priority" === e ? this.updatePriority(t) : t.isEmpty() && ".priority" !== e ? this : Fm.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e, t).updatePriority(this.priorityNode_)
	}
	updateChild(e, t) {
		const n = sm(e);
		return null === n ? t : t.isEmpty() && ".priority" !== n ? this : ($d(".priority" !== n || 1 === am(e), ".priority must be the last token in a path"), this.updateImmediateChild(n, Fm.__childrenNodeConstructor.EMPTY_NODE.updateChild(om(e), t)))
	}
	isEmpty() {
		return !1
	}
	numChildren() {
		return 0
	}
	forEachChild(e, t) {
		return !1
	}
	val(e) {
		return e && !this.getPriority().isEmpty() ? {
			".value": this.getValue(),
			".priority": this.getPriority().val()
		} : this.getValue()
	}
	hash() {
		if (null === this.lazyHash_) {
			let e = "";
			this.priorityNode_.isEmpty() || (e += "priority:" + Dm(this.priorityNode_.val()) + ":");
			const t = typeof this.value_;
			e += t + ":", e += "number" === t ? Df(this.value_) : this.value_, this.lazyHash_ = ff(e)
		}
		return this.lazyHash_
	}
	getValue() {
		return this.value_
	}
	compareTo(e) {
		return e === Fm.__childrenNodeConstructor.EMPTY_NODE ? 1 : e instanceof Fm.__childrenNodeConstructor ? -1 : ($d(e.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(e))
	}
	compareToLeafNode_(e) {
		const t = typeof e.value_,
			n = typeof this.value_,
			i = Fm.VALUE_TYPE_ORDER.indexOf(t),
			r = Fm.VALUE_TYPE_ORDER.indexOf(n);
		return $d(i >= 0, "Unknown leaf type: " + t), $d(r >= 0, "Unknown leaf type: " + n), i === r ? "object" === n ? 0 : this.value_ < e.value_ ? -1 : this.value_ === e.value_ ? 0 : 1 : r - i
	}
	withIndex() {
		return this
	}
	isIndexed() {
		return !0
	}
	equals(e) {
		if (e === this) return !0;
		if (e.isLeafNode()) {
			const t = e;
			return this.value_ === t.value_ && this.priorityNode_.equals(t.priorityNode_)
		}
		return !1
	}
}
Fm.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
const zm = new class extends wm {
		compare(e, t) {
			const n = e.node.getPriority(),
				i = t.node.getPriority(),
				r = n.compareTo(i);
			return 0 === r ? Cf(e.name, t.name) : r
		}
		isDefinedOn(e) {
			return !e.getPriority().isEmpty()
		}
		indexedValueChanged(e, t) {
			return !e.getPriority().equals(t.getPriority())
		}
		minPost() {
			return bm.MIN
		}
		maxPost() {
			return new bm(Tf, new Fm("[PRIORITY-POST]", Om))
		}
		makePost(e, t) {
			const n = Nm(e);
			return new bm(t, new Fm("[PRIORITY-POST]", n))
		}
		toString() {
			return ".priority"
		}
	},
	Um = Math.log(2);
class Bm {
	constructor(e) {
		var t;
		this.count = (t = e + 1, parseInt(Math.log(t) / Um, 10)), this.current_ = this.count - 1;
		const n = (i = this.count, parseInt(Array(i + 1).join("1"), 2));
		var i;
		this.bits_ = e + 1 & n
	}
	nextBitIsOne() {
		const e = !(this.bits_ & 1 << this.current_);
		return this.current_--, e
	}
}
const Vm = function(e, t, n, i) {
	e.sort(t);
	const r = function(t, i) {
			const s = i - t;
			let a, o;
			if (0 === s) return null;
			if (1 === s) return a = e[t], o = n ? n(a) : a, new Em(o, a.node, Em.BLACK, null, null); {
				const l = parseInt(s / 2, 10) + t,
					c = r(t, l),
					u = r(l + 1, i);
				return a = e[l], o = n ? n(a) : a, new Em(o, a.node, Em.BLACK, c, u)
			}
		},
		s = function(t) {
			let i = null,
				s = null,
				a = e.length;
			const o = function(t, i) {
					const s = a - t,
						o = a;
					a -= t;
					const c = r(s + 1, o),
						u = e[s],
						h = n ? n(u) : u;
					l(new Em(h, u.node, i, null, c))
				},
				l = function(e) {
					i ? (i.left = e, i = e) : (s = e, i = e)
				};
			for (let e = 0; e < t.count; ++e) {
				const n = t.nextBitIsOne(),
					i = Math.pow(2, t.count - (e + 1));
				n ? o(i, Em.BLACK) : (o(i, Em.BLACK), o(i, Em.RED))
			}
			return s
		}(new Bm(e.length));
	return new Am(i || t, s)
};
let Hm;
const Gm = {};
class Wm {
	constructor(e, t) {
		this.indexes_ = e, this.indexSet_ = t
	}
	static get Default() {
		return $d(Gm && zm, "ChildrenNode.ts has not been loaded"), Hm = Hm || new Wm({
			".priority": Gm
		}, {
			".priority": zm
		}), Hm
	}
	get(e) {
		const t = dp(this.indexes_, e);
		if (!t) throw new Error("No index defined for " + e);
		return t instanceof Am ? t : null
	}
	hasIndex(e) {
		return hp(this.indexSet_, e.toString())
	}
	addIndex(e, t) {
		$d(e !== Tm, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
		const n = [];
		let i = !1;
		const r = t.getIterator(bm.Wrap);
		let s, a = r.getNext();
		for (; a;) i = i || e.isDefinedOn(a.node), n.push(a), a = r.getNext();
		s = i ? Vm(n, e.getCompare()) : Gm;
		const o = e.toString(),
			l = Object.assign({}, this.indexSet_);
		l[o] = e;
		const c = Object.assign({}, this.indexes_);
		return c[o] = s, new Wm(c, l)
	}
	addToIndexes(e, t) {
		const n = fp(this.indexes_, ((n, i) => {
			const r = dp(this.indexSet_, i);
			if ($d(r, "Missing index implementation for " + i), n === Gm) {
				if (r.isDefinedOn(e.node)) {
					const n = [],
						i = t.getIterator(bm.Wrap);
					let s = i.getNext();
					for (; s;) s.name !== e.name && n.push(s), s = i.getNext();
					return n.push(e), Vm(n, r.getCompare())
				}
				return Gm
			} {
				const i = t.get(e.name);
				let r = n;
				return i && (r = r.remove(new bm(e.name, i))), r.insert(e, e.node)
			}
		}));
		return new Wm(n, this.indexSet_)
	}
	removeFromIndexes(e, t) {
		const n = fp(this.indexes_, (n => {
			if (n === Gm) return n; {
				const i = t.get(e.name);
				return i ? n.remove(new bm(e.name, i)) : n
			}
		}));
		return new Wm(n, this.indexSet_)
	}
}
let qm;
class jm {
	constructor(e, t, n) {
		this.children_ = e, this.priorityNode_ = t, this.indexMap_ = n, this.lazyHash_ = null, this.priorityNode_ && Rm(this.priorityNode_), this.children_.isEmpty() && $d(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority")
	}
	static get EMPTY_NODE() {
		return qm || (qm = new jm(new Am(Lm), null, Wm.Default))
	}
	isLeafNode() {
		return !1
	}
	getPriority() {
		return this.priorityNode_ || qm
	}
	updatePriority(e) {
		return this.children_.isEmpty() ? this : new jm(this.children_, e, this.indexMap_)
	}
	getImmediateChild(e) {
		if (".priority" === e) return this.getPriority(); {
			const t = this.children_.get(e);
			return null === t ? qm : t
		}
	}
	getChild(e) {
		const t = sm(e);
		return null === t ? this : this.getImmediateChild(t).getChild(om(e))
	}
	hasChild(e) {
		return null !== this.children_.get(e)
	}
	updateImmediateChild(e, t) {
		if ($d(t, "We should always be passing snapshot nodes"), ".priority" === e) return this.updatePriority(t); {
			const n = new bm(e, t);
			let i, r;
			t.isEmpty() ? (i = this.children_.remove(e), r = this.indexMap_.removeFromIndexes(n, this.children_)) : (i = this.children_.insert(e, t), r = this.indexMap_.addToIndexes(n, this.children_));
			const s = i.isEmpty() ? qm : this.priorityNode_;
			return new jm(i, s, r)
		}
	}
	updateChild(e, t) {
		const n = sm(e);
		if (null === n) return t; {
			$d(".priority" !== sm(e) || 1 === am(e), ".priority must be the last token in a path");
			const i = this.getImmediateChild(n).updateChild(om(e), t);
			return this.updateImmediateChild(n, i)
		}
	}
	isEmpty() {
		return this.children_.isEmpty()
	}
	numChildren() {
		return this.children_.count()
	}
	val(e) {
		if (this.isEmpty()) return null;
		const t = {};
		let n = 0,
			i = 0,
			r = !0;
		if (this.forEachChild(zm, ((s, a) => {
				t[s] = a.val(e), n++, r && jm.INTEGER_REGEXP_.test(s) ? i = Math.max(i, Number(s)) : r = !1
			})), !e && r && i < 2 * n) {
			const e = [];
			for (const n in t) e[n] = t[n];
			return e
		}
		return e && !this.getPriority().isEmpty() && (t[".priority"] = this.getPriority().val()), t
	}
	hash() {
		if (null === this.lazyHash_) {
			let e = "";
			this.getPriority().isEmpty() || (e += "priority:" + Dm(this.getPriority().val()) + ":"), this.forEachChild(zm, ((t, n) => {
				const i = n.hash();
				"" !== i && (e += ":" + t + ":" + i)
			})), this.lazyHash_ = "" === e ? "" : ff(e)
		}
		return this.lazyHash_
	}
	getPredecessorChildName(e, t, n) {
		const i = this.resolveIndex_(n);
		if (i) {
			const n = i.getPredecessorKey(new bm(e, t));
			return n ? n.name : null
		}
		return this.children_.getPredecessorKey(e)
	}
	getFirstChildName(e) {
		const t = this.resolveIndex_(e);
		if (t) {
			const e = t.minKey();
			return e && e.name
		}
		return this.children_.minKey()
	}
	getFirstChild(e) {
		const t = this.getFirstChildName(e);
		return t ? new bm(t, this.children_.get(t)) : null
	}
	getLastChildName(e) {
		const t = this.resolveIndex_(e);
		if (t) {
			const e = t.maxKey();
			return e && e.name
		}
		return this.children_.maxKey()
	}
	getLastChild(e) {
		const t = this.getLastChildName(e);
		return t ? new bm(t, this.children_.get(t)) : null
	}
	forEachChild(e, t) {
		const n = this.resolveIndex_(e);
		return n ? n.inorderTraversal((e => t(e.name, e.node))) : this.children_.inorderTraversal(t)
	}
	getIterator(e) {
		return this.getIteratorFrom(e.minPost(), e)
	}
	getIteratorFrom(e, t) {
		const n = this.resolveIndex_(t);
		if (n) return n.getIteratorFrom(e, (e => e)); {
			const n = this.children_.getIteratorFrom(e.name, bm.Wrap);
			let i = n.peek();
			for (; null != i && t.compare(i, e) < 0;) n.getNext(), i = n.peek();
			return n
		}
	}
	getReverseIterator(e) {
		return this.getReverseIteratorFrom(e.maxPost(), e)
	}
	getReverseIteratorFrom(e, t) {
		const n = this.resolveIndex_(t);
		if (n) return n.getReverseIteratorFrom(e, (e => e)); {
			const n = this.children_.getReverseIteratorFrom(e.name, bm.Wrap);
			let i = n.peek();
			for (; null != i && t.compare(i, e) > 0;) n.getNext(), i = n.peek();
			return n
		}
	}
	compareTo(e) {
		return this.isEmpty() ? e.isEmpty() ? 0 : -1 : e.isLeafNode() || e.isEmpty() ? 1 : e === Ym ? -1 : 0
	}
	withIndex(e) {
		if (e === Tm || this.indexMap_.hasIndex(e)) return this; {
			const t = this.indexMap_.addIndex(e, this.children_);
			return new jm(this.children_, this.priorityNode_, t)
		}
	}
	isIndexed(e) {
		return e === Tm || this.indexMap_.hasIndex(e)
	}
	equals(e) {
		if (e === this) return !0;
		if (e.isLeafNode()) return !1; {
			const t = e;
			if (this.getPriority().equals(t.getPriority())) {
				if (this.children_.count() === t.children_.count()) {
					const e = this.getIterator(zm),
						n = t.getIterator(zm);
					let i = e.getNext(),
						r = n.getNext();
					for (; i && r;) {
						if (i.name !== r.name || !i.node.equals(r.node)) return !1;
						i = e.getNext(), r = n.getNext()
					}
					return null === i && null === r
				}
				return !1
			}
			return !1
		}
	}
	resolveIndex_(e) {
		return e === Tm ? null : this.indexMap_.get(e.toString())
	}
}
jm.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
const Ym = new class extends jm {
	constructor() {
		super(new Am(Lm), jm.EMPTY_NODE, Wm.Default)
	}
	compareTo(e) {
		return e === this ? 0 : 1
	}
	equals(e) {
		return e === this
	}
	getPriority() {
		return this
	}
	getImmediateChild(e) {
		return jm.EMPTY_NODE
	}
	isEmpty() {
		return !1
	}
};
Object.defineProperties(bm, {
		MIN: {
			value: new bm(Mf, jm.EMPTY_NODE)
		},
		MAX: {
			value: new bm(Tf, Ym)
		}
	}), Mm.__EMPTY_NODE = jm.EMPTY_NODE, Fm.__childrenNodeConstructor = jm, Im = Ym,
	function(e) {
		Om = e
	}(Ym);

function Xm(e, t = null) {
	if (null === e) return jm.EMPTY_NODE;
	if ("object" == typeof e && ".priority" in e && (t = e[".priority"]), $d(null === t || "string" == typeof t || "number" == typeof t || "object" == typeof t && ".sv" in t, "Invalid priority type found: " + typeof t), "object" == typeof e && ".value" in e && null !== e[".value"] && (e = e[".value"]), "object" != typeof e || ".sv" in e) {
		return new Fm(e, Xm(t))
	}
	if (e instanceof Array) {
		let n = jm.EMPTY_NODE;
		return If(e, ((t, i) => {
			if (hp(e, t) && "." !== t.substring(0, 1)) {
				const e = Xm(i);
				!e.isLeafNode() && e.isEmpty() || (n = n.updateImmediateChild(t, e))
			}
		})), n.updatePriority(Xm(t))
	} {
		const n = [];
		let i = !1;
		if (If(e, ((e, t) => {
				if ("." !== e.substring(0, 1)) {
					const r = Xm(t);
					r.isEmpty() || (i = i || !r.getPriority().isEmpty(), n.push(new bm(e, r)))
				}
			})), 0 === n.length) return jm.EMPTY_NODE;
		const r = Vm(n, Pm, (e => e.name), Lm);
		if (i) {
			const e = Vm(n, zm.getCompare());
			return new jm(r, Xm(t), new Wm({
				".priority": e
			}, {
				".priority": zm
			}))
		}
		return new jm(r, Xm(t), Wm.Default)
	}
}! function(e) {
	Nm = e
}(Xm);
class $m extends wm {
	constructor(e) {
		super(), this.indexPath_ = e, $d(!dm(e) && ".priority" !== sm(e), "Can't create PathIndex with empty path or .priority key")
	}
	extractChild(e) {
		return e.getChild(this.indexPath_)
	}
	isDefinedOn(e) {
		return !e.getChild(this.indexPath_).isEmpty()
	}
	compare(e, t) {
		const n = this.extractChild(e.node),
			i = this.extractChild(t.node),
			r = n.compareTo(i);
		return 0 === r ? Cf(e.name, t.name) : r
	}
	makePost(e, t) {
		const n = Xm(e),
			i = jm.EMPTY_NODE.updateChild(this.indexPath_, n);
		return new bm(t, i)
	}
	maxPost() {
		const e = jm.EMPTY_NODE.updateChild(this.indexPath_, Ym);
		return new bm(Tf, e)
	}
	toString() {
		return cm(this.indexPath_, 0).join("/")
	}
}
const Zm = new class extends wm {
		compare(e, t) {
			const n = e.node.compareTo(t.node);
			return 0 === n ? Cf(e.name, t.name) : n
		}
		isDefinedOn(e) {
			return !0
		}
		indexedValueChanged(e, t) {
			return !e.equals(t)
		}
		minPost() {
			return bm.MIN
		}
		maxPost() {
			return bm.MAX
		}
		makePost(e, t) {
			const n = Xm(e);
			return new bm(t, n)
		}
		toString() {
			return ".value"
		}
	},
	Km = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",
	Jm = function() {
		let e = 0;
		const t = [];
		return function(n) {
			const i = n === e;
			let r;
			e = n;
			const s = new Array(8);
			for (r = 7; r >= 0; r--) s[r] = Km.charAt(n % 64), n = Math.floor(n / 64);
			$d(0 === n, "Cannot push at time == 0");
			let a = s.join("");
			if (i) {
				for (r = 11; r >= 0 && 63 === t[r]; r--) t[r] = 0;
				t[r]++
			} else
				for (r = 0; r < 12; r++) t[r] = Math.floor(64 * Math.random());
			for (r = 0; r < 12; r++) a += Km.charAt(t[r]);
			return $d(20 === a.length, "nextPushId: Length should be 20."), a
		}
	}();

function Qm(e) {
	return {
		type: "value",
		snapshotNode: e
	}
}

function eg(e, t) {
	return {
		type: "child_added",
		snapshotNode: t,
		childName: e
	}
}

function tg(e, t) {
	return {
		type: "child_removed",
		snapshotNode: t,
		childName: e
	}
}

function ng(e, t, n) {
	return {
		type: "child_changed",
		snapshotNode: t,
		childName: e,
		oldSnap: n
	}
}
class ig {
	constructor(e) {
		this.index_ = e
	}
	updateChild(e, t, n, i, r, s) {
		$d(e.isIndexed(this.index_), "A node must be indexed if only a child is updated");
		const a = e.getImmediateChild(t);
		return a.getChild(i).equals(n.getChild(i)) && a.isEmpty() === n.isEmpty() ? e : (null != s && (n.isEmpty() ? e.hasChild(t) ? s.trackChildChange(tg(t, a)) : $d(e.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : a.isEmpty() ? s.trackChildChange(eg(t, n)) : s.trackChildChange(ng(t, n, a))), e.isLeafNode() && n.isEmpty() ? e : e.updateImmediateChild(t, n).withIndex(this.index_))
	}
	updateFullNode(e, t, n) {
		return null != n && (e.isLeafNode() || e.forEachChild(zm, ((e, i) => {
			t.hasChild(e) || n.trackChildChange(tg(e, i))
		})), t.isLeafNode() || t.forEachChild(zm, ((t, i) => {
			if (e.hasChild(t)) {
				const r = e.getImmediateChild(t);
				r.equals(i) || n.trackChildChange(ng(t, i, r))
			} else n.trackChildChange(eg(t, i))
		}))), t.withIndex(this.index_)
	}
	updatePriority(e, t) {
		return e.isEmpty() ? jm.EMPTY_NODE : e.updatePriority(t)
	}
	filtersNodes() {
		return !1
	}
	getIndexedFilter() {
		return this
	}
	getIndex() {
		return this.index_
	}
}
class rg {
	constructor(e) {
		this.indexedFilter_ = new ig(e.getIndex()), this.index_ = e.getIndex(), this.startPost_ = rg.getStartPost_(e), this.endPost_ = rg.getEndPost_(e)
	}
	getStartPost() {
		return this.startPost_
	}
	getEndPost() {
		return this.endPost_
	}
	matches(e) {
		return this.index_.compare(this.getStartPost(), e) <= 0 && this.index_.compare(e, this.getEndPost()) <= 0
	}
	updateChild(e, t, n, i, r, s) {
		return this.matches(new bm(t, n)) || (n = jm.EMPTY_NODE), this.indexedFilter_.updateChild(e, t, n, i, r, s)
	}
	updateFullNode(e, t, n) {
		t.isLeafNode() && (t = jm.EMPTY_NODE);
		let i = t.withIndex(this.index_);
		i = i.updatePriority(jm.EMPTY_NODE);
		const r = this;
		return t.forEachChild(zm, ((e, t) => {
			r.matches(new bm(e, t)) || (i = i.updateImmediateChild(e, jm.EMPTY_NODE))
		})), this.indexedFilter_.updateFullNode(e, i, n)
	}
	updatePriority(e, t) {
		return e
	}
	filtersNodes() {
		return !0
	}
	getIndexedFilter() {
		return this.indexedFilter_
	}
	getIndex() {
		return this.index_
	}
	static getStartPost_(e) {
		if (e.hasStart()) {
			const t = e.getIndexStartName();
			return e.getIndex().makePost(e.getIndexStartValue(), t)
		}
		return e.getIndex().minPost()
	}
	static getEndPost_(e) {
		if (e.hasEnd()) {
			const t = e.getIndexEndName();
			return e.getIndex().makePost(e.getIndexEndValue(), t)
		}
		return e.getIndex().maxPost()
	}
}
class sg {
	constructor(e) {
		this.rangedFilter_ = new rg(e), this.index_ = e.getIndex(), this.limit_ = e.getLimit(), this.reverse_ = !e.isViewFromLeft()
	}
	updateChild(e, t, n, i, r, s) {
		return this.rangedFilter_.matches(new bm(t, n)) || (n = jm.EMPTY_NODE), e.getImmediateChild(t).equals(n) ? e : e.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, n, i, r, s) : this.fullLimitUpdateChild_(e, t, n, r, s)
	}
	updateFullNode(e, t, n) {
		let i;
		if (t.isLeafNode() || t.isEmpty()) i = jm.EMPTY_NODE.withIndex(this.index_);
		else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) {
			let e;
			i = jm.EMPTY_NODE.withIndex(this.index_), e = this.reverse_ ? t.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
			let n = 0;
			for (; e.hasNext() && n < this.limit_;) {
				const t = e.getNext();
				let r;
				if (r = this.reverse_ ? this.index_.compare(this.rangedFilter_.getStartPost(), t) <= 0 : this.index_.compare(t, this.rangedFilter_.getEndPost()) <= 0, !r) break;
				i = i.updateImmediateChild(t.name, t.node), n++
			}
		} else {
			let e, n, r, s;
			if (i = t.withIndex(this.index_), i = i.updatePriority(jm.EMPTY_NODE), this.reverse_) {
				s = i.getReverseIterator(this.index_), e = this.rangedFilter_.getEndPost(), n = this.rangedFilter_.getStartPost();
				const t = this.index_.getCompare();
				r = (e, n) => t(n, e)
			} else s = i.getIterator(this.index_), e = this.rangedFilter_.getStartPost(), n = this.rangedFilter_.getEndPost(), r = this.index_.getCompare();
			let a = 0,
				o = !1;
			for (; s.hasNext();) {
				const t = s.getNext();
				!o && r(e, t) <= 0 && (o = !0);
				o && a < this.limit_ && r(t, n) <= 0 ? a++ : i = i.updateImmediateChild(t.name, jm.EMPTY_NODE)
			}
		}
		return this.rangedFilter_.getIndexedFilter().updateFullNode(e, i, n)
	}
	updatePriority(e, t) {
		return e
	}
	filtersNodes() {
		return !0
	}
	getIndexedFilter() {
		return this.rangedFilter_.getIndexedFilter()
	}
	getIndex() {
		return this.index_
	}
	fullLimitUpdateChild_(e, t, n, i, r) {
		let s;
		if (this.reverse_) {
			const e = this.index_.getCompare();
			s = (t, n) => e(n, t)
		} else s = this.index_.getCompare();
		const a = e;
		$d(a.numChildren() === this.limit_, "");
		const o = new bm(t, n),
			l = this.reverse_ ? a.getFirstChild(this.index_) : a.getLastChild(this.index_),
			c = this.rangedFilter_.matches(o);
		if (a.hasChild(t)) {
			const e = a.getImmediateChild(t);
			let u = i.getChildAfterChild(this.index_, l, this.reverse_);
			for (; null != u && (u.name === t || a.hasChild(u.name));) u = i.getChildAfterChild(this.index_, u, this.reverse_);
			const h = null == u ? 1 : s(u, o);
			if (c && !n.isEmpty() && h >= 0) return null != r && r.trackChildChange(ng(t, n, e)), a.updateImmediateChild(t, n); {
				null != r && r.trackChildChange(tg(t, e));
				const n = a.updateImmediateChild(t, jm.EMPTY_NODE);
				return null != u && this.rangedFilter_.matches(u) ? (null != r && r.trackChildChange(eg(u.name, u.node)), n.updateImmediateChild(u.name, u.node)) : n
			}
		}
		return n.isEmpty() ? e : c && s(l, o) >= 0 ? (null != r && (r.trackChildChange(tg(l.name, l.node)), r.trackChildChange(eg(t, n))), a.updateImmediateChild(t, n).updateImmediateChild(l.name, jm.EMPTY_NODE)) : e
	}
}
class ag {
	constructor() {
		this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = zm
	}
	hasStart() {
		return this.startSet_
	}
	hasStartAfter() {
		return this.startAfterSet_
	}
	hasEndBefore() {
		return this.endBeforeSet_
	}
	isViewFromLeft() {
		return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_
	}
	getIndexStartValue() {
		return $d(this.startSet_, "Only valid if start has been set"), this.indexStartValue_
	}
	getIndexStartName() {
		return $d(this.startSet_, "Only valid if start has been set"), this.startNameSet_ ? this.indexStartName_ : Mf
	}
	hasEnd() {
		return this.endSet_
	}
	getIndexEndValue() {
		return $d(this.endSet_, "Only valid if end has been set"), this.indexEndValue_
	}
	getIndexEndName() {
		return $d(this.endSet_, "Only valid if end has been set"), this.endNameSet_ ? this.indexEndName_ : Tf
	}
	hasLimit() {
		return this.limitSet_
	}
	hasAnchoredLimit() {
		return this.limitSet_ && "" !== this.viewFrom_
	}
	getLimit() {
		return $d(this.limitSet_, "Only valid if limit has been set"), this.limit_
	}
	getIndex() {
		return this.index_
	}
	loadsAllData() {
		return !(this.startSet_ || this.endSet_ || this.limitSet_)
	}
	isDefault() {
		return this.loadsAllData() && this.index_ === zm
	}
	copy() {
		const e = new ag;
		return e.limitSet_ = this.limitSet_, e.limit_ = this.limit_, e.startSet_ = this.startSet_, e.indexStartValue_ = this.indexStartValue_, e.startNameSet_ = this.startNameSet_, e.indexStartName_ = this.indexStartName_, e.endSet_ = this.endSet_, e.indexEndValue_ = this.indexEndValue_, e.endNameSet_ = this.endNameSet_, e.indexEndName_ = this.indexEndName_, e.index_ = this.index_, e.viewFrom_ = this.viewFrom_, e
	}
}

function og(e) {
	const t = {};
	if (e.isDefault()) return t;
	let n;
	return e.index_ === zm ? n = "$priority" : e.index_ === Zm ? n = "$value" : e.index_ === Tm ? n = "$key" : ($d(e.index_ instanceof $m, "Unrecognized index type!"), n = e.index_.toString()), t.orderBy = cp(n), e.startSet_ && (t.startAt = cp(e.indexStartValue_), e.startNameSet_ && (t.startAt += "," + cp(e.indexStartName_))), e.endSet_ && (t.endAt = cp(e.indexEndValue_), e.endNameSet_ && (t.endAt += "," + cp(e.indexEndName_))), e.limitSet_ && (e.isViewFromLeft() ? t.limitToFirst = e.limit_ : t.limitToLast = e.limit_), t
}

function lg(e) {
	const t = {};
	if (e.startSet_ && (t.sp = e.indexStartValue_, e.startNameSet_ && (t.sn = e.indexStartName_)), e.endSet_ && (t.ep = e.indexEndValue_, e.endNameSet_ && (t.en = e.indexEndName_)), e.limitSet_) {
		t.l = e.limit_;
		let n = e.viewFrom_;
		"" === n && (n = e.isViewFromLeft() ? "l" : "r"), t.vf = n
	}
	return e.index_ !== zm && (t.i = e.index_.toString()), t
}
class cg extends em {
	constructor(e, t, n, i) {
		super(), this.repoInfo_ = e, this.onDataUpdate_ = t, this.authTokenProvider_ = n, this.appCheckTokenProvider_ = i, this.log_ = yf("p:rest:"), this.listens_ = {}
	}
	reportStats(e) {
		throw new Error("Method not implemented.")
	}
	static getListenId_(e, t) {
		return void 0 !== t ? "tag$" + t : ($d(e._queryParams.isDefault(), "should have a tag if it's not a default query."), e._path.toString())
	}
	listen(e, t, n, i) {
		const r = e._path.toString();
		this.log_("Listen called for " + r + " " + e._queryIdentifier);
		const s = cg.getListenId_(e, n),
			a = {};
		this.listens_[s] = a;
		const o = og(e._queryParams);
		this.restRequest_(r + ".json", o, ((e, t) => {
			let o = t;
			if (404 === e && (o = null, e = null), null === e && this.onDataUpdate_(r, o, !1, n), dp(this.listens_, s) === a) {
				let t;
				t = e ? 401 === e ? "permission_denied" : "rest_error:" + e : "ok", i(t, null)
			}
		}))
	}
	unlisten(e, t) {
		const n = cg.getListenId_(e, t);
		delete this.listens_[n]
	}
	get(e) {
		const t = og(e._queryParams),
			n = e._path.toString(),
			i = new np;
		return this.restRequest_(n + ".json", t, ((e, t) => {
			let r = t;
			404 === e && (r = null, e = null), null === e ? (this.onDataUpdate_(n, r, !1, null), i.resolve(r)) : i.reject(new Error(r))
		})), i.promise
	}
	refreshAuthToken(e) {}
	restRequest_(e, t = {}, n) {
		return t.format = "export", Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then((([i, r]) => {
			i && i.accessToken && (t.auth = i.accessToken), r && r.token && (t.ac = r.token);
			const s = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + e + "?ns=" + this.repoInfo_.namespace + function(e) {
				const t = [];
				for (const [n, i] of Object.entries(e)) Array.isArray(i) ? i.forEach((e => {
					t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e))
				})) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(i));
				return t.length ? "&" + t.join("&") : ""
			}(t);
			this.log_("Sending REST request for " + s);
			const a = new XMLHttpRequest;
			a.onreadystatechange = () => {
				if (n && 4 === a.readyState) {
					this.log_("REST Response for " + s + " received. status:", a.status, "response:", a.responseText);
					let t = null;
					if (a.status >= 200 && a.status < 300) {
						try {
							t = lp(a.responseText)
						} catch (e) {
							wf("Failed to parse JSON response for " + s + ": " + a.responseText)
						}
						n(null, t)
					} else 401 !== a.status && 404 !== a.status && wf("Got unsuccessful REST response for " + s + " Status: " + a.status), n(a.status);
					n = null
				}
			}, a.open("GET", s, !0), a.send()
		}))
	}
}
class ug {
	constructor() {
		this.rootNode_ = jm.EMPTY_NODE
	}
	getNode(e) {
		return this.rootNode_.getChild(e)
	}
	updateSnapshot(e, t) {
		this.rootNode_ = this.rootNode_.updateChild(e, t)
	}
}

function hg() {
	return {
		value: null,
		children: new Map
	}
}

function dg(e, t, n) {
	if (dm(t)) e.value = n, e.children.clear();
	else if (null !== e.value) e.value = e.value.updateChild(t, n);
	else {
		const i = sm(t);
		e.children.has(i) || e.children.set(i, hg());
		dg(e.children.get(i), t = om(t), n)
	}
}

function pg(e, t, n) {
	null !== e.value ? n(t, e.value) : function(e, t) {
		e.children.forEach(((e, n) => {
			t(n, e)
		}))
	}(e, ((e, i) => {
		pg(i, new im(t.toString() + "/" + e), n)
	}))
}
class fg {
	constructor(e) {
		this.collection_ = e, this.last_ = null
	}
	get() {
		const e = this.collection_.get(),
			t = Object.assign({}, e);
		return this.last_ && If(this.last_, ((e, n) => {
			t[e] = t[e] - n
		})), this.last_ = e, t
	}
}
class mg {
	constructor(e, t) {
		this.server_ = t, this.statsToReport_ = {}, this.statsListener_ = new fg(e);
		const n = 1e4 + 2e4 * Math.random();
		Of(this.reportStats_.bind(this), Math.floor(n))
	}
	reportStats_() {
		const e = this.statsListener_.get(),
			t = {};
		let n = !1;
		If(e, ((e, i) => {
			i > 0 && hp(this.statsToReport_, e) && (t[e] = i, n = !0)
		})), n && this.server_.reportStats(t), Of(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5))
	}
}
var gg, vg;

function _g(e) {
	return {
		fromUser: !1,
		fromServer: !0,
		queryId: e,
		tagged: !0
	}
}(vg = gg || (gg = {}))[vg.OVERWRITE = 0] = "OVERWRITE", vg[vg.MERGE = 1] = "MERGE", vg[vg.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", vg[vg.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE";
class yg {
	constructor(e, t, n) {
		this.path = e, this.affectedTree = t, this.revert = n, this.type = gg.ACK_USER_WRITE, this.source = {
			fromUser: !0,
			fromServer: !1,
			queryId: null,
			tagged: !1
		}
	}
	operationForChild(e) {
		if (dm(this.path)) {
			if (null != this.affectedTree.value) return $d(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this; {
				const t = this.affectedTree.subtree(new im(e));
				return new yg(rm(), t, this.revert)
			}
		}
		return $d(sm(this.path) === e, "operationForChild called for unrelated child."), new yg(om(this.path), this.affectedTree, this.revert)
	}
}
class xg {
	constructor(e, t) {
		this.source = e, this.path = t, this.type = gg.LISTEN_COMPLETE
	}
	operationForChild(e) {
		return dm(this.path) ? new xg(this.source, rm()) : new xg(this.source, om(this.path))
	}
}
class bg {
	constructor(e, t, n) {
		this.source = e, this.path = t, this.snap = n, this.type = gg.OVERWRITE
	}
	operationForChild(e) {
		return dm(this.path) ? new bg(this.source, rm(), this.snap.getImmediateChild(e)) : new bg(this.source, om(this.path), this.snap)
	}
}
class wg {
	constructor(e, t, n) {
		this.source = e, this.path = t, this.children = n, this.type = gg.MERGE
	}
	operationForChild(e) {
		if (dm(this.path)) {
			const t = this.children.subtree(new im(e));
			return t.isEmpty() ? null : t.value ? new bg(this.source, rm(), t.value) : new wg(this.source, rm(), t)
		}
		return $d(sm(this.path) === e, "Can't get a merge for a child not on the path of the operation"), new wg(this.source, om(this.path), this.children)
	}
	toString() {
		return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")"
	}
}
class Sg {
	constructor(e, t, n) {
		this.node_ = e, this.fullyInitialized_ = t, this.filtered_ = n
	}
	isFullyInitialized() {
		return this.fullyInitialized_
	}
	isFiltered() {
		return this.filtered_
	}
	isCompleteForPath(e) {
		if (dm(e)) return this.isFullyInitialized() && !this.filtered_;
		const t = sm(e);
		return this.isCompleteForChild(t)
	}
	isCompleteForChild(e) {
		return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(e)
	}
	getNode() {
		return this.node_
	}
}
class Mg {
	constructor(e) {
		this.query_ = e, this.index_ = this.query_._queryParams.getIndex()
	}
}

function Tg(e, t, n, i, r, s) {
	const a = i.filter((e => e.type === n));
	a.sort(((t, n) => function(e, t, n) {
		if (null == t.childName || null == n.childName) throw Zd("Should only compare child_ events.");
		const i = new bm(t.childName, t.snapshotNode),
			r = new bm(n.childName, n.snapshotNode);
		return e.index_.compare(i, r)
	}(e, t, n))), a.forEach((n => {
		const i = function(e, t, n) {
			return "value" === t.type || "child_removed" === t.type || (t.prevName = n.getPredecessorChildName(t.childName, t.snapshotNode, e.index_)), t
		}(e, n, s);
		r.forEach((r => {
			r.respondsTo(n.type) && t.push(r.createEvent(i, e.query_))
		}))
	}))
}

function Cg(e, t) {
	return {
		eventCache: e,
		serverCache: t
	}
}

function Eg(e, t, n, i) {
	return Cg(new Sg(t, n, i), e.serverCache)
}

function Ag(e, t, n, i) {
	return Cg(e.eventCache, new Sg(t, n, i))
}

function Pg(e) {
	return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null
}

function Lg(e) {
	return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null
}
let Ig;
class Dg {
	constructor(e, t = (() => (Ig || (Ig = new Am(Ef)), Ig))()) {
		this.value = e, this.children = t
	}
	static fromObject(e) {
		let t = new Dg(null);
		return If(e, ((e, n) => {
			t = t.set(new im(e), n)
		})), t
	}
	isEmpty() {
		return null === this.value && this.children.isEmpty()
	}
	findRootMostMatchingPathAndValue(e, t) {
		if (null != this.value && t(this.value)) return {
			path: rm(),
			value: this.value
		};
		if (dm(e)) return null; {
			const n = sm(e),
				i = this.children.get(n);
			if (null !== i) {
				const r = i.findRootMostMatchingPathAndValue(om(e), t);
				if (null != r) {
					return {
						path: hm(new im(n), r.path),
						value: r.value
					}
				}
				return null
			}
			return null
		}
	}
	findRootMostValueAndPath(e) {
		return this.findRootMostMatchingPathAndValue(e, (() => !0))
	}
	subtree(e) {
		if (dm(e)) return this; {
			const t = sm(e),
				n = this.children.get(t);
			return null !== n ? n.subtree(om(e)) : new Dg(null)
		}
	}
	set(e, t) {
		if (dm(e)) return new Dg(t, this.children); {
			const n = sm(e),
				i = (this.children.get(n) || new Dg(null)).set(om(e), t),
				r = this.children.insert(n, i);
			return new Dg(this.value, r)
		}
	}
	remove(e) {
		if (dm(e)) return this.children.isEmpty() ? new Dg(null) : new Dg(null, this.children); {
			const t = sm(e),
				n = this.children.get(t);
			if (n) {
				const i = n.remove(om(e));
				let r;
				return r = i.isEmpty() ? this.children.remove(t) : this.children.insert(t, i), null === this.value && r.isEmpty() ? new Dg(null) : new Dg(this.value, r)
			}
			return this
		}
	}
	get(e) {
		if (dm(e)) return this.value; {
			const t = sm(e),
				n = this.children.get(t);
			return n ? n.get(om(e)) : null
		}
	}
	setTree(e, t) {
		if (dm(e)) return t; {
			const n = sm(e),
				i = (this.children.get(n) || new Dg(null)).setTree(om(e), t);
			let r;
			return r = i.isEmpty() ? this.children.remove(n) : this.children.insert(n, i), new Dg(this.value, r)
		}
	}
	fold(e) {
		return this.fold_(rm(), e)
	}
	fold_(e, t) {
		const n = {};
		return this.children.inorderTraversal(((i, r) => {
			n[i] = r.fold_(hm(e, i), t)
		})), t(e, this.value, n)
	}
	findOnPath(e, t) {
		return this.findOnPath_(e, rm(), t)
	}
	findOnPath_(e, t, n) {
		const i = !!this.value && n(t, this.value);
		if (i) return i;
		if (dm(e)) return null; {
			const i = sm(e),
				r = this.children.get(i);
			return r ? r.findOnPath_(om(e), hm(t, i), n) : null
		}
	}
	foreachOnPath(e, t) {
		return this.foreachOnPath_(e, rm(), t)
	}
	foreachOnPath_(e, t, n) {
		if (dm(e)) return this; {
			this.value && n(t, this.value);
			const i = sm(e),
				r = this.children.get(i);
			return r ? r.foreachOnPath_(om(e), hm(t, i), n) : new Dg(null)
		}
	}
	foreach(e) {
		this.foreach_(rm(), e)
	}
	foreach_(e, t) {
		this.children.inorderTraversal(((n, i) => {
			i.foreach_(hm(e, n), t)
		})), this.value && t(e, this.value)
	}
	foreachChild(e) {
		this.children.inorderTraversal(((t, n) => {
			n.value && e(t, n.value)
		}))
	}
}
class Rg {
	constructor(e) {
		this.writeTree_ = e
	}
	static empty() {
		return new Rg(new Dg(null))
	}
}

function kg(e, t, n) {
	if (dm(t)) return new Rg(new Dg(n)); {
		const i = e.writeTree_.findRootMostValueAndPath(t);
		if (null != i) {
			const r = i.path;
			let s = i.value;
			const a = pm(r, t);
			return s = s.updateChild(a, n), new Rg(e.writeTree_.set(r, s))
		} {
			const i = new Dg(n),
				r = e.writeTree_.setTree(t, i);
			return new Rg(r)
		}
	}
}

function Ng(e, t, n) {
	let i = e;
	return If(n, ((e, n) => {
		i = kg(i, hm(t, e), n)
	})), i
}

function Og(e, t) {
	if (dm(t)) return Rg.empty(); {
		const n = e.writeTree_.setTree(t, new Dg(null));
		return new Rg(n)
	}
}

function Fg(e, t) {
	return null != zg(e, t)
}

function zg(e, t) {
	const n = e.writeTree_.findRootMostValueAndPath(t);
	return null != n ? e.writeTree_.get(n.path).getChild(pm(n.path, t)) : null
}

function Ug(e) {
	const t = [],
		n = e.writeTree_.value;
	return null != n ? n.isLeafNode() || n.forEachChild(zm, ((e, n) => {
		t.push(new bm(e, n))
	})) : e.writeTree_.children.inorderTraversal(((e, n) => {
		null != n.value && t.push(new bm(e, n.value))
	})), t
}

function Bg(e, t) {
	if (dm(t)) return e; {
		const n = zg(e, t);
		return new Rg(null != n ? new Dg(n) : e.writeTree_.subtree(t))
	}
}

function Vg(e) {
	return e.writeTree_.isEmpty()
}

function Hg(e, t) {
	return Gg(rm(), e.writeTree_, t)
}

function Gg(e, t, n) {
	if (null != t.value) return n.updateChild(e, t.value); {
		let i = null;
		return t.children.inorderTraversal(((t, r) => {
			".priority" === t ? ($d(null !== r.value, "Priority writes must always be leaf nodes"), i = r.value) : n = Gg(hm(e, t), r, n)
		})), n.getChild(e).isEmpty() || null === i || (n = n.updateChild(hm(e, ".priority"), i)), n
	}
}

function Wg(e, t) {
	return iv(t, e)
}

function qg(e, t) {
	const n = e.allWrites.findIndex((e => e.writeId === t));
	$d(n >= 0, "removeWrite called with nonexistent writeId.");
	const i = e.allWrites[n];
	e.allWrites.splice(n, 1);
	let r = i.visible,
		s = !1,
		a = e.allWrites.length - 1;
	for (; r && a >= 0;) {
		const t = e.allWrites[a];
		t.visible && (a >= n && jg(t, i.path) ? r = !1 : mm(i.path, t.path) && (s = !0)), a--
	}
	if (r) {
		if (s) return function(e) {
			e.visibleWrites = Xg(e.allWrites, Yg, rm()), e.allWrites.length > 0 ? e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId : e.lastWriteId = -1
		}(e), !0;
		if (i.snap) e.visibleWrites = Og(e.visibleWrites, i.path);
		else {
			If(i.children, (t => {
				e.visibleWrites = Og(e.visibleWrites, hm(i.path, t))
			}))
		}
		return !0
	}
	return !1
}

function jg(e, t) {
	if (e.snap) return mm(e.path, t);
	for (const n in e.children)
		if (e.children.hasOwnProperty(n) && mm(hm(e.path, n), t)) return !0;
	return !1
}

function Yg(e) {
	return e.visible
}

function Xg(e, t, n) {
	let i = Rg.empty();
	for (let r = 0; r < e.length; ++r) {
		const s = e[r];
		if (t(s)) {
			const e = s.path;
			let t;
			if (s.snap) mm(n, e) ? (t = pm(n, e), i = kg(i, t, s.snap)) : mm(e, n) && (t = pm(e, n), i = kg(i, rm(), s.snap.getChild(t)));
			else {
				if (!s.children) throw Zd("WriteRecord should have .snap or .children");
				if (mm(n, e)) t = pm(n, e), i = Ng(i, t, s.children);
				else if (mm(e, n))
					if (t = pm(e, n), dm(t)) i = Ng(i, rm(), s.children);
					else {
						const e = dp(s.children, sm(t));
						if (e) {
							const n = e.getChild(om(t));
							i = kg(i, rm(), n)
						}
					}
			}
		}
	}
	return i
}

function $g(e, t, n, i, r) {
	if (i || r) {
		const s = Bg(e.visibleWrites, t);
		if (!r && Vg(s)) return n;
		if (r || null != n || Fg(s, rm())) {
			const s = function(e) {
				return (e.visible || r) && (!i || !~i.indexOf(e.writeId)) && (mm(e.path, t) || mm(t, e.path))
			};
			return Hg(Xg(e.allWrites, s, t), n || jm.EMPTY_NODE)
		}
		return null
	} {
		const i = zg(e.visibleWrites, t);
		if (null != i) return i; {
			const i = Bg(e.visibleWrites, t);
			if (Vg(i)) return n;
			if (null != n || Fg(i, rm())) {
				return Hg(i, n || jm.EMPTY_NODE)
			}
			return null
		}
	}
}

function Zg(e, t, n, i) {
	return $g(e.writeTree, e.treePath, t, n, i)
}

function Kg(e, t) {
	return function(e, t, n) {
		let i = jm.EMPTY_NODE;
		const r = zg(e.visibleWrites, t);
		if (r) return r.isLeafNode() || r.forEachChild(zm, ((e, t) => {
			i = i.updateImmediateChild(e, t)
		})), i;
		if (n) {
			const r = Bg(e.visibleWrites, t);
			return n.forEachChild(zm, ((e, t) => {
				const n = Hg(Bg(r, new im(e)), t);
				i = i.updateImmediateChild(e, n)
			})), Ug(r).forEach((e => {
				i = i.updateImmediateChild(e.name, e.node)
			})), i
		}
		return Ug(Bg(e.visibleWrites, t)).forEach((e => {
			i = i.updateImmediateChild(e.name, e.node)
		})), i
	}(e.writeTree, e.treePath, t)
}

function Jg(e, t, n, i) {
	return function(e, t, n, i, r) {
		$d(i || r, "Either existingEventSnap or existingServerSnap must exist");
		const s = hm(t, n);
		if (Fg(e.visibleWrites, s)) return null; {
			const t = Bg(e.visibleWrites, s);
			return Vg(t) ? r.getChild(n) : Hg(t, r.getChild(n))
		}
	}(e.writeTree, e.treePath, t, n, i)
}

function Qg(e, t) {
	return function(e, t) {
		return zg(e.visibleWrites, t)
	}(e.writeTree, hm(e.treePath, t))
}

function ev(e, t, n, i, r, s) {
	return function(e, t, n, i, r, s, a) {
		let o;
		const l = Bg(e.visibleWrites, t),
			c = zg(l, rm());
		if (null != c) o = c;
		else {
			if (null == n) return [];
			o = Hg(l, n)
		}
		if (o = o.withIndex(a), o.isEmpty() || o.isLeafNode()) return []; {
			const e = [],
				t = a.getCompare(),
				n = s ? o.getReverseIteratorFrom(i, a) : o.getIteratorFrom(i, a);
			let l = n.getNext();
			for (; l && e.length < r;) 0 !== t(l, i) && e.push(l), l = n.getNext();
			return e
		}
	}(e.writeTree, e.treePath, t, n, i, r, s)
}

function tv(e, t, n) {
	return function(e, t, n, i) {
		const r = hm(t, n),
			s = zg(e.visibleWrites, r);
		if (null != s) return s;
		if (i.isCompleteForChild(n)) return Hg(Bg(e.visibleWrites, r), i.getNode().getImmediateChild(n));
		return null
	}(e.writeTree, e.treePath, t, n)
}

function nv(e, t) {
	return iv(hm(e.treePath, t), e.writeTree)
}

function iv(e, t) {
	return {
		treePath: e,
		writeTree: t
	}
}
class rv {
	constructor() {
		this.changeMap = new Map
	}
	trackChildChange(e) {
		const t = e.type,
			n = e.childName;
		$d("child_added" === t || "child_changed" === t || "child_removed" === t, "Only child changes supported for tracking"), $d(".priority" !== n, "Only non-priority child changes can be tracked.");
		const i = this.changeMap.get(n);
		if (i) {
			const r = i.type;
			if ("child_added" === t && "child_removed" === r) this.changeMap.set(n, ng(n, e.snapshotNode, i.snapshotNode));
			else if ("child_removed" === t && "child_added" === r) this.changeMap.delete(n);
			else if ("child_removed" === t && "child_changed" === r) this.changeMap.set(n, tg(n, i.oldSnap));
			else if ("child_changed" === t && "child_added" === r) this.changeMap.set(n, eg(n, e.snapshotNode));
			else {
				if ("child_changed" !== t || "child_changed" !== r) throw Zd("Illegal combination of changes: " + e + " occurred after " + i);
				this.changeMap.set(n, ng(n, e.snapshotNode, i.oldSnap))
			}
		} else this.changeMap.set(n, e)
	}
	getChanges() {
		return Array.from(this.changeMap.values())
	}
}
const sv = new class {
	getCompleteChild(e) {
		return null
	}
	getChildAfterChild(e, t, n) {
		return null
	}
};
class av {
	constructor(e, t, n = null) {
		this.writes_ = e, this.viewCache_ = t, this.optCompleteServerCache_ = n
	}
	getCompleteChild(e) {
		const t = this.viewCache_.eventCache;
		if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e); {
			const t = null != this.optCompleteServerCache_ ? new Sg(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache;
			return tv(this.writes_, e, t)
		}
	}
	getChildAfterChild(e, t, n) {
		const i = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : Lg(this.viewCache_),
			r = ev(this.writes_, i, t, 1, n, e);
		return 0 === r.length ? null : r[0]
	}
}

function ov(e, t, n, i, r) {
	const s = new rv;
	let a, o;
	if (n.type === gg.OVERWRITE) {
		const l = n;
		l.source.fromUser ? a = uv(e, t, l.path, l.snap, i, r, s) : ($d(l.source.fromServer, "Unknown source."), o = l.source.tagged || t.serverCache.isFiltered() && !dm(l.path), a = cv(e, t, l.path, l.snap, i, r, o, s))
	} else if (n.type === gg.MERGE) {
		const l = n;
		l.source.fromUser ? a = function(e, t, n, i, r, s, a) {
			let o = t;
			return i.foreach(((i, l) => {
				const c = hm(n, i);
				hv(t, sm(c)) && (o = uv(e, o, c, l, r, s, a))
			})), i.foreach(((i, l) => {
				const c = hm(n, i);
				hv(t, sm(c)) || (o = uv(e, o, c, l, r, s, a))
			})), o
		}(e, t, l.path, l.children, i, r, s) : ($d(l.source.fromServer, "Unknown source."), o = l.source.tagged || t.serverCache.isFiltered(), a = pv(e, t, l.path, l.children, i, r, o, s))
	} else if (n.type === gg.ACK_USER_WRITE) {
		const o = n;
		a = o.revert ? function(e, t, n, i, r, s) {
			let a;
			if (null != Qg(i, n)) return t; {
				const o = new av(i, t, r),
					l = t.eventCache.getNode();
				let c;
				if (dm(n) || ".priority" === sm(n)) {
					let n;
					if (t.serverCache.isFullyInitialized()) n = Zg(i, Lg(t));
					else {
						const e = t.serverCache.getNode();
						$d(e instanceof jm, "serverChildren would be complete if leaf node"), n = Kg(i, e)
					}
					n = n, c = e.filter.updateFullNode(l, n, s)
				} else {
					const r = sm(n);
					let u = tv(i, r, t.serverCache);
					null == u && t.serverCache.isCompleteForChild(r) && (u = l.getImmediateChild(r)), c = null != u ? e.filter.updateChild(l, r, u, om(n), o, s) : t.eventCache.getNode().hasChild(r) ? e.filter.updateChild(l, r, jm.EMPTY_NODE, om(n), o, s) : l, c.isEmpty() && t.serverCache.isFullyInitialized() && (a = Zg(i, Lg(t)), a.isLeafNode() && (c = e.filter.updateFullNode(c, a, s)))
				}
				return a = t.serverCache.isFullyInitialized() || null != Qg(i, rm()), Eg(t, c, a, e.filter.filtersNodes())
			}
		}(e, t, o.path, i, r, s) : function(e, t, n, i, r, s, a) {
			if (null != Qg(r, n)) return t;
			const o = t.serverCache.isFiltered(),
				l = t.serverCache;
			if (null != i.value) {
				if (dm(n) && l.isFullyInitialized() || l.isCompleteForPath(n)) return cv(e, t, n, l.getNode().getChild(n), r, s, o, a);
				if (dm(n)) {
					let i = new Dg(null);
					return l.getNode().forEachChild(Tm, ((e, t) => {
						i = i.set(new im(e), t)
					})), pv(e, t, n, i, r, s, o, a)
				}
				return t
			} {
				let c = new Dg(null);
				return i.foreach(((e, t) => {
					const i = hm(n, e);
					l.isCompleteForPath(i) && (c = c.set(e, l.getNode().getChild(i)))
				})), pv(e, t, n, c, r, s, o, a)
			}
		}(e, t, o.path, o.affectedTree, i, r, s)
	} else {
		if (n.type !== gg.LISTEN_COMPLETE) throw Zd("Unknown operation type: " + n.type);
		a = function(e, t, n, i, r) {
			const s = t.serverCache,
				a = Ag(t, s.getNode(), s.isFullyInitialized() || dm(n), s.isFiltered());
			return lv(e, a, n, i, sv, r)
		}(e, t, n.path, i, s)
	}
	const l = s.getChanges();
	return function(e, t, n) {
		const i = t.eventCache;
		if (i.isFullyInitialized()) {
			const r = i.getNode().isLeafNode() || i.getNode().isEmpty(),
				s = Pg(e);
			(n.length > 0 || !e.eventCache.isFullyInitialized() || r && !i.getNode().equals(s) || !i.getNode().getPriority().equals(s.getPriority())) && n.push(Qm(Pg(t)))
		}
	}(t, a, l), {
		viewCache: a,
		changes: l
	}
}

function lv(e, t, n, i, r, s) {
	const a = t.eventCache;
	if (null != Qg(i, n)) return t; {
		let o, l;
		if (dm(n))
			if ($d(t.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), t.serverCache.isFiltered()) {
				const n = Lg(t),
					r = Kg(i, n instanceof jm ? n : jm.EMPTY_NODE);
				o = e.filter.updateFullNode(t.eventCache.getNode(), r, s)
			} else {
				const n = Zg(i, Lg(t));
				o = e.filter.updateFullNode(t.eventCache.getNode(), n, s)
			}
		else {
			const c = sm(n);
			if (".priority" === c) {
				$d(1 === am(n), "Can't have a priority with additional path components");
				const r = a.getNode();
				l = t.serverCache.getNode();
				const s = Jg(i, n, r, l);
				o = null != s ? e.filter.updatePriority(r, s) : a.getNode()
			} else {
				const u = om(n);
				let h;
				if (a.isCompleteForChild(c)) {
					l = t.serverCache.getNode();
					const e = Jg(i, n, a.getNode(), l);
					h = null != e ? a.getNode().getImmediateChild(c).updateChild(u, e) : a.getNode().getImmediateChild(c)
				} else h = tv(i, c, t.serverCache);
				o = null != h ? e.filter.updateChild(a.getNode(), c, h, u, r, s) : a.getNode()
			}
		}
		return Eg(t, o, a.isFullyInitialized() || dm(n), e.filter.filtersNodes())
	}
}

function cv(e, t, n, i, r, s, a, o) {
	const l = t.serverCache;
	let c;
	const u = a ? e.filter : e.filter.getIndexedFilter();
	if (dm(n)) c = u.updateFullNode(l.getNode(), i, null);
	else if (u.filtersNodes() && !l.isFiltered()) {
		const e = l.getNode().updateChild(n, i);
		c = u.updateFullNode(l.getNode(), e, null)
	} else {
		const e = sm(n);
		if (!l.isCompleteForPath(n) && am(n) > 1) return t;
		const r = om(n),
			s = l.getNode().getImmediateChild(e).updateChild(r, i);
		c = ".priority" === e ? u.updatePriority(l.getNode(), s) : u.updateChild(l.getNode(), e, s, r, sv, null)
	}
	const h = Ag(t, c, l.isFullyInitialized() || dm(n), u.filtersNodes());
	return lv(e, h, n, r, new av(r, h, s), o)
}

function uv(e, t, n, i, r, s, a) {
	const o = t.eventCache;
	let l, c;
	const u = new av(r, t, s);
	if (dm(n)) c = e.filter.updateFullNode(t.eventCache.getNode(), i, a), l = Eg(t, c, !0, e.filter.filtersNodes());
	else {
		const r = sm(n);
		if (".priority" === r) c = e.filter.updatePriority(t.eventCache.getNode(), i), l = Eg(t, c, o.isFullyInitialized(), o.isFiltered());
		else {
			const s = om(n),
				c = o.getNode().getImmediateChild(r);
			let h;
			if (dm(s)) h = i;
			else {
				const e = u.getCompleteChild(r);
				h = null != e ? ".priority" === lm(s) && e.getChild(um(s)).isEmpty() ? e : e.updateChild(s, i) : jm.EMPTY_NODE
			}
			if (c.equals(h)) l = t;
			else {
				l = Eg(t, e.filter.updateChild(o.getNode(), r, h, s, u, a), o.isFullyInitialized(), e.filter.filtersNodes())
			}
		}
	}
	return l
}

function hv(e, t) {
	return e.eventCache.isCompleteForChild(t)
}

function dv(e, t, n) {
	return n.foreach(((e, n) => {
		t = t.updateChild(e, n)
	})), t
}

function pv(e, t, n, i, r, s, a, o) {
	if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t;
	let l, c = t;
	l = dm(n) ? i : new Dg(null).setTree(n, i);
	const u = t.serverCache.getNode();
	return l.children.inorderTraversal(((n, i) => {
		if (u.hasChild(n)) {
			const l = dv(0, t.serverCache.getNode().getImmediateChild(n), i);
			c = cv(e, c, new im(n), l, r, s, a, o)
		}
	})), l.children.inorderTraversal(((n, i) => {
		const l = !t.serverCache.isCompleteForChild(n) && void 0 === i.value;
		if (!u.hasChild(n) && !l) {
			const l = dv(0, t.serverCache.getNode().getImmediateChild(n), i);
			c = cv(e, c, new im(n), l, r, s, a, o)
		}
	})), c
}
class fv {
	constructor(e, t) {
		this.query_ = e, this.eventRegistrations_ = [];
		const n = this.query_._queryParams,
			i = new ig(n.getIndex()),
			r = (s = n).loadsAllData() ? new ig(s.getIndex()) : s.hasLimit() ? new sg(s) : new rg(s);
		var s;
		this.processor_ = function(e) {
			return {
				filter: e
			}
		}(r);
		const a = t.serverCache,
			o = t.eventCache,
			l = i.updateFullNode(jm.EMPTY_NODE, a.getNode(), null),
			c = r.updateFullNode(jm.EMPTY_NODE, o.getNode(), null),
			u = new Sg(l, a.isFullyInitialized(), i.filtersNodes()),
			h = new Sg(c, o.isFullyInitialized(), r.filtersNodes());
		this.viewCache_ = Cg(h, u), this.eventGenerator_ = new Mg(this.query_)
	}
	get query() {
		return this.query_
	}
}

function mv(e, t) {
	const n = Lg(e.viewCache_);
	return n && (e.query._queryParams.loadsAllData() || !dm(t) && !n.getImmediateChild(sm(t)).isEmpty()) ? n.getChild(t) : null
}

function gv(e) {
	return 0 === e.eventRegistrations_.length
}

function vv(e, t, n) {
	const i = [];
	if (n) {
		$d(null == t, "A cancel should cancel all event registrations.");
		const r = e.query._path;
		e.eventRegistrations_.forEach((e => {
			const t = e.createCancelEvent(n, r);
			t && i.push(t)
		}))
	}
	if (t) {
		let n = [];
		for (let i = 0; i < e.eventRegistrations_.length; ++i) {
			const r = e.eventRegistrations_[i];
			if (r.matches(t)) {
				if (t.hasAnyCallback()) {
					n = n.concat(e.eventRegistrations_.slice(i + 1));
					break
				}
			} else n.push(r)
		}
		e.eventRegistrations_ = n
	} else e.eventRegistrations_ = [];
	return i
}

function _v(e, t, n, i) {
	t.type === gg.MERGE && null !== t.source.queryId && ($d(Lg(e.viewCache_), "We should always have a full cache before handling merges"), $d(Pg(e.viewCache_), "Missing event cache, even though we have a server cache"));
	const r = e.viewCache_,
		s = ov(e.processor_, r, t, n, i);
	var a, o;
	return a = e.processor_, o = s.viewCache, $d(o.eventCache.getNode().isIndexed(a.filter.getIndex()), "Event snap not indexed"), $d(o.serverCache.getNode().isIndexed(a.filter.getIndex()), "Server snap not indexed"), $d(s.viewCache.serverCache.isFullyInitialized() || !r.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), e.viewCache_ = s.viewCache, yv(e, s.changes, s.viewCache.eventCache.getNode(), null)
}

function yv(e, t, n, i) {
	const r = i ? [i] : e.eventRegistrations_;
	return function(e, t, n, i) {
		const r = [],
			s = [];
		return t.forEach((t => {
			var n;
			"child_changed" === t.type && e.index_.indexedValueChanged(t.oldSnap, t.snapshotNode) && s.push((n = t.childName, {
				type: "child_moved",
				snapshotNode: t.snapshotNode,
				childName: n
			}))
		})), Tg(e, r, "child_removed", t, i, n), Tg(e, r, "child_added", t, i, n), Tg(e, r, "child_moved", s, i, n), Tg(e, r, "child_changed", t, i, n), Tg(e, r, "value", t, i, n), r
	}(e.eventGenerator_, t, n, r)
}
let xv, bv;
class wv {
	constructor() {
		this.views = new Map
	}
}

function Sv(e, t, n, i) {
	const r = t.source.queryId;
	if (null !== r) {
		const s = e.views.get(r);
		return $d(null != s, "SyncTree gave us an op for an invalid query."), _v(s, t, n, i)
	} {
		let r = [];
		for (const s of e.views.values()) r = r.concat(_v(s, t, n, i));
		return r
	}
}

function Mv(e, t, n, i, r) {
	const s = t._queryIdentifier,
		a = e.views.get(s);
	if (!a) {
		let e = Zg(n, r ? i : null),
			s = !1;
		e ? s = !0 : i instanceof jm ? (e = Kg(n, i), s = !1) : (e = jm.EMPTY_NODE, s = !1);
		const a = Cg(new Sg(e, s, !1), new Sg(i, r, !1));
		return new fv(t, a)
	}
	return a
}

function Tv(e, t, n, i, r, s) {
	const a = Mv(e, t, i, r, s);
	return e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, a),
		function(e, t) {
			e.eventRegistrations_.push(t)
		}(a, n),
		function(e, t) {
			const n = e.viewCache_.eventCache,
				i = [];
			n.getNode().isLeafNode() || n.getNode().forEachChild(zm, ((e, t) => {
				i.push(eg(e, t))
			}));
			return n.isFullyInitialized() && i.push(Qm(n.getNode())), yv(e, i, n.getNode(), t)
		}(a, n)
}

function Cv(e, t, n, i) {
	const r = t._queryIdentifier,
		s = [];
	let a = [];
	const o = Iv(e);
	if ("default" === r)
		for (const [l, c] of e.views.entries()) a = a.concat(vv(c, n, i)), gv(c) && (e.views.delete(l), c.query._queryParams.loadsAllData() || s.push(c.query));
	else {
		const t = e.views.get(r);
		t && (a = a.concat(vv(t, n, i)), gv(t) && (e.views.delete(r), t.query._queryParams.loadsAllData() || s.push(t.query)))
	}
	return o && !Iv(e) && s.push(new($d(xv, "Reference.ts has not been loaded"), xv)(t._repo, t._path)), {
		removed: s,
		events: a
	}
}

function Ev(e) {
	const t = [];
	for (const n of e.views.values()) n.query._queryParams.loadsAllData() || t.push(n);
	return t
}

function Av(e, t) {
	let n = null;
	for (const i of e.views.values()) n = n || mv(i, t);
	return n
}

function Pv(e, t) {
	if (t._queryParams.loadsAllData()) return Dv(e); {
		const n = t._queryIdentifier;
		return e.views.get(n)
	}
}

function Lv(e, t) {
	return null != Pv(e, t)
}

function Iv(e) {
	return null != Dv(e)
}

function Dv(e) {
	for (const t of e.views.values())
		if (t.query._queryParams.loadsAllData()) return t;
	return null
}
let Rv = 1;
class kv {
	constructor(e) {
		this.listenProvider_ = e, this.syncPointTree_ = new Dg(null), this.pendingWriteTree_ = {
			visibleWrites: Rg.empty(),
			allWrites: [],
			lastWriteId: -1
		}, this.tagToQueryMap = new Map, this.queryToTagMap = new Map
	}
}

function Nv(e, t, n, i, r) {
	return function(e, t, n, i, r) {
		$d(i > e.lastWriteId, "Stacking an older write on top of newer ones"), void 0 === r && (r = !0), e.allWrites.push({
			path: t,
			snap: n,
			writeId: i,
			visible: r
		}), r && (e.visibleWrites = kg(e.visibleWrites, t, n)), e.lastWriteId = i
	}(e.pendingWriteTree_, t, n, i, r), r ? Hv(e, new bg({
		fromUser: !0,
		fromServer: !1,
		queryId: null,
		tagged: !1
	}, t, n)) : []
}

function Ov(e, t, n = !1) {
	const i = function(e, t) {
		for (let n = 0; n < e.allWrites.length; n++) {
			const i = e.allWrites[n];
			if (i.writeId === t) return i
		}
		return null
	}(e.pendingWriteTree_, t);
	if (qg(e.pendingWriteTree_, t)) {
		let t = new Dg(null);
		return null != i.snap ? t = t.set(rm(), !0) : If(i.children, (e => {
			t = t.set(new im(e), !0)
		})), Hv(e, new yg(i.path, t, n))
	}
	return []
}

function Fv(e, t, n) {
	return Hv(e, new bg({
		fromUser: !1,
		fromServer: !0,
		queryId: null,
		tagged: !1
	}, t, n))
}

function zv(e, t, n, i) {
	const r = t._path,
		s = e.syncPointTree_.get(r);
	let a = [];
	if (s && ("default" === t._queryIdentifier || Lv(s, t))) {
		const o = Cv(s, t, n, i);
		0 === s.views.size && (e.syncPointTree_ = e.syncPointTree_.remove(r));
		const l = o.removed;
		a = o.events;
		const c = -1 !== l.findIndex((e => e._queryParams.loadsAllData())),
			u = e.syncPointTree_.findOnPath(r, ((e, t) => Iv(t)));
		if (c && !u) {
			const t = e.syncPointTree_.subtree(r);
			if (!t.isEmpty()) {
				const n = function(e) {
					return e.fold(((e, t, n) => {
						if (t && Iv(t)) {
							return [Dv(t)]
						} {
							let e = [];
							return t && (e = Ev(t)), If(n, ((t, n) => {
								e = e.concat(n)
							})), e
						}
					}))
				}(t);
				for (let t = 0; t < n.length; ++t) {
					const i = n[t],
						r = i.query,
						s = qv(e, i);
					e.listenProvider_.startListening(Kv(r), jv(e, r), s.hashFn, s.onComplete)
				}
			}
		}
		if (!u && l.length > 0 && !i)
			if (c) {
				const n = null;
				e.listenProvider_.stopListening(Kv(t), n)
			} else l.forEach((t => {
				const n = e.queryToTagMap.get(Yv(t));
				e.listenProvider_.stopListening(Kv(t), n)
			}));
		! function(e, t) {
			for (let n = 0; n < t.length; ++n) {
				const i = t[n];
				if (!i._queryParams.loadsAllData()) {
					const t = Yv(i),
						n = e.queryToTagMap.get(t);
					e.queryToTagMap.delete(t), e.tagToQueryMap.delete(n)
				}
			}
		}(e, l)
	}
	return a
}

function Uv(e, t, n) {
	const i = t._path;
	let r = null,
		s = !1;
	e.syncPointTree_.foreachOnPath(i, ((e, t) => {
		const n = pm(e, i);
		r = r || Av(t, n), s = s || Iv(t)
	}));
	let a, o = e.syncPointTree_.get(i);
	if (o ? (s = s || Iv(o), r = r || Av(o, rm())) : (o = new wv, e.syncPointTree_ = e.syncPointTree_.set(i, o)), null != r) a = !0;
	else {
		a = !1, r = jm.EMPTY_NODE;
		e.syncPointTree_.subtree(i).foreachChild(((e, t) => {
			const n = Av(t, rm());
			n && (r = r.updateImmediateChild(e, n))
		}))
	}
	const l = Lv(o, t);
	if (!l && !t._queryParams.loadsAllData()) {
		const n = Yv(t);
		$d(!e.queryToTagMap.has(n), "View does not exist, but we have a tag");
		const i = Rv++;
		e.queryToTagMap.set(n, i), e.tagToQueryMap.set(i, n)
	}
	let c = Tv(o, t, n, Wg(e.pendingWriteTree_, i), r, a);
	if (!l && !s) {
		const n = Pv(o, t);
		c = c.concat(function(e, t, n) {
			const i = t._path,
				r = jv(e, t),
				s = qv(e, n),
				a = e.listenProvider_.startListening(Kv(t), r, s.hashFn, s.onComplete),
				o = e.syncPointTree_.subtree(i);
			if (r) $d(!Iv(o.value), "If we're adding a query, it shouldn't be shadowed");
			else {
				const t = o.fold(((e, t, n) => {
					if (!dm(e) && t && Iv(t)) return [Dv(t).query]; {
						let e = [];
						return t && (e = e.concat(Ev(t).map((e => e.query)))), If(n, ((t, n) => {
							e = e.concat(n)
						})), e
					}
				}));
				for (let n = 0; n < t.length; ++n) {
					const i = t[n];
					e.listenProvider_.stopListening(Kv(i), jv(e, i))
				}
			}
			return a
		}(e, t, n))
	}
	return c
}

function Bv(e, t, n) {
	const i = e.pendingWriteTree_,
		r = e.syncPointTree_.findOnPath(t, ((e, n) => {
			const i = Av(n, pm(e, t));
			if (i) return i
		}));
	return $g(i, t, r, n, !0)
}

function Vv(e, t) {
	const n = t._path;
	let i = null;
	e.syncPointTree_.foreachOnPath(n, ((e, t) => {
		const r = pm(e, n);
		i = i || Av(t, r)
	}));
	let r = e.syncPointTree_.get(n);
	r ? i = i || Av(r, rm()) : (r = new wv, e.syncPointTree_ = e.syncPointTree_.set(n, r));
	const s = null != i,
		a = s ? new Sg(i, !0, !1) : null;
	return function(e) {
		return Pg(e.viewCache_)
	}(Mv(r, t, Wg(e.pendingWriteTree_, t._path), s ? a.getNode() : jm.EMPTY_NODE, s))
}

function Hv(e, t) {
	return Gv(t, e.syncPointTree_, null, Wg(e.pendingWriteTree_, rm()))
}

function Gv(e, t, n, i) {
	if (dm(e.path)) return Wv(e, t, n, i); {
		const r = t.get(rm());
		null == n && null != r && (n = Av(r, rm()));
		let s = [];
		const a = sm(e.path),
			o = e.operationForChild(a),
			l = t.children.get(a);
		if (l && o) {
			const e = n ? n.getImmediateChild(a) : null,
				t = nv(i, a);
			s = s.concat(Gv(o, l, e, t))
		}
		return r && (s = s.concat(Sv(r, e, i, n))), s
	}
}

function Wv(e, t, n, i) {
	const r = t.get(rm());
	null == n && null != r && (n = Av(r, rm()));
	let s = [];
	return t.children.inorderTraversal(((t, r) => {
		const a = n ? n.getImmediateChild(t) : null,
			o = nv(i, t),
			l = e.operationForChild(t);
		l && (s = s.concat(Wv(l, r, a, o)))
	})), r && (s = s.concat(Sv(r, e, i, n))), s
}

function qv(e, t) {
	const n = t.query,
		i = jv(e, n);
	return {
		hashFn: () => {
			const e = function(e) {
				return e.viewCache_.serverCache.getNode()
			}(t) || jm.EMPTY_NODE;
			return e.hash()
		},
		onComplete: t => {
			if ("ok" === t) return i ? function(e, t, n) {
				const i = Xv(e, n);
				if (i) {
					const n = $v(i),
						r = n.path,
						s = n.queryId,
						a = pm(r, t);
					return Zv(e, r, new xg(_g(s), a))
				}
				return []
			}(e, n._path, i) : function(e, t) {
				return Hv(e, new xg({
					fromUser: !1,
					fromServer: !0,
					queryId: null,
					tagged: !1
				}, t))
			}(e, n._path); {
				const i = function(e, t) {
					let n = "Unknown Error";
					"too_big" === e ? n = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" === e ? n = "Client doesn't have permission to access the desired data." : "unavailable" === e && (n = "The service is unavailable");
					const i = new Error(e + " at " + t._path.toString() + ": " + n);
					return i.code = e.toUpperCase(), i
				}(t, n);
				return zv(e, n, null, i)
			}
		}
	}
}

function jv(e, t) {
	const n = Yv(t);
	return e.queryToTagMap.get(n)
}

function Yv(e) {
	return e._path.toString() + "$" + e._queryIdentifier
}

function Xv(e, t) {
	return e.tagToQueryMap.get(t)
}

function $v(e) {
	const t = e.indexOf("$");
	return $d(-1 !== t && t < e.length - 1, "Bad queryKey."), {
		queryId: e.substr(t + 1),
		path: new im(e.substr(0, t))
	}
}

function Zv(e, t, n) {
	const i = e.syncPointTree_.get(t);
	$d(i, "Missing sync point for query tag that we're tracking");
	return Sv(i, n, Wg(e.pendingWriteTree_, t), null)
}

function Kv(e) {
	return e._queryParams.loadsAllData() && !e._queryParams.isDefault() ? new($d(bv, "Reference.ts has not been loaded"), bv)(e._repo, e._path) : e
}
class Jv {
	constructor(e) {
		this.node_ = e
	}
	getImmediateChild(e) {
		const t = this.node_.getImmediateChild(e);
		return new Jv(t)
	}
	node() {
		return this.node_
	}
}
class Qv {
	constructor(e, t) {
		this.syncTree_ = e, this.path_ = t
	}
	getImmediateChild(e) {
		const t = hm(this.path_, e);
		return new Qv(this.syncTree_, t)
	}
	node() {
		return Bv(this.syncTree_, this.path_)
	}
}
const e_ = function(e, t, n) {
		return e && "object" == typeof e ? ($d(".sv" in e, "Unexpected leaf node or priority contents"), "string" == typeof e[".sv"] ? t_(e[".sv"], t, n) : "object" == typeof e[".sv"] ? n_(e[".sv"], t) : void $d(!1, "Unexpected server value: " + JSON.stringify(e, null, 2))) : e
	},
	t_ = function(e, t, n) {
		if ("timestamp" === e) return n.timestamp;
		$d(!1, "Unexpected server value: " + e)
	},
	n_ = function(e, t, n) {
		e.hasOwnProperty("increment") || $d(!1, "Unexpected server value: " + JSON.stringify(e, null, 2));
		const i = e.increment;
		"number" != typeof i && $d(!1, "Unexpected increment value: " + i);
		const r = t.node();
		if ($d(null != r, "Expected ChildrenNode.EMPTY_NODE for nulls"), !r.isLeafNode()) return i;
		const s = r.getValue();
		return "number" != typeof s ? i : s + i
	},
	i_ = function(e, t, n) {
		return r_(e, new Jv(t), n)
	};

function r_(e, t, n) {
	const i = e.getPriority().val(),
		r = e_(i, t.getImmediateChild(".priority"), n);
	let s;
	if (e.isLeafNode()) {
		const i = e,
			s = e_(i.getValue(), t, n);
		return s !== i.getValue() || r !== i.getPriority().val() ? new Fm(s, Xm(r)) : e
	} {
		const i = e;
		return s = i, r !== i.getPriority().val() && (s = s.updatePriority(new Fm(r))), i.forEachChild(zm, ((e, i) => {
			const r = r_(i, t.getImmediateChild(e), n);
			r !== i && (s = s.updateImmediateChild(e, r))
		})), s
	}
}
class s_ {
	constructor(e = "", t = null, n = {
		children: {},
		childCount: 0
	}) {
		this.name = e, this.parent = t, this.node = n
	}
}

function a_(e, t) {
	let n = t instanceof im ? t : new im(t),
		i = e,
		r = sm(n);
	for (; null !== r;) {
		const e = dp(i.node.children, r) || {
			children: {},
			childCount: 0
		};
		i = new s_(r, i, e), n = om(n), r = sm(n)
	}
	return i
}

function o_(e) {
	return e.node.value
}

function l_(e, t) {
	e.node.value = t, p_(e)
}

function c_(e) {
	return e.node.childCount > 0
}

function u_(e, t) {
	If(e.node.children, ((n, i) => {
		t(new s_(n, e, i))
	}))
}

function h_(e, t, n, i) {
	n && !i && t(e), u_(e, (e => {
		h_(e, t, !0, i)
	})), n && i && t(e)
}

function d_(e) {
	return new im(null === e.parent ? e.name : d_(e.parent) + "/" + e.name)
}

function p_(e) {
	null !== e.parent && function(e, t, n) {
		const i = function(e) {
				return void 0 === o_(e) && !c_(e)
			}(n),
			r = hp(e.node.children, t);
		i && r ? (delete e.node.children[t], e.node.childCount--, p_(e)) : i || r || (e.node.children[t] = n.node, e.node.childCount++, p_(e))
	}(e.parent, e.name, e)
}
const f_ = /[\[\].#$\/\u0000-\u001F\u007F]/,
	m_ = /[\[\].#$\u0000-\u001F\u007F]/,
	g_ = function(e) {
		return "string" == typeof e && 0 !== e.length && !f_.test(e)
	},
	v_ = function(e) {
		return "string" == typeof e && 0 !== e.length && !m_.test(e)
	},
	__ = function(e, t, n, i) {
		i && void 0 === t || y_(_p(e, "value"), t, n)
	},
	y_ = function(e, t, n) {
		const i = n instanceof im ? new gm(n, e) : n;
		if (void 0 === t) throw new Error(e + "contains undefined " + _m(i));
		if ("function" == typeof t) throw new Error(e + "contains a function " + _m(i) + " with contents = " + t.toString());
		if (Sf(t)) throw new Error(e + "contains " + t.toString() + " " + _m(i));
		if ("string" == typeof t && t.length > 10485760 / 3 && yp(t) > 10485760) throw new Error(e + "contains a string greater than 10485760 utf8 bytes " + _m(i) + " ('" + t.substring(0, 50) + "...')");
		if (t && "object" == typeof t) {
			let n = !1,
				r = !1;
			if (If(t, ((t, s) => {
					if (".value" === t) n = !0;
					else if (".priority" !== t && ".sv" !== t && (r = !0, !g_(t))) throw new Error(e + " contains an invalid key (" + t + ") " + _m(i) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
					var a, o;
					o = t, (a = i).parts_.length > 0 && (a.byteLength_ += 1), a.parts_.push(o), a.byteLength_ += yp(o), vm(a), y_(e, s, i),
						function(e) {
							const t = e.parts_.pop();
							e.byteLength_ -= yp(t), e.parts_.length > 0 && (e.byteLength_ -= 1)
						}(i)
				})), n && r) throw new Error(e + ' contains ".value" child ' + _m(i) + " in addition to actual children.")
		}
	},
	x_ = function(e, t, n, i) {
		if (!(i && void 0 === n || v_(n))) throw new Error(_p(e, t) + 'was an invalid path = "' + n + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"')
	},
	b_ = function(e, t) {
		if (".info" === sm(t)) throw new Error(e + " failed = Can't modify data under /.info/")
	},
	w_ = function(e, t) {
		const n = t.path.toString();
		if ("string" != typeof t.repoInfo.host || 0 === t.repoInfo.host.length || !g_(t.repoInfo.namespace) && "localhost" !== t.repoInfo.host.split(":")[0] || 0 !== n.length && ! function(e) {
				return e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), v_(e)
			}(n)) throw new Error(_p(e, "url") + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".')
	};
class S_ {
	constructor() {
		this.eventLists_ = [], this.recursionDepth_ = 0
	}
}

function M_(e, t) {
	let n = null;
	for (let i = 0; i < t.length; i++) {
		const r = t[i],
			s = r.getPath();
		null === n || fm(s, n.path) || (e.eventLists_.push(n), n = null), null === n && (n = {
			events: [],
			path: s
		}), n.events.push(r)
	}
	n && e.eventLists_.push(n)
}

function T_(e, t, n) {
	M_(e, n), E_(e, (e => fm(e, t)))
}

function C_(e, t, n) {
	M_(e, n), E_(e, (e => mm(e, t) || mm(t, e)))
}

function E_(e, t) {
	e.recursionDepth_++;
	let n = !0;
	for (let i = 0; i < e.eventLists_.length; i++) {
		const r = e.eventLists_[i];
		if (r) {
			t(r.path) ? (A_(e.eventLists_[i]), e.eventLists_[i] = null) : n = !1
		}
	}
	n && (e.eventLists_ = []), e.recursionDepth_--
}

function A_(e) {
	for (let t = 0; t < e.events.length; t++) {
		const n = e.events[t];
		if (null !== n) {
			e.events[t] = null;
			const i = n.getEventRunner();
			gf && _f("event: " + n.toString()), Nf(i)
		}
	}
}
class P_ {
	constructor(e, t, n, i) {
		this.repoInfo_ = e, this.forceRestClient_ = t, this.authTokenProvider_ = n, this.appCheckProvider_ = i, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new S_, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = hg(), this.transactionQueueTree_ = new s_, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString()
	}
	toString() {
		return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host
	}
}

function L_(e, t, n) {
	if (e.stats_ = jf(e.repoInfo_), e.forceRestClient_ || ("object" == typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0) e.server_ = new cg(e.repoInfo_, ((t, n, i, r) => {
		R_(e, t, n, i, r)
	}), e.authTokenProvider_, e.appCheckProvider_), setTimeout((() => k_(e, !0)), 0);
	else {
		if (null != n) {
			if ("object" != typeof n) throw new Error("Only objects are supported for option databaseAuthVariableOverride");
			try {
				cp(n)
			} catch (i) {
				throw new Error("Invalid authOverride provided: " + i)
			}
		}
		e.persistentConnection_ = new xm(e.repoInfo_, t, ((t, n, i, r) => {
			R_(e, t, n, i, r)
		}), (t => {
			k_(e, t)
		}), (t => {
			! function(e, t) {
				If(t, ((t, n) => {
					N_(e, t, n)
				}))
			}(e, t)
		}), e.authTokenProvider_, e.appCheckProvider_, n), e.server_ = e.persistentConnection_
	}
	e.authTokenProvider_.addTokenChangeListener((t => {
		e.server_.refreshAuthToken(t)
	})), e.appCheckProvider_.addTokenChangeListener((t => {
		e.server_.refreshAppCheckToken(t.token)
	})), e.statsReporter_ = function(e, t) {
		const n = e.toString();
		return qf[n] || (qf[n] = t()), qf[n]
	}(e.repoInfo_, (() => new mg(e.stats_, e.server_))), e.infoData_ = new ug, e.infoSyncTree_ = new kv({
		startListening: (t, n, i, r) => {
			let s = [];
			const a = e.infoData_.getNode(t._path);
			return a.isEmpty() || (s = Fv(e.infoSyncTree_, t._path, a), setTimeout((() => {
				r("ok")
			}), 0)), s
		},
		stopListening: () => {}
	}), N_(e, "connected", !1), e.serverSyncTree_ = new kv({
		startListening: (t, n, i, r) => (e.server_.listen(t, i, n, ((n, i) => {
			const s = r(n, i);
			C_(e.eventQueue_, t._path, s)
		})), []),
		stopListening: (t, n) => {
			e.server_.unlisten(t, n)
		}
	})
}

function I_(e) {
	const t = e.infoData_.getNode(new im(".info/serverTimeOffset")).val() || 0;
	return (new Date).getTime() + t
}

function D_(e) {
	return (t = (t = {
		timestamp: I_(e)
	}) || {}).timestamp = t.timestamp || (new Date).getTime(), t;
	var t
}

function R_(e, t, n, i, r) {
	e.dataUpdateCount++;
	const s = new im(t);
	n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n;
	let a = [];
	if (r)
		if (i) {
			const t = fp(n, (e => Xm(e)));
			a = function(e, t, n, i) {
				const r = Xv(e, i);
				if (r) {
					const i = $v(r),
						s = i.path,
						a = i.queryId,
						o = pm(s, t),
						l = Dg.fromObject(n);
					return Zv(e, s, new wg(_g(a), o, l))
				}
				return []
			}(e.serverSyncTree_, s, t, r)
		} else {
			const t = Xm(n);
			a = function(e, t, n, i) {
				const r = Xv(e, i);
				if (null != r) {
					const i = $v(r),
						s = i.path,
						a = i.queryId,
						o = pm(s, t);
					return Zv(e, s, new bg(_g(a), o, n))
				}
				return []
			}(e.serverSyncTree_, s, t, r)
		}
	else if (i) {
		const t = fp(n, (e => Xm(e)));
		a = function(e, t, n) {
			const i = Dg.fromObject(n);
			return Hv(e, new wg({
				fromUser: !1,
				fromServer: !0,
				queryId: null,
				tagged: !1
			}, t, i))
		}(e.serverSyncTree_, s, t)
	} else {
		const t = Xm(n);
		a = Fv(e.serverSyncTree_, s, t)
	}
	let o = s;
	a.length > 0 && (o = H_(e, s)), C_(e.eventQueue_, o, a)
}

function k_(e, t) {
	N_(e, "connected", t), !1 === t && function(e) {
		U_(e, "onDisconnectEvents");
		const t = D_(e),
			n = hg();
		pg(e.onDisconnect_, rm(), ((i, r) => {
			const s = function(e, t, n, i) {
				return r_(t, new Qv(n, e), i)
			}(i, r, e.serverSyncTree_, t);
			dg(n, i, s)
		}));
		let i = [];
		pg(n, rm(), ((t, n) => {
			i = i.concat(Fv(e.serverSyncTree_, t, n));
			const r = Y_(e, t);
			H_(e, r)
		})), e.onDisconnect_ = hg(), C_(e.eventQueue_, rm(), i)
	}(e)
}

function N_(e, t, n) {
	const i = new im("/.info/" + t),
		r = Xm(n);
	e.infoData_.updateSnapshot(i, r);
	const s = Fv(e.infoSyncTree_, i, r);
	C_(e.eventQueue_, i, s)
}

function O_(e) {
	return e.nextWriteId_++
}

function F_(e, t, n, i, r) {
	U_(e, "set", {
		path: t.toString(),
		value: n,
		priority: i
	});
	const s = D_(e),
		a = Xm(n, i),
		o = Bv(e.serverSyncTree_, t),
		l = i_(a, o, s),
		c = O_(e),
		u = Nv(e.serverSyncTree_, t, l, c, !0);
	M_(e.eventQueue_, u), e.server_.put(t.toString(), a.val(!0), ((n, i) => {
		const s = "ok" === n;
		s || wf("set at " + t + " failed: " + n);
		const a = Ov(e.serverSyncTree_, c, !s);
		C_(e.eventQueue_, t, a),
			function(e, t, n, i) {
				t && Nf((() => {
					if ("ok" === n) t(null);
					else {
						const e = (n || "error").toUpperCase();
						let r = e;
						i && (r += ": " + i);
						const s = new Error(r);
						s.code = e, t(s)
					}
				}))
			}(0, r, n, i)
	}));
	const h = Y_(e, t);
	H_(e, h), C_(e.eventQueue_, h, [])
}

function z_(e, t, n) {
	let i;
	i = ".info" === sm(t._path) ? zv(e.infoSyncTree_, t, n) : zv(e.serverSyncTree_, t, n), T_(e.eventQueue_, t._path, i)
}

function U_(e, ...t) {
	let n = "";
	e.persistentConnection_ && (n = e.persistentConnection_.id + ":"), _f(n, ...t)
}

function B_(e, t, n) {
	return Bv(e.serverSyncTree_, t, n) || jm.EMPTY_NODE
}

function V_(e, t = e.transactionQueueTree_) {
	if (t || j_(e, t), o_(t)) {
		const n = W_(e, t);
		$d(n.length > 0, "Sending zero length transaction queue");
		n.every((e => 0 === e.status)) && function(e, t, n) {
			const i = n.map((e => e.currentWriteId)),
				r = B_(e, t, i);
			let s = r;
			const a = r.hash();
			for (let c = 0; c < n.length; c++) {
				const e = n[c];
				$d(0 === e.status, "tryToSendTransactionQueue_: items in queue should all be run."), e.status = 1, e.retryCount++;
				const i = pm(t, e.path);
				s = s.updateChild(i, e.currentOutputSnapshotRaw)
			}
			const o = s.val(!0),
				l = t;
			e.server_.put(l.toString(), o, (i => {
				U_(e, "transaction put response", {
					path: l.toString(),
					status: i
				});
				let r = [];
				if ("ok" === i) {
					const i = [];
					for (let t = 0; t < n.length; t++) n[t].status = 2, r = r.concat(Ov(e.serverSyncTree_, n[t].currentWriteId)), n[t].onComplete && i.push((() => n[t].onComplete(null, !0, n[t].currentOutputSnapshotResolved))), n[t].unwatcher();
					j_(e, a_(e.transactionQueueTree_, t)), V_(e, e.transactionQueueTree_), C_(e.eventQueue_, t, r);
					for (let e = 0; e < i.length; e++) Nf(i[e])
				} else {
					if ("datastale" === i)
						for (let e = 0; e < n.length; e++) 3 === n[e].status ? n[e].status = 4 : n[e].status = 0;
					else {
						wf("transaction at " + l.toString() + " failed: " + i);
						for (let e = 0; e < n.length; e++) n[e].status = 4, n[e].abortReason = i
					}
					H_(e, t)
				}
			}), a)
		}(e, d_(t), n)
	} else c_(t) && u_(t, (t => {
		V_(e, t)
	}))
}

function H_(e, t) {
	const n = G_(e, t),
		i = d_(n);
	return function(e, t, n) {
		if (0 === t.length) return;
		const i = [];
		let r = [];
		const s = t.filter((e => 0 === e.status)).map((e => e.currentWriteId));
		for (let o = 0; o < t.length; o++) {
			const l = t[o],
				c = pm(n, l.path);
			let u, h = !1;
			if ($d(null !== c, "rerunTransactionsUnderNode_: relativePath should not be null."), 4 === l.status) h = !0, u = l.abortReason, r = r.concat(Ov(e.serverSyncTree_, l.currentWriteId, !0));
			else if (0 === l.status)
				if (l.retryCount >= 25) h = !0, u = "maxretry", r = r.concat(Ov(e.serverSyncTree_, l.currentWriteId, !0));
				else {
					const n = B_(e, l.path, s);
					l.currentInputSnapshot = n;
					const i = t[o].update(n.val());
					if (void 0 !== i) {
						y_("transaction failed: Data returned ", i, l.path);
						let t = Xm(i);
						"object" == typeof i && null != i && hp(i, ".priority") || (t = t.updatePriority(n.getPriority()));
						const a = l.currentWriteId,
							o = D_(e),
							c = i_(t, n, o);
						l.currentOutputSnapshotRaw = t, l.currentOutputSnapshotResolved = c, l.currentWriteId = O_(e), s.splice(s.indexOf(a), 1), r = r.concat(Nv(e.serverSyncTree_, l.path, c, l.currentWriteId, l.applyLocally)), r = r.concat(Ov(e.serverSyncTree_, a, !0))
					} else h = !0, u = "nodata", r = r.concat(Ov(e.serverSyncTree_, l.currentWriteId, !0))
				} C_(e.eventQueue_, n, r), r = [], h && (t[o].status = 2, a = t[o].unwatcher, setTimeout(a, Math.floor(0)), t[o].onComplete && ("nodata" === u ? i.push((() => t[o].onComplete(null, !1, t[o].currentInputSnapshot))) : i.push((() => t[o].onComplete(new Error(u), !1, null)))))
		}
		var a;
		j_(e, e.transactionQueueTree_);
		for (let o = 0; o < i.length; o++) Nf(i[o]);
		V_(e, e.transactionQueueTree_)
	}(e, W_(e, n), i), i
}

function G_(e, t) {
	let n, i = e.transactionQueueTree_;
	for (n = sm(t); null !== n && void 0 === o_(i);) i = a_(i, n), n = sm(t = om(t));
	return i
}

function W_(e, t) {
	const n = [];
	return q_(e, t, n), n.sort(((e, t) => e.order - t.order)), n
}

function q_(e, t, n) {
	const i = o_(t);
	if (i)
		for (let r = 0; r < i.length; r++) n.push(i[r]);
	u_(t, (t => {
		q_(e, t, n)
	}))
}

function j_(e, t) {
	const n = o_(t);
	if (n) {
		let e = 0;
		for (let t = 0; t < n.length; t++) 2 !== n[t].status && (n[e] = n[t], e++);
		n.length = e, l_(t, n.length > 0 ? n : void 0)
	}
	u_(t, (t => {
		j_(e, t)
	}))
}

function Y_(e, t) {
	const n = d_(G_(e, t)),
		i = a_(e.transactionQueueTree_, t);
	return function(e, t, n) {
		let i = n ? e : e.parent;
		for (; null !== i;) {
			if (t(i)) return !0;
			i = i.parent
		}
	}(i, (t => {
		X_(e, t)
	})), X_(e, i), h_(i, (t => {
		X_(e, t)
	})), n
}

function X_(e, t) {
	const n = o_(t);
	if (n) {
		const i = [];
		let r = [],
			s = -1;
		for (let t = 0; t < n.length; t++) 3 === n[t].status || (1 === n[t].status ? ($d(s === t - 1, "All SENT items should be at beginning of queue."), s = t, n[t].status = 3, n[t].abortReason = "set") : ($d(0 === n[t].status, "Unexpected transaction status in abort"), n[t].unwatcher(), r = r.concat(Ov(e.serverSyncTree_, n[t].currentWriteId, !0)), n[t].onComplete && i.push(n[t].onComplete.bind(null, new Error("set"), !1, null)))); - 1 === s ? l_(t, void 0) : n.length = s + 1, C_(e.eventQueue_, d_(t), r);
		for (let e = 0; e < i.length; e++) Nf(i[e])
	}
}
const $_ = function(e, t) {
		const n = Z_(e),
			i = n.namespace;
		"firebase.com" === n.domain && bf(n.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), i && "undefined" !== i || "localhost" === n.domain || bf("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"), n.secure || "undefined" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && wf("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
		const r = "ws" === n.scheme || "wss" === n.scheme;
		return {
			repoInfo: new Vf(n.host, n.secure, i, t, r, "", i !== n.subdomain),
			path: new im(n.pathString)
		}
	},
	Z_ = function(e) {
		let t = "",
			n = "",
			i = "",
			r = "",
			s = "",
			a = !0,
			o = "https",
			l = 443;
		if ("string" == typeof e) {
			let c = e.indexOf("//");
			c >= 0 && (o = e.substring(0, c - 1), e = e.substring(c + 2));
			let u = e.indexOf("/"); - 1 === u && (u = e.length);
			let h = e.indexOf("?"); - 1 === h && (h = e.length), t = e.substring(0, Math.min(u, h)), u < h && (r = function(e) {
				let t = "";
				const n = e.split("/");
				for (let r = 0; r < n.length; r++)
					if (n[r].length > 0) {
						let e = n[r];
						try {
							e = decodeURIComponent(e.replace(/\+/g, " "))
						} catch (i) {}
						t += "./" + e
					} return t
			}(e.substring(u, h)));
			const d = function(e) {
				const t = {};
				"?" === e.charAt(0) && (e = e.substring(1));
				for (const n of e.split("&")) {
					if (0 === n.length) continue;
					const i = n.split("=");
					2 === i.length ? t[decodeURIComponent(i[0])] = decodeURIComponent(i[1]) : wf(`Invalid query segment '${n}' in query '${e}'`)
				}
				return t
			}(e.substring(Math.min(e.length, h)));
			c = t.indexOf(":"), c >= 0 ? (a = "https" === o || "wss" === o, l = parseInt(t.substring(c + 1), 10)) : c = t.length;
			const p = t.slice(0, c);
			if ("localhost" === p.toLowerCase()) n = "localhost";
			else if (p.split(".").length <= 2) n = p;
			else {
				const e = t.indexOf(".");
				i = t.substring(0, e).toLowerCase(), n = t.substring(e + 1), s = i
			}
			"ns" in d && (s = d.ns)
		}
		return {
			host: t,
			port: l,
			domain: n,
			subdomain: i,
			secure: a,
			scheme: o,
			pathString: r,
			namespace: s
		}
	};
class K_ {
	constructor(e, t, n, i) {
		this.eventType = e, this.eventRegistration = t, this.snapshot = n, this.prevName = i
	}
	getPath() {
		const e = this.snapshot.ref;
		return "value" === this.eventType ? e._path : e.parent._path
	}
	getEventType() {
		return this.eventType
	}
	getEventRunner() {
		return this.eventRegistration.getEventRunner(this)
	}
	toString() {
		return this.getPath().toString() + ":" + this.eventType + ":" + cp(this.snapshot.exportVal())
	}
}
class J_ {
	constructor(e, t, n) {
		this.eventRegistration = e, this.error = t, this.path = n
	}
	getPath() {
		return this.path
	}
	getEventType() {
		return "cancel"
	}
	getEventRunner() {
		return this.eventRegistration.getEventRunner(this)
	}
	toString() {
		return this.path.toString() + ":cancel"
	}
}
class Q_ {
	constructor(e, t) {
		this.snapshotCallback = e, this.cancelCallback = t
	}
	onValue(e, t) {
		this.snapshotCallback.call(null, e, t)
	}
	onCancel(e) {
		return $d(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, e)
	}
	get hasCancelCallback() {
		return !!this.cancelCallback
	}
	matches(e) {
		return this.snapshotCallback === e.snapshotCallback || void 0 !== this.snapshotCallback.userCallback && this.snapshotCallback.userCallback === e.snapshotCallback.userCallback && this.snapshotCallback.context === e.snapshotCallback.context
	}
}
class ey {
	constructor(e, t, n, i) {
		this._repo = e, this._path = t, this._queryParams = n, this._orderByCalled = i
	}
	get key() {
		return dm(this._path) ? null : lm(this._path)
	}
	get ref() {
		return new ty(this._repo, this._path)
	}
	get _queryIdentifier() {
		const e = lg(this._queryParams),
			t = Pf(e);
		return "{}" === t ? "default" : t
	}
	get _queryObject() {
		return lg(this._queryParams)
	}
	isEqual(e) {
		if (!((e = xp(e)) instanceof ey)) return !1;
		const t = this._repo === e._repo,
			n = fm(this._path, e._path),
			i = this._queryIdentifier === e._queryIdentifier;
		return t && n && i
	}
	toJSON() {
		return this.toString()
	}
	toString() {
		return this._repo.toString() + function(e) {
			let t = "";
			for (let n = e.pieceNum_; n < e.pieces_.length; n++) "" !== e.pieces_[n] && (t += "/" + encodeURIComponent(String(e.pieces_[n])));
			return t || "/"
		}(this._path)
	}
}
class ty extends ey {
	constructor(e, t) {
		super(e, t, new ag, !1)
	}
	get parent() {
		const e = um(this._path);
		return null === e ? null : new ty(this._repo, e)
	}
	get root() {
		let e = this;
		for (; null !== e.parent;) e = e.parent;
		return e
	}
}
class ny {
	constructor(e, t, n) {
		this._node = e, this.ref = t, this._index = n
	}
	get priority() {
		return this._node.getPriority().val()
	}
	get key() {
		return this.ref.key
	}
	get size() {
		return this._node.numChildren()
	}
	child(e) {
		const t = new im(e),
			n = ry(this.ref, e);
		return new ny(this._node.getChild(t), n, zm)
	}
	exists() {
		return !this._node.isEmpty()
	}
	exportVal() {
		return this._node.val(!0)
	}
	forEach(e) {
		if (this._node.isLeafNode()) return !1;
		return !!this._node.forEachChild(this._index, ((t, n) => e(new ny(n, ry(this.ref, t), zm))))
	}
	hasChild(e) {
		const t = new im(e);
		return !this._node.getChild(t).isEmpty()
	}
	hasChildren() {
		return !this._node.isLeafNode() && !this._node.isEmpty()
	}
	toJSON() {
		return this.exportVal()
	}
	val() {
		return this._node.val()
	}
}

function iy(e, t) {
	return (e = xp(e))._checkNotDeleted("ref"), void 0 !== t ? ry(e._root, t) : e._root
}

function ry(e, t) {
	var n, i, r, s;
	return null === sm((e = xp(e))._path) ? (n = "child", i = "path", s = !1, (r = t) && (r = r.replace(/^\/*\.info(\/|$)/, "/")), x_(n, i, r, s)) : x_("child", "path", t, !1), new ty(e._repo, hm(e._path, t))
}

function sy(e, t) {
	e = xp(e), b_("push", e._path), __("push", t, e._path, !0);
	const n = I_(e._repo),
		i = Jm(n),
		r = ry(e, i),
		s = ry(e, i);
	let a;
	return a = null != t ? ay(s, t).then((() => s)) : Promise.resolve(s), r.then = a.then.bind(a), r.catch = a.then.bind(a, void 0), r
}

function ay(e, t) {
	e = xp(e), b_("set", e._path), __("set", t, e._path, !1);
	const n = new np;
	return F_(e._repo, e._path, t, null, n.wrapCallback((() => {}))), n.promise
}

function oy(e) {
	return function(e, t) {
		const n = Vv(e.serverSyncTree_, t);
		return null != n ? Promise.resolve(n) : e.server_.get(t).then((n => {
			const i = Xm(n).withIndex(t._queryParams.getIndex()),
				r = Fv(e.serverSyncTree_, t._path, i);
			return T_(e.eventQueue_, t._path, r), Promise.resolve(i)
		}), (n => (U_(e, "get for query " + cp(t) + " failed: " + n), Promise.reject(new Error(n)))))
	}((e = xp(e))._repo, e).then((t => new ny(t, new ty(e._repo, e._path), e._queryParams.getIndex())))
}
class ly {
	constructor(e) {
		this.callbackContext = e
	}
	respondsTo(e) {
		return "value" === e
	}
	createEvent(e, t) {
		const n = t._queryParams.getIndex();
		return new K_("value", this, new ny(e.snapshotNode, new ty(t._repo, t._path), n))
	}
	getEventRunner(e) {
		return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, null)
	}
	createCancelEvent(e, t) {
		return this.callbackContext.hasCancelCallback ? new J_(this, e, t) : null
	}
	matches(e) {
		return e instanceof ly && (!e.callbackContext || !this.callbackContext || e.callbackContext.matches(this.callbackContext))
	}
	hasAnyCallback() {
		return null !== this.callbackContext
	}
}
class cy {
	constructor(e, t) {
		this.eventType = e, this.callbackContext = t
	}
	respondsTo(e) {
		let t = "children_added" === e ? "child_added" : e;
		return t = "children_removed" === t ? "child_removed" : t, this.eventType === t
	}
	createCancelEvent(e, t) {
		return this.callbackContext.hasCancelCallback ? new J_(this, e, t) : null
	}
	createEvent(e, t) {
		$d(null != e.childName, "Child events should have a childName.");
		const n = ry(new ty(t._repo, t._path), e.childName),
			i = t._queryParams.getIndex();
		return new K_(e.type, this, new ny(e.snapshotNode, n, i), e.prevName)
	}
	getEventRunner(e) {
		return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, e.prevName)
	}
	matches(e) {
		return e instanceof cy && (this.eventType === e.eventType && (!this.callbackContext || !e.callbackContext || this.callbackContext.matches(e.callbackContext)))
	}
	hasAnyCallback() {
		return !!this.callbackContext
	}
}

function uy(e, t, n, i, r) {
	let s;
	if ("object" == typeof i && (s = void 0, r = i), "function" == typeof i && (s = i), r && r.onlyOnce) {
		const t = n,
			i = (n, i) => {
				z_(e._repo, e, o), t(n, i)
			};
		i.userCallback = n.userCallback, i.context = n.context, n = i
	}
	const a = new Q_(n, s || void 0),
		o = "value" === t ? new ly(a) : new cy(t, a);
	return function(e, t, n) {
		let i;
		i = ".info" === sm(t._path) ? Uv(e.infoSyncTree_, t, n) : Uv(e.serverSyncTree_, t, n), T_(e.eventQueue_, t._path, i)
	}(e._repo, e, o), () => z_(e._repo, e, o)
}

function hy(e, t, n, i) {
	return uy(e, "value", t, n, i)
}! function(e) {
	$d(!xv, "__referenceConstructor has already been defined"), xv = e
}(ty),
function(e) {
	$d(!bv, "__referenceConstructor has already been defined"), bv = e
}(ty);
const dy = {};

function py(e, t, n, i, r) {
	let s = i || e.options.databaseURL;
	void 0 === s && (e.options.projectId || bf("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), _f("Using default host for project ", e.options.projectId), s = `${e.options.projectId}-default-rtdb.firebaseio.com`);
	let a, o, l = $_(s, r),
		c = l.repoInfo;
	"undefined" != typeof process && (o = process.env.FIREBASE_DATABASE_EMULATOR_HOST), o ? (a = !0, s = `http://${o}?ns=${c.namespace}`, l = $_(s, r), c = l.repoInfo) : a = !l.repoInfo.secure;
	const u = r && a ? new Uf(Uf.OWNER) : new zf(e.name, e.options, t);
	w_("Invalid Firebase Database URL", l), dm(l.path) || bf("Database URL must point to the root of a Firebase Database (not including a child path).");
	const h = function(e, t, n, i) {
		let r = dy[t.name];
		r || (r = {}, dy[t.name] = r);
		let s = r[e.toURLString()];
		s && bf("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
		return s = new P_(e, false, n, i), r[e.toURLString()] = s, s
	}(c, e, u, new Ff(e.name, n));
	return new fy(h, e)
}
class fy {
	constructor(e, t) {
		this._repoInternal = e, this.app = t, this.type = "database", this._instanceStarted = !1
	}
	get _repo() {
		return this._instanceStarted || (L_(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal
	}
	get _root() {
		return this._rootInternal || (this._rootInternal = new ty(this._repo, rm())), this._rootInternal
	}
	_delete() {
		return null !== this._rootInternal && (! function(e, t) {
			const n = dy[t];
			n && n[e.key] === e || bf(`Database ${t}(${e.repoInfo_}) has already been deleted.`),
				function(e) {
					e.persistentConnection_ && e.persistentConnection_.interrupt("repo_interrupt")
				}(e), delete n[e.key]
		}(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve()
	}
	_checkNotDeleted(e) {
		null === this._rootInternal && bf("Cannot call " + e + " on a deleted database.")
	}
}

function my(e = function(e = "[DEFAULT]") {
	const t = Np.get(e);
	if (!t) throw Up.create("no-app", {
		appName: e
	});
	return t
}(), t) {
	return function(e, t) {
		return e.container.getProvider(t)
	}(e, "database").getImmediate({
		identifier: t
	})
}
xm.prototype.simpleListen = function(e, t) {
		this.sendRequest("q", {
			p: e
		}, t)
	}, xm.prototype.echo = function(e, t) {
		this.sendRequest("echo", {
			d: e
		}, t)
	},
	function(e) {
		af = "9.4.1", zp(new bp("database", ((e, {
			instanceIdentifier: t
		}) => py(e.getProvider("app").getImmediate(), e.getProvider("auth-internal"), e.getProvider("app-check-internal"), t)), "PUBLIC").setMultipleInstances(!0)), Vp(sf, "0.12.4", e), Vp(sf, "0.12.4", "esm2017")
	}();
let gy;
const vy = [];
let _y = function() {
	const e = localStorage.getItem("ice_servers_cache");
	if (!e) return null;
	try {
		return JSON.parse(e)
	} catch (t) {
		return null
	}
}() || null;

function yy() {
	return ((e = 21) => {
		let t = "",
			n = crypto.getRandomValues(new Uint8Array(e));
		for (; e--;) {
			let i = 63 & n[e];
			t += i < 36 ? i.toString(36) : i < 62 ? (i - 26).toString(36).toUpperCase() : i < 63 ? "_" : "-"
		}
		return t
	})()
}

function xy() {
	let e, t, n, i, r, s = localStorage.getItem("uuid");
	s || (s = yy(), localStorage.setItem("uuid", s));
	const a = Tt(!1),
		o = jp(),
		l = jp(),
		c = gy = {
			install: async function(e) {
				e.config.globalProperties.$webRTC = c, e.provide("webRTC", c), delete c.install
			},
			config: function(e) {
				this.firebaseApp = function(e, t = {}) {
					"object" != typeof t && (t = {
						name: t
					});
					const n = Object.assign({
							name: "[DEFAULT]",
							automaticDataCollectionEnabled: !1
						}, t),
						i = n.name;
					if ("string" != typeof i || !i) throw Up.create("bad-app-name", {
						appName: String(i)
					});
					const r = Np.get(i);
					if (r) {
						if (mp(e, r.options) && mp(n, r.config)) return r;
						throw Up.create("duplicate-app", {
							appName: i
						})
					}
					const s = new Sp(i);
					for (const o of Op.values()) s.addComponent(o);
					const a = new Bp(e, n, s);
					return Np.set(i, a), a
				}(e)
			},
			createRoom: p,
			joinRoom: async function(n) {
				if (!n) return !1;
				const i = my(),
					r = iy(i, `${n}/room`),
					s = iy(i, `${n}/candidates/remote`),
					a = await oy(iy(i, `${n}`)).then((e => {
						if (e.exists()) return e.val()
					})).catch((e => {}));
				if (!a) return;
				if (a.room.answers) return;
				t || (e = await u(), jd.config = {
					iceServers: e
				});
				t = h(!1), t.on("signal", (async e => {
					e.type, "answer" == e.type ? await ay(ry(r, "answers/"), e) : "candidate" == e.type && sy(s, e)
				})), t.signal(a.room.offer), Object.keys(a.candidates.host).forEach((e => {
					t.signal(a.candidates.host[e])
				})), await new Promise((e => requestAnimationFrame(e)))
			},
			sendMessage: function(e, n) {
				if (!a.value) return;
				t.send(JSON.stringify({
					type: e,
					data: n
				}))
			},
			watch: function(e, t) {
				return o.watch(e, t)
			},
			unwatch: function(e, t) {
				o.unwatch(e, t)
			},
			watchStatus: function(e, t) {
				return l.watch(e, t)
			},
			unwatchStatus: function(e, t) {
				o.unwatch(e, t)
			},
			kill: function() {
				t && (t.destroy(), t = null);
				i && i();
				r && r()
			},
			close: function() {
				t && (t.destroy(), t = null);
				i && i();
				r && r()
			},
			status: a
		};
	return c;
	async function u() {
		if (_y && Date.now() < _y.expires) return _y.list;
		const e = await fetch("https://europe-west1-montblanc-race.cloudfunctions.net/listIceServers", {
				method: "POST",
				headers: {
					Accept: "application/json",
					"Content-Type": "application/json",
					Authorization: "Bearer VgDa2q5ZPfcyA+Fal9CtlGXqOb+T"
				}
			}),
			t = await e.json();
		if (!t.iceServers) throw new Error(t);
		const n = Date.now() + 18e5;
		return _y = {
			expires: n,
			list: t.iceServers
		}, localStorage.setItem("ice_servers_cache", JSON.stringify(_y)), t.iceServers
	}

	function h(e = !1) {
		const t = new jd({
			objectMode: !0,
			initiator: e,
			trickle: !0,
			answerConstraints: {
				offerToReceiveAudio: !1,
				offerToReceiveVideo: !1
			}
		});
		return t.on("error", f), t.on("close", (() => {
			a.value = !1, l.emit("close")
		})), t.on("data", m), t.on("connect", (() => {
			a.value = !0, l.emit("connect")
		})), t
	}
	async function d(e) {
		if (!e) return;
		const t = my();
		var n;
		n = iy(t, e), b_("remove", n._path), ay(n, null)
	}
	async function p(s = null) {
		e = await u(), jd.config = {
			iceServers: e
		}, t = h(!0), await d(n), n = s || yy();
		const a = my(),
			o = iy(a, `${n}/room`),
			l = iy(a, `${n}/candidates`),
			c = iy(a, `${n}/candidates/host/`);
		return t.on("signal", (async e => {
			"offer" == e.type ? await ay(ry(o, "offer/"), e) : "candidate" == e.type && sy(c, e)
		})), i = hy(ry(o, "answers/"), (async e => {
			const n = e.val();
			n && t.signal(n)
		})), r = hy(ry(l, "/remote/"), (async e => {
			const n = e.val();
			n && Object.keys(n).forEach((async e => {
				vy.includes(e) || (vy.push(e), n[e], t.signal(n[e]))
			}))
		})), n
	}

	function f(e) {
		a.value = !1, t.destroy(), t = null, l.emit("error"), i && i(), r && r(), p(n)
	}

	function m(e) {
		const t = JSON.parse(e);
		o.emit(t.type, t.data)
	}
}
const by = {
		class: "page page-syncP syncP"
	},
	wy = {
		class: "syncP__container"
	},
	Sy = {
		class: "syncP__title"
	},
	My = Ai('<div class="syncP__iconContainer" data-v-7429eb11><div class="syncP__icon" data-v-7429eb11><svg viewBox="0 0 236 237" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-7429eb11><path fill-rule="evenodd" clip-rule="evenodd" d="M89.375 179.775c33.245 17.093 74.861 7.596 97.12-23.78a76.314 76.314 0 0 0 10.375-20.616l12.28 5.778a89.892 89.892 0 0 1-11.664 22.636c-27.544 38.825-80.281 49.174-120.254 24.597l12.143-8.615Z" fill="#fff" class="p3" data-v-7429eb11></path><path d="M175.548 39.451c23.86 16.928 36.83 43.49 37.372 70.658l-11.547-5.434c-2.017-21.713-13.141-42.455-32.324-56.065-18.315-12.994-40.339-16.905-60.711-12.646l-1.322-11.19c23.053-4.552 47.855.008 68.532 14.677Z" fill="#fff" stroke="url(#a)" stroke-width="2.246" class="p2" data-v-7429eb11></path><path d="M61.93 67.622a76.22 76.22 0 0 1 18.908-18.69l-1.752-14.834C68.29 40.36 58.632 48.981 50.94 59.825c-24.016 33.852-21.273 78.627 3.952 109.168l11.029-7.824c-22.025-25.973-24.601-64.493-3.99-93.546Z" fill="#fff" class="p1" data-v-7429eb11></path><defs data-v-7429eb11><linearGradient id="a" x1="205.65" y1="107.003" x2="130.408" y2="18.285" gradientUnits="userSpaceOnUse" data-v-7429eb11><stop stop-color="#fff" data-v-7429eb11></stop><stop offset="1" stop-color="#fff" stop-opacity="0" data-v-7429eb11></stop></linearGradient></defs></svg></div></div>', 1);
var Ty = '<svg viewBox="0 0 86 86" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="42.954" y="1.414" width="58.746" height="58.746" rx="4" transform="rotate(45 42.954 1.414)" fill="#fff" stroke="url(#a)" stroke-width="2"/><path d="m38.93 31.68 1.05 14.7h5.82l5.73-14.7h-12.6Zm8.52 15.87h-9.48L36.92 54h9.51l1.02-6.45Z" fill="#DD2526"/><defs><linearGradient id="a" x1="43.654" y1="60.775" x2="100.114" y2="4.315" gradientUnits="userSpaceOnUse"><stop stop-color="#E1E1E1"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient></defs></svg>\n';
const Cy = {
		class: "page syncF"
	},
	Ey = {
		class: "syncF__container"
	},
	Ay = ["innerHTML"],
	Py = {
		class: "syncF__title"
	};
const Ly = [{
	path: "/",
	name: "home",
	component: pc
}, {
	path: "/result",
	name: "result",
	component: yu
}, {
	path: "/register",
	name: "register",
	component: Ju
}, {
	path: "/confirmation",
	name: "confirmation",
	component: rh
}, {
	path: "/game",
	name: "game",
	component: Ad
}, {
	path: "/qrcode-home",
	name: "qrcode-home",
	component: Vd
}, {
	path: "/qrcode-pairing",
	name: "qrcode-pairing",
	component: zl({
		setup(e, {
			expose: t
		}) {
			const {
				csstween: n
			} = Sl(), i = "cubic-bezier(.87,0,.13,1)";
			kc();
			const r = Wa();
			return (Gi() ? Yt("webRTC") : gy).watch((e => {
				"start" === e.data && r.push({
					name: "game"
				})
			})), _c(), pn((() => {
				app.$rtcDisplay.enable()
			})), t({
				enter: async function(e) {
					n({
						target: e,
						selector: ".syncP__title",
						transform: ["translateY(-40px)", ""],
						duration: 1e3,
						ease: "cubic-bezier(0,0,.13,1) ",
						opacity: [0, ""]
					}), n({
						target: e,
						selector: ".syncP__iconContainer",
						transform: ["scale3d(0.35,0.35,0.35)", ""],
						duration: 1e3,
						ease: i,
						delay: 100,
						opacity: [0, ""]
					})
				},
				leave: async function(e) {
					return n({
						target: e,
						transform: ["", "scale3d(0.6,0.6,0.6)"],
						duration: 800,
						ease: i,
						opacity: ["", 0],
						autoClear: !1
					}).finished
				}
			}), (e, t) => (pi(), vi("section", by, [Mi("div", wy, [Mi("div", Sy, [Mi("p", null, y(e.$l("webRTC.pairing.borne.progress")), 1)]), My])]))
		}
	}, [
		["__scopeId", "data-v-7429eb11"]
	])
}, {
	path: "/qrcode-error",
	name: "qrcode-error",
	component: zl({
		setup(e, {
			expose: t
		}) {
			const {
				csstween: n
			} = Sl(), i = "cubic-bezier(.87,0,.13,1)";
			return pn((() => {
				Nl() && Nl().audio.setBgm("intro"), Ll.$rtcDisplay.enable()
			})), t({
				enter: async function(e) {
					n({
						target: e,
						selector: ".syncF__icon",
						transform: ["scale3d(0,0,0) rotate(15deg)", ""],
						duration: 1e3,
						ease: i,
						opacity: [0, ""]
					}), n({
						target: e,
						selector: ".syncF__title",
						transform: ["translateY(-40px)", ""],
						duration: 1e3,
						ease: "cubic-bezier(0,0,.13,1) ",
						delay: 300,
						opacity: [0, ""]
					})
				},
				leave: async function(e) {
					return n({
						target: e,
						transform: ["", "scale3d(0.6,0.6,0.6)"],
						duration: 800,
						ease: i,
						opacity: ["", 0],
						autoClear: !1
					}).finished
				}
			}), (e, t) => (pi(), vi("section", Cy, [Mi("div", Ey, [Mi("div", {
				class: "syncF__icon",
				innerHTML: At(Ty)
			}, null, 8, Ay), Mi("div", Py, [Mi("p", null, y(e.$l("webRTC.pairing.borne.fail")), 1)])])]))
		}
	}, [
		["__scopeId", "data-v-ec20fb1c"]
	])
}];

function Iy() {
	const e = window.__DATA,
		t = e.site.locales[e.site.locale];
	let n = e.config.basepath;
	return t.default || (n += e.site.locale), n.endsWith("/") && (n = n.slice(0, -1)), n
}
const Dy = {
	props: ["mode", "routeKey"],
	setup(e) {
		const t = e,
			n = "_transitionState",
			i = Wa(),
			r = Tt();
		let s, a, o = 1,
			l = null,
			c = null,
			u = null,
			h = null;
		const d = i.beforeResolve(((e, t) => {
			s = t, a = e
		}));
		async function p(e, t) {
			l = c;
			const i = c = r.value;
			i[n] || (i[n] = {});
			const d = i[n];
			d.uid || (d.uid = o++), g(), i === h && v(), u = i, d.entering = !0, d.leaving = !1, i.enter && await i.enter(e, s, a, d), u === i && (u = null), d.entering && (d.entering = !1, t())
		}

		function f() {
			const e = c,
				t = e[n];
			u === e && (u = null), t.entering && (t.entering = !1, e.enterCancelled && e.enterCancelled(t))
		}
		async function m(e, i) {
			const r = "in-out" === t.mode ? l : c,
				o = r[n];
			if (v(), r === u && g(), h = r, o.entering = !1, o.leaving = !0, r.leave && await r.leave(e, s, a, o), h === r && (h = null), !o.leaving) return i();
			o.leaving = !1, i()
		}

		function g() {
			if (!u) return;
			const e = u,
				t = e[n];
			t.entering && (t.entering = !1, e.enteringCancelled && e.enterCancelled(t)), u = null
		}

		function v() {
			if (!h) return;
			const e = h,
				t = e[n];
			t.leaving && (t.leaving = !1, e.leaveCancelled && e.leaveCancelled(t)), h = null
		}
		return gn((() => {
			d()
		})), (n, i) => {
			const s = ni("RouterView");
			return pi(), _i(s, null, {
				default: Vt((({
					Component: n
				}) => [Ti(Xr, {
					ref: (e, t) => {
						t.tr = e
					},
					css: !1,
					mode: e.mode,
					appear: "",
					onEnter: p,
					onEnterCancelled: f,
					onLeave: m
				}, {
					default: Vt((() => [(pi(), _i(ri(n), {
						key: t.routeKey,
						ref: (e, t) => {
							t.component = e, r.value = e
						}
					}, null, 512))])),
					_: 2
				}, 1032, ["mode"])])),
				_: 1
			})
		}
	}
};

function Ry(e = {}) {
	e.notFoundComponent ? Ly.push({
		path: "/:pathMatch(.*)*",
		name: "404",
		component: e.notFoundComponent
	}) : Ly.push({
		path: "/:pathMatch(.*)*",
		redirect: "/"
	});
	const t = e.historyMode(Iy()),
		n = Ha(Object.assign({
			routes: Ly,
			history: t
		}, e)),
		i = n.install.bind(n);
	return n.install = function(e) {
		e.component("AnimatedRouterView", Dy), i.call(this, e)
	}, n
}

function ky(e, t = 0, n = 1) {
	return Math.min(Math.max(e, t), n)
}

function Ny(e, t = 0, n = 1) {
	return (e - t) / (n - t)
}

function Oy(e, t, n, i, r) {
	return i + (e - t) / (n - t) * (r - i)
}

function Fy(e, t, n) {
	const i = ky((n - e) / (t - e), 0, 1);
	return i * i * (3 - 2 * i)
}

function zy(e, t, n) {
	return e * (1 - n) + t * n
}

function Uy(e, t, n, i = .001) {
	const r = e * (1 - n) + t * n;
	return Math.abs(t - r) < i ? t : r
}

function By(e, t, n, i) {
	return zy(e, t, 1 - Math.exp(.05 * -n * i))
}

function Vy(e, t, n, i, r) {
	return Uy(e, t, 1 - Math.exp(.05 * -n * i), r)
}
const Hy = e => new Promise((t => setTimeout(t, e)));
let Gy = null;

function Wy() {
	let e, t, n, i, r, s, a, o = !1,
		l = 2,
		c = 0,
		u = !1;
	const h = [],
		d = new Promise((e => s = e)),
		p = Gy = dt({
			progress: 0,
			taskCount: 0,
			taskFinished: 0,
			hidden: !1,
			destroyed: !1,
			task: function(e, {
				weight: t = 1,
				graceful: n = !0
			} = {}) {
				"function" == typeof e && (e = e());
				return y(t), Promise.resolve().then((() => e)).then((() => _(t))).catch((e => {
					n && _(t)
				}))
			},
			createTask: x,
			setMinimumTaskCount: function(e) {
				l = e, p.taskCount = Math.max(l, c)
			},
			beforeExit: function(e) {
				u ? e() : h.push(e)
			}
		});
	return function(s) {
		i = x(), n = s, n.config.globalProperties.$router.beforeEach(g), n.config.globalProperties.$preloader = p, n.provide("preloader", p), t = document.getElementById("preloader"), e = function(e, t) {
			const n = t.querySelector(".preloader-counter"),
				i = t.querySelector(".preloader-background"),
				r = t.querySelector(".preloader-text"),
				s = bu();
			let a = 0,
				o = 0;

			function l(e) {
				e = ky(e, 5, 300);
				let t = By(o, a, .17, e);
				if (t > .99 && (t = 1), t === o) return;
				o = t;
				const i = Math.floor(100 * o).toString().padStart(2, "0");
				n.textContent = Math.min(99, i), o >= 1 && s.resolve()
			}
			return {
				enter: function() {
					Kc.add(l)
				},
				onProgress: function(e) {
					a = e
				},
				exit: async function(e) {
					await s, i.style.transition = "transform 1000ms cubic-bezier(0.910, 0.000, 0.195, 0.990)", i.style.transform = "scaleY(0)", await Hy(400), n.style.transition = "opacity 200ms", n.style.opacity = 0, await Hy(100), r.style.transition = "opacity 200ms", r.style.opacity = 0, await Hy(100), e(), await Hy(1e3)
				},
				beforeDestroy: function() {
					Kc.remove(l)
				}
			}
		}(0, t), e.init && e.init();
		e.enter && (a = e.enter());
		o = () => function() {
			const t = p.progress;
			e.onProgress && e.onProgress(t), t >= 1 && (u || (u = !0, Promise.resolve().then((() => a)).then((() => h.reduce(((e, t) => e.then(t)), Promise.resolve()))).then((() => h.length = 0)).then((() => e.exit && e.exit(f))).then(m).catch((e => {
				m()
			}))))
		}(p.progress), r = Mr(o, null, {
			flush: "post"
		});
		var o
	};

	function f() {
		p.hidden || p.destroyed || (p.hidden = !0, r && r(), r = null, s())
	}

	function m() {
		p.destroyed || (f(), t.parentNode && t.parentNode.removeChild(t), e.beforeDestroy && e.beforeDestroy(), t = null, e = null, p.destroyed = !0)
	}

	function g(e, t, i) {
		o || (n.config.globalProperties.$router.beforeResolve(v), o = !0), i()
	}
	async function v(e, t, n) {
		i.finish(), await d, n()
	}

	function _(e) {
		p.taskFinished += e;
		const t = p.taskFinished / p.taskCount;
		p.progress = Math.max(0, Math.min(1, Math.max(p.progress, t)))
	}

	function y(e) {
		c += e, p.taskCount = Math.max(l, c)
	}

	function x({
		weight: e = 1
	} = {}) {
		let t = !1;
		return y(e), {
			get finished() {
				return t
			},
			finish() {
				t || (t = !0, _(e))
			}
		}
	}
}

function qy(e, t, n, i, r) {
	for (t = t.split ? t.split(".") : t, i = 0; i < t.length; i++) e = e ? e[t[i]] : r;
	return e === r ? n : e
}
const jy = {};

function Yy(e, t = !1) {
	const n = window.__DATA || jy;
	return qy(n, e) || qy(n.site, e) || qy(n.page, e) || (t ? e : "")
}

function Xy(e) {
	const t = e.tag || e.tagName || "span";
	let n = e.debug;
	"string" != typeof n || n.length || (n = !0);
	return Ar(t, {
		innerHTML: Yy(e.id || "", !!n)
	})
}

function $y() {
	return {
		install: function(e) {
			e.config.globalProperties.$l = Yy, e.config.globalProperties.$translation = Yy, e.provide("translation", Yy), e.component("Translation", Xy), e.component("L", Xy)
		}
	}
}
const Zy = "unknown",
	Ky = (e, t) => t.reduce(((t, n) => t || !!e.match(n)), !1),
	Jy = (e, t) => {
		for (const n in t)
			if (Ky(e, t[n])) return n
	},
	Qy = {
		edge: ["edge"],
		chrome: ["chrome", "crios"],
		firefox: ["firefox", "fxios"],
		ie: ["msie", "trident", "rv:"],
		ucbrowser: ["ucbrowser"],
		safari: ["safari", "ios"],
		opera: ["opera", "opios"]
	},
	ex = {
		0: "verylow",
		1: "low",
		2: "medium",
		3: "high",
		4: "veryhigh",
		5: "ultra"
	};

function tx(e, t = !1) {
	const n = {};
	if (t) return Object.assign(n, {
		type: {
			desktop: !0
		},
		os: "windows",
		browser: "chrome",
		browserVersion: "77",
		gpu: sx("low")
	});
	n.userAgent = "string" == typeof e ? e : navigator.userAgent.toLowerCase(), n.hasTouch = "ontouchstart" in window || navigator.maxTouchPoints > 1, n.type = function({
		hasTouch: e,
		userAgent: t
	}) {
		const n = ["ios", "iphone", "ipad", "phone", "android", "blackberry"],
			i = Math.max(screen.width, screen.height) > 900,
			r = nx(t, e),
			s = !!(r || e && Ky(t, n)),
			a = !(!s || !r && !i),
			o = !s;
		return {
			desktop: o,
			mobile: s,
			tablet: a,
			phone: !o && !a
		}
	}(n), n.os = function({
		hasTouch: e,
		type: t,
		userAgent: n
	}) {
		if (nx(n, e)) return "ios";
		const i = {
				desktop: {
					windows: ["windows", "iemobile"],
					linux: ["linux"],
					macos: ["mac os"]
				},
				mobile: {
					android: ["android"],
					ios: ["ipad", "iphone"],
					blackberry: ["blackberry"]
				}
			},
			r = t.desktop ? i.desktop : i.mobile;
		return Jy(n, r) || "unknown"
	}(n), n.browser = function({
		userAgent: e,
		os: t
	}) {
		const n = Jy(e, Qy);
		return n || ("ios" === t ? "safari" : Zy)
	}(n), n.browserVersion = function({
		userAgent: e,
		browser: t
	}) {
		const n = t => {
			const n = e.split(t)[1];
			if (!n || n.length <= 0) return;
			const i = parseFloat(n.split(" ")[0].split(".")[0].replace(/[^.0-9]/g, ""));
			return isNaN(i) ? void 0 : i
		};
		switch (t) {
			case "chrome":
			case "firefox":
				return void Qy[t].forEach((e => {
					const t = n(e);
					if (null !== t || void 0 !== t) return t
				}));
			case "safari":
				let i = e.match(/version\/([.\d]+)/i);
				return i && i[1] ? parseFloat(i[1]) : (i = e.match(/os ([0-9_]+)/i), i && i[1] ? parseFloat(i[1].split("_")[0]) : void 0);
			case "ie":
			case "edge":
				return Ky(e, ["msie"]) ? n("msie") : Ky(e, ["rv:"]) ? n("rv:") : n("edge/");
			default:
				return
		}
	}(n);
	let i = ix(n, !0);
	const r = !i;
	return rx(), i = ix(n, !1), n.majorPerformanceCaveat = i && r, n.webgl = i ? function(e, t) {
		const n = ["WEBKIT_", "MOZ_"];
		let i = t.getSupportedExtensions() || [];
		i = i.reduce(((e, t) => {
			for (let i = 0; i < n.length; i++)
				if (!t.indexOf(n[i])) return e[t.substring(n[i].length)] = t, e;
			return e[t] = t, e
		}), {});
		const r = "WEBGL_compressed_texture_",
			s = ["s3tc", "astc", "etc", "pvrtc"].reduce(((e, t) => (e[t] = !!i[r + t], e)), {});
		return {
			renderer: (t.getParameter(t.RENDERER) || "").toLowerCase(),
			version: (t.getParameter(t.VERSION) || "").toLowerCase(),
			glsl: (t.getParameter(t.SHADING_LANGUAGE_VERSION) || "").toLowerCase(),
			extensions: i,
			compressedTextures: s
		}
	}(0, i) : null, n.gpu = i ? function({
		os: e,
		webgl: t
	}, n) {
		const i = {
				string: null,
				quality: {
					low: !0
				},
				qualityIndex: 1,
				type: null,
				series: null,
				version: null,
				numbers: [],
				isMobile: null
			},
			r = {
				intel: ["intel"],
				nvidia: ["nvidia", "geforce"],
				amd: ["amd", "radeon"],
				adreno: ["adreno"],
				apple: ["apple"],
				mali: ["mali"],
				swiftshader: ["swiftshader"]
			},
			s = n.getExtension(t.extensions.WEBGL_debug_renderer_info),
			a = s ? n.getParameter(s.UNMASKED_RENDERER_WEBGL) : "";
		if (!s || !a.length) return i;
		if (i.string = function(e) {
				let t = e.toLowerCase();
				t = t.replace(/(\(tm\)|\(r\))/g, ""), t = t.trim(), t.includes("angle (") && t.includes("direct3d") && (t = t.replace("angle (", "").split(" direct3d")[0]);
				t.includes("nvidia") && t.includes("gb") && (t = t.split(/\dgb/)[0]);
				return t
			}(a), i.type = Jy(i.string, r) || Zy, i.type === Zy) return i;
		"ios" === e && "apple gpu" === i.string && (i.string = function({
			os: e,
			type: t
		}, n) {
			const i = window.devicePixelRatio,
				r = Math.min(window.screen.width, window.screen.height) * i,
				s = Math.max(window.screen.width, window.screen.height) * i,
				a = "ios" === e && t.tablet,
				o = "\n\t\t// Credits: @Samsy\n\t\tprecision highp float;\n\t\tattribute vec3 position;\n\t\tvarying float vvv;\n\t\tvoid main() {\n\t\t\tvvv = 0.31622776601683794;\n\t\t\tgl_Position = vec4(position, 1.0);\n\t\t}\n\t",
				l = "\n\t\t// Credits: @Samsy\n\t\tprecision highp float;\n\t\tvarying float vvv;\n\t\tvoid main() {\n\t\t\tvec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n\t\t\tenc = fract(enc);\n\t\t\tenc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n\t\t\tgl_FragColor = enc;\n\t\t}\n\t";
			let c = 0;
			const u = n.createShader(35633),
				h = n.createShader(35632),
				d = n.createProgram();
			if (null !== h && null !== u && null !== d) {
				n.shaderSource(u, o), n.shaderSource(h, l), n.compileShader(u), n.compileShader(h), n.attachShader(d, u), n.attachShader(d, h), n.linkProgram(d), n.detachShader(d, u), n.detachShader(d, h), n.deleteShader(u), n.deleteShader(h), n.useProgram(d);
				const e = n.createBuffer(),
					t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
				n.bindBuffer(34962, e), n.bufferData(34962, t, 35044);
				const i = n.getAttribLocation(d, "position");
				n.vertexAttribPointer(i, 3, 5126, !1, 0, 0), n.enableVertexAttribArray(i), n.clearColor(1, 1, 1, 1), n.clear(16384), n.viewport(0, 0, 1, 1), n.drawArrays(4, 0, 3);
				const r = new Uint8Array(4);
				n.readPixels(0, 0, 1, 1, 6408, 5121, r);
				const s = r.join("");
				n.deleteProgram(d), n.deleteBuffer(e), "801621810" === s ? c = 11 : "8016218135" === s && (c = 8)
			}
			return a && 8 === c ? "apple a8 gpu" : a && 11 === c ? "apple a11 gpu" : a && s <= 1024 ? "apple a8 gpu" : a && s >= 2200 ? "apple a10 gpu" : !a && r < 640 ? "apple a6 gpu" : !a && r <= 640 ? 8 === c ? "apple a8 gpu" : "apple a7 gpu" : !a && r <= 750 || !a && r <= 1080 ? "apple a9 gpu" : !a && s >= 2e3 ? "apple a10 gpu" : "apple gpu"
		}(i, n));
		return i.isMobile = "m" === i.string[i.string.length - 1], Object.assign(i, function(e) {
			const t = e.split(" ").map((e => e.replace(/[\D]/g, ""))).filter((e => e.length > 0)).map((e => parseFloat(e))),
				n = t[0] || null;
			return {
				numbers: t,
				version: n
			}
		}(i.string)), i.series = function(e) {
			const t = {
					swiftshader: "swiftshader",
					"apple a": "apple gpu",
					"apple m1": "apple m1",
					"apple m": "apple m",
					"geforce gtx": "geforce gtx",
					"geforce rtx": "geforce rtx",
					"geforce mx": "geforce mx",
					titan: "geforce titan",
					"quadro fx": "quadro fx",
					"quadro p": "quadro p",
					"quadro rtx": "quadro rtx",
					"quadro ": "quadro",
					"geforce ": "geforce",
					"tegra ": "tegra",
					"radeon vii": "radeon vii",
					"radeon r7": "radeon r7",
					"radeon r9": "radeon r9",
					"radeon r10": "radeon r10",
					"radeon rx": "radeon rx",
					"radeon pro vega": "radeon pro vega",
					"radeon rx vega": "radeon rx vega",
					"radeon hd": "radeon hd",
					"radeon pro ": "radeon pro",
					"radeon ": "radeon",
					"intel iris ": "intel iris",
					"intel iris plus ": "intel iris plus",
					"intel iris pro ": "intel iris pro",
					"intel hd ": "intel hd",
					"intel uhd ": "intel uhd",
					adreno: "adreno",
					"mali-t": "mali t",
					"mali-g": "mali g",
					mali: "mali"
				},
				n = {};
			for (const i in t) e.indexOf(i) > -1 && (n[t[i]] = !0);
			return n
		}(i.string), Object.assign(i, function({
			type: e,
			browser: t
		}, n) {
			if (!n || !n.type || "swiftshader" === n.type) return "firefox" === t && e.desktop ? sx("medium") : sx("low");
			const i = n.isMobile,
				r = n.type,
				s = n.series,
				a = n.version || 0,
				o = n.string.match(/(?:^| )mp(\d)+(?: |$)/i),
				l = o ? parseFloat(o[1]) : 1,
				c = e => s[e],
				u = (e, t, n) => c(e) && t <= a && (void 0 === n || l <= n),
				h = (e, t, n) => c(e) && a >= t && (void 0 === n || l >= n),
				d = {
					veryhigh: [c("geforce rtx"), c("geforce titan"), c("quadro gtx"), i && h("geforce gtx", 780), !i && h("geforce gtx", 680), h("quadro p", 400), c("radeon vii") || c("radeon r10") || c("radeon r9"), h("radeon r7", 370), h("radeon rx", 570), h("radeon rx vega", 56)],
					high: [c("geforce gtx"), c("apple m"), h("geforce mx", 150), h("radeon pro", 450), h("radeon hd", 5570) && !i, (h("intel iris plus", 650) || h("intel iris pro", 580)) && u("intel iris", 5e3), h("adreno", 418), h("apple gpu", 9), h("mali g", 71), h("mali t", 760, 8) || h("mali t", 880)],
					medium: ["nvidia" === r || "amd" === r, c("intel iris plus") || c("intel iris pro"), h("intel hd", 630) && u("intel hd", 2e3), h("adreno", 430), h("apple gpu", 8), c("mali g"), h("mali t", 800, 2) || h("mali t", 860)]
				};
			let p = "low";
			for (const f in d) {
				for (let e = 0, t = d[f].length; e < t; e++)
					if (d[f][e]) {
						p = f;
						break
					} if ("low" !== p) break
			}
			return sx(p)
		}(s, i)), i
	}(n, i) : sx("low"), rx(), n
}

function nx(e, t) {
	const n = Ky(e, ["ipad", "mac", "macos"]),
		i = Ky(e, ["iphone"]),
		r = "MacIntel" === navigator.platform;
	return !(i || !n || !r || !t)
}

function ix(e, t) {
	const n = document.createElement("canvas");
	let i;
	try {
		const r = {
			alpha: !1,
			antialias: !1,
			depth: !1,
			failIfMajorPerformanceCaveat: t,
			powerPreference: "high-performance",
			stencil: !1
		};
		"safari" === e.browser && 12 === e.browserVersion && e.type.desktop && delete r.powerPreference, i = n.getContext("webgl", r) || n.getContext("webgl-experimental", r) || n.getContext("experimental-webgl", r)
	} catch (r) {}
	return i
}

function rx(e) {
	e && e.getExtension("WEBGL_lose_context") && e.getExtension("WEBGL_lose_context").loseContext()
}

function sx(e) {
	const t = ex;
	return {
		qualities: t,
		qualityIndex: Math.max(0, Object.values(t).indexOf(e))
	}
}

function ax(e = {}) {
	const t = {
		install: function(i) {
			i.config.globalProperties.$device = t, i.provide("device", t),
				function() {
					const i = tx(e.userAgent);
					Object.assign(t, i), n(t.gpu.qualityIndex),
						function(e) {
							const t = document.documentElement;
							e.hasTouch && t.classList.add("touch");
							for (const n in e.type) e.type[n] && t.classList.add(n.toLowerCase());
							e.browser && e.browser.length > 0 && t.classList.add(e.browser.toLowerCase());
							e.os && e.os.length > 0 && "Unknown" !== e.os && t.classList.add(e.os.toLowerCase())
						}(t)
				}(), delete t.install
		},
		updateQuality: n
	};
	return t;

	function n(e) {
		const n = document.documentElement;
		if (!t.gpu) return;
		t.gpu.qualityIndex = e;
		const i = t.gpu.qualities;
		for (const r in i) t.gpu && t.gpu.quality && (t.gpu.quality[i[r]] = r <= e), n.classList.toggle(i[r], e == r)
	}
}
const ox = document.documentElement;
let lx, cx;

function ux() {
	const e = Tt(),
		t = Tt(),
		n = Tt(),
		i = Tt(),
		r = Tt(),
		s = wu(l, 500, {
			trail: !1
		});
	let a = null;
	const o = cx = {
		install: function(e) {
			e.config.globalProperties.$viewport = o, e.provide("viewport", o), lx = document.createElement("div"), Object.assign(lx.style, {
				position: "fixed",
				top: 0,
				left: 0,
				width: "200px",
				height: "10px",
				overflowY: "scroll",
				pointerEvents: "none",
				userSelect: "none",
				zIndex: -1,
				opacity: 0
			}), a = {
				measureScrollbarWidth: function() {
					const e = document.createElement("div");
					Object.assign(lx.style, {
						width: "200px",
						height: "10px",
						overflowY: "scroll"
					}), Object.assign(e.style, {
						width: "100%",
						height: "150%"
					}), lx.appendChild(e), document.body.appendChild(lx);
					const t = parseFloat(getComputedStyle(ox).zoom),
						n = isNaN(t) ? 1 : t,
						i = Math.round((200 - lx.clientWidth) * n);
					return ox.style.setProperty("--scrollbar-width", i + "px"), document.body.removeChild(lx), lx.removeChild(e), Object.assign(lx.style, {
						width: "1px",
						height: "100%",
						overflowY: "hidden"
					}), i
				},
				measureViewportHeight: function() {
					document.body.appendChild(lx);
					const e = lx.getBoundingClientRect().height;
					return document.body.removeChild(lx), ox.style.setProperty("--inner-height", window.innerHeight + "px"), ox.style.setProperty("--vp-height", e + "px"), e
				}
			}, a.measureScrollbarWidth(), document.addEventListener("visibilitychange", u, !1), setInterval(c, 5e3), window.addEventListener("resize", (() => {
				l(), s()
			}), !1), l(), c(), u(), delete o.install
		},
		width: e,
		height: t,
		viewportRatio: i,
		pixelRatio: n,
		visible: r
	};
	return o;

	function l() {
		e.value = window.innerWidth, t.value = a.measureViewportHeight(), i.value = e.value / t.value
	}

	function c() {
		n.value = window.devicePixelRatio || 1
	}

	function u() {
		r.value = !document.hidden, l()
	}
}
const hx = {
	setup(e, {
		expose: t
	}) {
		const n = Tt(),
			i = Gi() ? Yt("webGL") : MN;
		let r = Tt();
		return pn((() => {
			r.value = i.getElement(), r.value.classList.add("webgl-canvas"), n.value.appendChild(r.value)
		})), vn((() => {
			r = null
		})), t({
			wrapper: n,
			canvas: r
		}), (e, t) => t[0] || (mi(-1), t[0] = Mi("aside", {
			ref: (e, t) => {
				t.wrapper = e, n.value = e
			},
			class: "webgl-wrapper"
		}, null, 512), mi(1), t[0])
	}
};
let dx = null;

function px(e) {
	if (null !== dx && (dx.property, 1)) {
		const e = dx;
		return dx = px.prototype = null, e
	}
	return dx = px.prototype = null == e ? Object.create(null) : e, new px
}
for (let ga = 0; ga <= 10; ga++) px();

function fx(e, t, n = 0) {
	if ("string" == typeof e && (e = t[e]), 0 === n) return function() {
		return e.call(t)
	};
	if (1 === n) return function(n) {
		return e.call(t, n)
	};
	if (2 === n) return function(n, i) {
		return e.call(t, n, i)
	};
	if (3 === n) return function(n, i, r) {
		return e.call(t, n, i, r)
	};
	if (4 === n) return function(n, i, r, s) {
		return e.call(t, n, i, r, s)
	};
	if (5 === n) return function(n, i, r, s, a) {
		return e.call(t, n, i, r, s, a)
	};
	throw new Error("Too many arguments")
}

function mx(e, t, n = Number.MAX_SAFE_INTEGER) {
	const i = [];

	function r() {
		return new e
	}
	return "function" == typeof t && (e.prototype.onPoolReset = t), e.prototype.release = function() {
		return e.release(this), this
	}, e.alloc = function(t) {
		if (!(t <= 0))
			for (; t--;) e.release(r())
	}, e.get = function() {
		const e = i.pop() || r();
		return e.onPoolReset && e.onPoolReset(e), e
	}, e.release = function() {
		let e = arguments.length;
		for (; e--;) i.length < n && i.push(arguments[e])
	}, e
}
class gx {
	addEventListener(e, t) {
		void 0 === this._listeners && (this._listeners = {});
		const n = this._listeners;
		void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
	}
	hasEventListener(e, t) {
		if (void 0 === this._listeners) return !1;
		const n = this._listeners;
		return void 0 !== n[e] && -1 !== n[e].indexOf(t)
	}
	removeEventListener(e, t) {
		if (void 0 === this._listeners) return;
		const n = this._listeners[e];
		if (void 0 !== n) {
			const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
		}
	}
	dispatchEvent(e) {
		if (void 0 === this._listeners) return;
		const t = this._listeners[e.type];
		if (void 0 !== t) {
			e.target = this;
			const n = t.slice(0);
			for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
			e.target = null
		}
	}
}
const vx = Math.PI / 180,
	_x = 180 / Math.PI,
	yx = [];
for (let ga = 0; ga < 256; ga++) yx[ga] = (ga < 16 ? "0" : "") + ga.toString(16);
const xx = "undefined" != typeof crypto && "randomUUID" in crypto;

function bx() {
	if (xx) return crypto.randomUUID().toUpperCase();
	const e = 4294967295 * Math.random() | 0,
		t = 4294967295 * Math.random() | 0,
		n = 4294967295 * Math.random() | 0,
		i = 4294967295 * Math.random() | 0;
	return (yx[255 & e] + yx[e >> 8 & 255] + yx[e >> 16 & 255] + yx[e >> 24 & 255] + "-" + yx[255 & t] + yx[t >> 8 & 255] + "-" + yx[t >> 16 & 15 | 64] + yx[t >> 24 & 255] + "-" + yx[63 & n | 128] + yx[n >> 8 & 255] + "-" + yx[n >> 16 & 255] + yx[n >> 24 & 255] + yx[255 & i] + yx[i >> 8 & 255] + yx[i >> 16 & 255] + yx[i >> 24 & 255]).toUpperCase()
}

function wx(e, t, n) {
	return Math.max(t, Math.min(n, e))
}

function Sx(e, t, n) {
	return (1 - n) * e + n * t
}

function Mx(e) {
	return 0 == (e & e - 1) && 0 !== e
}

function Tx(e) {
	return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
}
class Cx {
	constructor(e = 0, t = 0) {
		this.x = e, this.y = t
	}
	get width() {
		return this.x
	}
	set width(e) {
		this.x = e
	}
	get height() {
		return this.y
	}
	set height(e) {
		this.y = e
	}
	set(e, t) {
		return this.x = e, this.y = t, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this
	}
	add(e, t) {
		return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this)
	}
	addScalar(e) {
		return this.x += e, this.y += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this
	}
	sub(e, t) {
		return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this)
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this
	}
	multiply(e) {
		return this.x *= e.x, this.y *= e.y, this
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this
	}
	divide(e) {
		return this.x /= e.x, this.y /= e.y, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	applyMatrix3(e) {
		const t = this.x,
			n = this.y,
			i = e.elements;
		return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this
	}
	roundToZero() {
		return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y
	}
	cross(e) {
		return this.x * e.y - this.y * e.x
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e))
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			n = this.y - e.y;
		return t * t + n * n
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
	}
	lerpVectors(e, t, n) {
		return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
	}
	equals(e) {
		return e.x === this.x && e.y === this.y
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e
	}
	fromBufferAttribute(e, t, n) {
		return this.x = e.getX(t), this.y = e.getY(t), this
	}
	rotateAround(e, t) {
		const n = Math.cos(t),
			i = Math.sin(t),
			r = this.x - e.x,
			s = this.y - e.y;
		return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y
	}
}
Cx.prototype.isVector2 = !0;
class Ex {
	constructor() {
		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
	}
	set(e, t, n, i, r, s, a, o, l) {
		const c = this.elements;
		return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
	}
	copy(e) {
		const t = this.elements,
			n = e.elements;
		return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
	}
	extractBasis(e, t, n) {
		return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
	}
	setFromMatrix4(e) {
		const t = e.elements;
		return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
	}
	multiply(e) {
		return this.multiplyMatrices(this, e)
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this)
	}
	multiplyMatrices(e, t) {
		const n = e.elements,
			i = t.elements,
			r = this.elements,
			s = n[0],
			a = n[3],
			o = n[6],
			l = n[1],
			c = n[4],
			u = n[7],
			h = n[2],
			d = n[5],
			p = n[8],
			f = i[0],
			m = i[3],
			g = i[6],
			v = i[1],
			_ = i[4],
			y = i[7],
			x = i[2],
			b = i[5],
			w = i[8];
		return r[0] = s * f + a * v + o * x, r[3] = s * m + a * _ + o * b, r[6] = s * g + a * y + o * w, r[1] = l * f + c * v + u * x, r[4] = l * m + c * _ + u * b, r[7] = l * g + c * y + u * w, r[2] = h * f + d * v + p * x, r[5] = h * m + d * _ + p * b, r[8] = h * g + d * y + p * w, this
	}
	multiplyScalar(e) {
		const t = this.elements;
		return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			i = e[2],
			r = e[3],
			s = e[4],
			a = e[5],
			o = e[6],
			l = e[7],
			c = e[8];
		return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
	}
	invert() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			i = e[2],
			r = e[3],
			s = e[4],
			a = e[5],
			o = e[6],
			l = e[7],
			c = e[8],
			u = c * s - a * l,
			h = a * o - c * r,
			d = l * r - s * o,
			p = t * u + n * h + i * d;
		if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const f = 1 / p;
		return e[0] = u * f, e[1] = (i * l - c * n) * f, e[2] = (a * n - i * s) * f, e[3] = h * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * r) * f, this
	}
	transpose() {
		let e;
		const t = this.elements;
		return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
	}
	getNormalMatrix(e) {
		return this.setFromMatrix4(e).invert().transpose()
	}
	transposeIntoArray(e) {
		const t = this.elements;
		return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
	}
	setUvTransform(e, t, n, i, r, s, a) {
		const o = Math.cos(r),
			l = Math.sin(r);
		return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1), this
	}
	scale(e, t) {
		const n = this.elements;
		return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
	}
	rotate(e) {
		const t = Math.cos(e),
			n = Math.sin(e),
			i = this.elements,
			r = i[0],
			s = i[3],
			a = i[6],
			o = i[1],
			l = i[4],
			c = i[7];
		return i[0] = t * r + n * o, i[3] = t * s + n * l, i[6] = t * a + n * c, i[1] = -n * r + t * o, i[4] = -n * s + t * l, i[7] = -n * a + t * c, this
	}
	translate(e, t) {
		const n = this.elements;
		return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
	}
	equals(e) {
		const t = this.elements,
			n = e.elements;
		for (let i = 0; i < 9; i++)
			if (t[i] !== n[i]) return !1;
		return !0
	}
	fromArray(e, t = 0) {
		for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
		return this
	}
	toArray(e = [], t = 0) {
		const n = this.elements;
		return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
	}
	clone() {
		return (new this.constructor).fromArray(this.elements)
	}
}

function Ax(e) {
	if (0 === e.length) return -Infinity;
	let t = e[0];
	for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
	return t
}

function Px(e) {
	return document.createElementNS("http://www.w3.org/1999/xhtml", e)
}
let Lx;
Ex.prototype.isMatrix3 = !0;
let Ix = 0;
class Dx extends gx {
	constructor(e = Dx.DEFAULT_IMAGE, t = Dx.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
		super(), Object.defineProperty(this, "id", {
			value: Ix++
		}), this.uuid = bx(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new Cx(0, 0), this.repeat = new Cx(1, 1), this.center = new Cx(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ex, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
	}
	toJSON(e) {
		const t = void 0 === e || "string" == typeof e;
		if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
		const n = {
			metadata: {
				version: 4.5,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			mapping: this.mapping,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			type: this.type,
			encoding: this.encoding,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		if (void 0 !== this.image) {
			const i = this.image;
			if (void 0 === i.uuid && (i.uuid = bx()), !t && void 0 === e.images[i.uuid]) {
				let t;
				if (Array.isArray(i)) {
					t = [];
					for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Rx(i[e].image)) : t.push(Rx(i[e]))
				} else t = Rx(i);
				e.images[i.uuid] = {
					uuid: i.uuid,
					url: t
				}
			}
			n.image = i.uuid
		}
		return t || (e.textures[this.uuid] = n), n
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	transformUv(e) {
		if (300 !== this.mapping) return e;
		if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
			case 1e3:
				e.x = e.x - Math.floor(e.x);
				break;
			case 1001:
				e.x = e.x < 0 ? 0 : 1;
				break;
			case 1002:
				1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
		}
		if (e.y < 0 || e.y > 1) switch (this.wrapT) {
			case 1e3:
				e.y = e.y - Math.floor(e.y);
				break;
			case 1001:
				e.y = e.y < 0 ? 0 : 1;
				break;
			case 1002:
				1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
		}
		return this.flipY && (e.y = 1 - e.y), e
	}
	set needsUpdate(e) {
		!0 === e && this.version++
	}
}

function Rx(e) {
	return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? class {
		static getDataURL(e) {
			if (/^data:/i.test(e.src)) return e.src;
			if ("undefined" == typeof HTMLCanvasElement) return e.src;
			let t;
			if (e instanceof HTMLCanvasElement) t = e;
			else {
				void 0 === Lx && (Lx = Px("canvas")), Lx.width = e.width, Lx.height = e.height;
				const n = Lx.getContext("2d");
				e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Lx
			}
			return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
		}
	}.getDataURL(e) : e.data ? {
		data: Array.prototype.slice.call(e.data),
		width: e.width,
		height: e.height,
		type: e.data.constructor.name
	} : {}
}
Dx.DEFAULT_IMAGE = void 0, Dx.DEFAULT_MAPPING = 300, Dx.prototype.isTexture = !0;
class kx {
	constructor(e = 0, t = 0, n = 0, i = 1) {
		this.x = e, this.y = t, this.z = n, this.w = i
	}
	get width() {
		return this.z
	}
	set width(e) {
		this.z = e
	}
	get height() {
		return this.w
	}
	set height(e) {
		this.w = e
	}
	set(e, t, n, i) {
		return this.x = e, this.y = t, this.z = n, this.w = i, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this.z = e, this.w = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setZ(e) {
		return this.z = e, this
	}
	setW(e) {
		return this.w = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			case 3:
				this.w = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
	}
	add(e, t) {
		return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
	}
	addScalar(e) {
		return this.x += e, this.y += e, this.z += e, this.w += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
	}
	sub(e, t) {
		return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
	}
	multiply(e) {
		return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
	}
	applyMatrix4(e) {
		const t = this.x,
			n = this.y,
			i = this.z,
			r = this.w,
			s = e.elements;
		return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	setAxisAngleFromQuaternion(e) {
		this.w = 2 * Math.acos(e.w);
		const t = Math.sqrt(1 - e.w * e.w);
		return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
	}
	setAxisAngleFromRotationMatrix(e) {
		let t, n, i, r;
		const s = .01,
			a = .1,
			o = e.elements,
			l = o[0],
			c = o[4],
			u = o[8],
			h = o[1],
			d = o[5],
			p = o[9],
			f = o[2],
			m = o[6],
			g = o[10];
		if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
			if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this;
			t = Math.PI;
			const e = (l + 1) / 2,
				o = (d + 1) / 2,
				v = (g + 1) / 2,
				_ = (c + h) / 4,
				y = (u + f) / 4,
				x = (p + m) / 4;
			return e > o && e > v ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = _ / n, r = y / n) : o > v ? o < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = _ / i, r = x / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = y / r, i = x / r), this.set(n, i, r, t), this
		}
		let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
		return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
	}
	roundToZero() {
		return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
	}
	lerpVectors(e, t, n) {
		return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
	}
	fromBufferAttribute(e, t, n) {
		return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w
	}
}
kx.prototype.isVector4 = !0;
class Nx extends gx {
	constructor(e, t, n = {}) {
		super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new kx(0, 0, e, t), this.scissorTest = !1, this.viewport = new kx(0, 0, e, t), this.texture = new Dx(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
			width: e,
			height: t,
			depth: 1
		}, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
	}
	setTexture(e) {
		e.image = {
			width: this.width,
			height: this.height,
			depth: this.depth
		}, this.texture = e
	}
	setSize(e, t, n = 1) {
		this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = o({}, this.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
Nx.prototype.isWebGLRenderTarget = !0;
class Ox extends Nx {
	constructor(e, t, n) {
		super(e, t, n), this.samples = 4
	}
	copy(e) {
		return super.copy.call(this, e), this.samples = e.samples, this
	}
}
Ox.prototype.isWebGLMultisampleRenderTarget = !0;
class Fx {
	constructor(e = 0, t = 0, n = 0, i = 1) {
		this._x = e, this._y = t, this._z = n, this._w = i
	}
	static slerp(e, t, n, i) {
		return n.slerpQuaternions(e, t, i)
	}
	static slerpFlat(e, t, n, i, r, s, a) {
		let o = n[i + 0],
			l = n[i + 1],
			c = n[i + 2],
			u = n[i + 3];
		const h = r[s + 0],
			d = r[s + 1],
			p = r[s + 2],
			f = r[s + 3];
		if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
		if (1 === a) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = f);
		if (u !== f || o !== h || l !== d || c !== p) {
			let e = 1 - a;
			const t = o * h + l * d + c * p + u * f,
				n = t >= 0 ? 1 : -1,
				i = 1 - t * t;
			if (i > Number.EPSILON) {
				const r = Math.sqrt(i),
					s = Math.atan2(r, t * n);
				e = Math.sin(e * s) / r, a = Math.sin(a * s) / r
			}
			const r = a * n;
			if (o = o * e + h * r, l = l * e + d * r, c = c * e + p * r, u = u * e + f * r, e === 1 - a) {
				const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
				o *= e, l *= e, c *= e, u *= e
			}
		}
		e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
	}
	static multiplyQuaternionsFlat(e, t, n, i, r, s) {
		const a = n[i],
			o = n[i + 1],
			l = n[i + 2],
			c = n[i + 3],
			u = r[s],
			h = r[s + 1],
			d = r[s + 2],
			p = r[s + 3];
		return e[t] = a * p + c * u + o * d - l * h, e[t + 1] = o * p + c * h + l * u - a * d, e[t + 2] = l * p + c * d + a * h - o * u, e[t + 3] = c * p - a * u - o * h - l * d, e
	}
	get x() {
		return this._x
	}
	set x(e) {
		this._x = e, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(e) {
		this._y = e, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(e) {
		this._z = e, this._onChangeCallback()
	}
	get w() {
		return this._w
	}
	set w(e) {
		this._w = e, this._onChangeCallback()
	}
	set(e, t, n, i) {
		return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w)
	}
	copy(e) {
		return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
	}
	setFromEuler(e, t) {
		if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
		const n = e._x,
			i = e._y,
			r = e._z,
			s = e._order,
			a = Math.cos,
			o = Math.sin,
			l = a(n / 2),
			c = a(i / 2),
			u = a(r / 2),
			h = o(n / 2),
			d = o(i / 2),
			p = o(r / 2);
		switch (s) {
			case "XYZ":
				this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
				break;
			case "YXZ":
				this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
				break;
			case "ZXY":
				this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
				break;
			case "ZYX":
				this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
				break;
			case "YZX":
				this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
				break;
			case "XZY":
				this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p
		}
		return !1 !== t && this._onChangeCallback(), this
	}
	setFromAxisAngle(e, t) {
		const n = t / 2,
			i = Math.sin(n);
		return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
	}
	setFromRotationMatrix(e) {
		const t = e.elements,
			n = t[0],
			i = t[4],
			r = t[8],
			s = t[1],
			a = t[5],
			o = t[9],
			l = t[2],
			c = t[6],
			u = t[10],
			h = n + a + u;
		if (h > 0) {
			const e = .5 / Math.sqrt(h + 1);
			this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (s - i) * e
		} else if (n > a && n > u) {
			const e = 2 * Math.sqrt(1 + n - a - u);
			this._w = (c - o) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e
		} else if (a > u) {
			const e = 2 * Math.sqrt(1 + a - n - u);
			this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (o + c) / e
		} else {
			const e = 2 * Math.sqrt(1 + u - n - a);
			this._w = (s - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
		}
		return this._onChangeCallback(), this
	}
	setFromUnitVectors(e, t) {
		let n = e.dot(t) + 1;
		return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
	}
	angleTo(e) {
		return 2 * Math.acos(Math.abs(wx(this.dot(e), -1, 1)))
	}
	rotateTowards(e, t) {
		const n = this.angleTo(e);
		if (0 === n) return this;
		const i = Math.min(1, t / n);
		return this.slerp(e, i), this
	}
	identity() {
		return this.set(0, 0, 0, 1)
	}
	invert() {
		return this.conjugate()
	}
	conjugate() {
		return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
	}
	dot(e) {
		return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
	}
	normalize() {
		let e = this.length();
		return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
	}
	multiply(e, t) {
		return void 0 !== t ? this.multiplyQuaternions(e, t) : this.multiplyQuaternions(this, e)
	}
	premultiply(e) {
		return this.multiplyQuaternions(e, this)
	}
	multiplyQuaternions(e, t) {
		const n = e._x,
			i = e._y,
			r = e._z,
			s = e._w,
			a = t._x,
			o = t._y,
			l = t._z,
			c = t._w;
		return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this
	}
	slerp(e, t) {
		if (0 === t) return this;
		if (1 === t) return this.copy(e);
		const n = this._x,
			i = this._y,
			r = this._z,
			s = this._w;
		let a = s * e._w + n * e._x + i * e._y + r * e._z;
		if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
		const o = 1 - a * a;
		if (o <= Number.EPSILON) {
			const e = 1 - t;
			return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
		}
		const l = Math.sqrt(o),
			c = Math.atan2(l, a),
			u = Math.sin((1 - t) * c) / l,
			h = Math.sin(t * c) / l;
		return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
	}
	slerpQuaternions(e, t, n) {
		this.copy(e).slerp(t, n)
	}
	random() {
		const e = Math.random(),
			t = Math.sqrt(1 - e),
			n = Math.sqrt(e),
			i = 2 * Math.PI * Math.random(),
			r = 2 * Math.PI * Math.random();
		return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
	}
	fromArray(e, t = 0) {
		return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
	}
	toArray(e = [], t = 0) {
		return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
	}
	fromBufferAttribute(e, t) {
		return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
	}
	_onChange(e) {
		return this._onChangeCallback = e, this
	}
	_onChangeCallback() {}
}
Fx.prototype.isQuaternion = !0;
class zx {
	constructor(e = 0, t = 0, n = 0) {
		this.x = e, this.y = t, this.z = n
	}
	set(e, t, n) {
		return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
	}
	setScalar(e) {
		return this.x = e, this.y = e, this.z = e, this
	}
	setX(e) {
		return this.x = e, this
	}
	setY(e) {
		return this.y = e, this
	}
	setZ(e) {
		return this.z = e, this
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			default:
				throw new Error("index is out of range: " + e)
		}
		return this
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new Error("index is out of range: " + e)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z)
	}
	copy(e) {
		return this.x = e.x, this.y = e.y, this.z = e.z, this
	}
	add(e, t) {
		return void 0 !== t ? this.addVectors(e, t) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
	}
	addScalar(e) {
		return this.x += e, this.y += e, this.z += e, this
	}
	addVectors(e, t) {
		return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
	}
	addScaledVector(e, t) {
		return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
	}
	sub(e, t) {
		return void 0 !== t ? this.subVectors(e, t) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
	}
	subScalar(e) {
		return this.x -= e, this.y -= e, this.z -= e, this
	}
	subVectors(e, t) {
		return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
	}
	multiply(e, t) {
		return void 0 !== t ? this.multiplyVectors(e, t) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
	}
	multiplyScalar(e) {
		return this.x *= e, this.y *= e, this.z *= e, this
	}
	multiplyVectors(e, t) {
		return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
	}
	applyEuler(e) {
		return !e || e.isEuler, this.applyQuaternion(Bx.setFromEuler(e))
	}
	applyAxisAngle(e, t) {
		return this.applyQuaternion(Bx.setFromAxisAngle(e, t))
	}
	applyMatrix3(e) {
		const t = this.x,
			n = this.y,
			i = this.z,
			r = e.elements;
		return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
	}
	applyNormalMatrix(e) {
		return this.applyMatrix3(e).normalize()
	}
	applyMatrix4(e) {
		const t = this.x,
			n = this.y,
			i = this.z,
			r = e.elements,
			s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
		return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this
	}
	applyQuaternion(e) {
		const t = this.x,
			n = this.y,
			i = this.z,
			r = e.x,
			s = e.y,
			a = e.z,
			o = e.w,
			l = o * t + s * i - a * n,
			c = o * n + a * t - r * i,
			u = o * i + r * n - s * t,
			h = -r * t - s * n - a * i;
		return this.x = l * o + h * -r + c * -a - u * -s, this.y = c * o + h * -s + u * -r - l * -a, this.z = u * o + h * -a + l * -s - c * -r, this
	}
	project(e) {
		return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
	}
	unproject(e) {
		return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
	}
	transformDirection(e) {
		const t = this.x,
			n = this.y,
			i = this.z,
			r = e.elements;
		return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
	}
	divide(e) {
		return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e)
	}
	min(e) {
		return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
	}
	max(e) {
		return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
	}
	clamp(e, t) {
		return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
	}
	clampScalar(e, t) {
		return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
	}
	roundToZero() {
		return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e)
	}
	lerp(e, t) {
		return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
	}
	lerpVectors(e, t, n) {
		return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
	}
	cross(e, t) {
		return void 0 !== t ? this.crossVectors(e, t) : this.crossVectors(this, e)
	}
	crossVectors(e, t) {
		const n = e.x,
			i = e.y,
			r = e.z,
			s = t.x,
			a = t.y,
			o = t.z;
		return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this
	}
	projectOnVector(e) {
		const t = e.lengthSq();
		if (0 === t) return this.set(0, 0, 0);
		const n = e.dot(this) / t;
		return this.copy(e).multiplyScalar(n)
	}
	projectOnPlane(e) {
		return Ux.copy(this).projectOnVector(e), this.sub(Ux)
	}
	reflect(e) {
		return this.sub(Ux.copy(e).multiplyScalar(2 * this.dot(e)))
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (0 === t) return Math.PI / 2;
		const n = this.dot(e) / t;
		return Math.acos(wx(n, -1, 1))
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e))
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			n = this.y - e.y,
			i = this.z - e.z;
		return t * t + n * n + i * i
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
	}
	setFromSpherical(e) {
		return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
	}
	setFromSphericalCoords(e, t, n) {
		const i = Math.sin(t) * e;
		return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
	}
	setFromCylindrical(e) {
		return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
	}
	setFromCylindricalCoords(e, t, n) {
		return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
	}
	setFromMatrixPosition(e) {
		const t = e.elements;
		return this.x = t[12], this.y = t[13], this.z = t[14], this
	}
	setFromMatrixScale(e) {
		const t = this.setFromMatrixColumn(e, 0).length(),
			n = this.setFromMatrixColumn(e, 1).length(),
			i = this.setFromMatrixColumn(e, 2).length();
		return this.x = t, this.y = n, this.z = i, this
	}
	setFromMatrixColumn(e, t) {
		return this.fromArray(e.elements, 4 * t)
	}
	setFromMatrix3Column(e, t) {
		return this.fromArray(e.elements, 3 * t)
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z
	}
	fromArray(e, t = 0) {
		return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
	}
	fromBufferAttribute(e, t, n) {
		return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
	}
	randomDirection() {
		const e = 2 * (Math.random() - .5),
			t = Math.random() * Math.PI * 2,
			n = Math.sqrt(1 - e ** 2);
		return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z
	}
}
zx.prototype.isVector3 = !0;
const Ux = new zx,
	Bx = new Fx;
class Vx {
	constructor(e = new zx(Infinity, Infinity, Infinity), t = new zx(-Infinity, -Infinity, -Infinity)) {
		this.min = e, this.max = t
	}
	set(e, t) {
		return this.min.copy(e), this.max.copy(t), this
	}
	setFromArray(e) {
		let t = Infinity,
			n = Infinity,
			i = Infinity,
			r = -Infinity,
			s = -Infinity,
			a = -Infinity;
		for (let o = 0, l = e.length; o < l; o += 3) {
			const l = e[o],
				c = e[o + 1],
				u = e[o + 2];
			l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
		}
		return this.min.set(t, n, i), this.max.set(r, s, a), this
	}
	setFromBufferAttribute(e) {
		let t = Infinity,
			n = Infinity,
			i = Infinity,
			r = -Infinity,
			s = -Infinity,
			a = -Infinity;
		for (let o = 0, l = e.count; o < l; o++) {
			const l = e.getX(o),
				c = e.getY(o),
				u = e.getZ(o);
			l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > a && (a = u)
		}
		return this.min.set(t, n, i), this.max.set(r, s, a), this
	}
	setFromPoints(e) {
		this.makeEmpty();
		for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
		return this
	}
	setFromCenterAndSize(e, t) {
		const n = Gx.copy(t).multiplyScalar(.5);
		return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
	}
	setFromObject(e) {
		return this.makeEmpty(), this.expandByObject(e)
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		return this.min.copy(e.min), this.max.copy(e.max), this
	}
	makeEmpty() {
		return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -Infinity, this
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	}
	getCenter(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
	}
	getSize(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
	}
	expandByPoint(e) {
		return this.min.min(e), this.max.max(e), this
	}
	expandByVector(e) {
		return this.min.sub(e), this.max.add(e), this
	}
	expandByScalar(e) {
		return this.min.addScalar(-e), this.max.addScalar(e), this
	}
	expandByObject(e) {
		e.updateWorldMatrix(!1, !1);
		const t = e.geometry;
		void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Wx.copy(t.boundingBox), Wx.applyMatrix4(e.matrixWorld), this.union(Wx));
		const n = e.children;
		for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
		return this
	}
	containsPoint(e) {
		return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
	}
	containsBox(e) {
		return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
	}
	getParameter(e, t) {
		return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
	}
	intersectsBox(e) {
		return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
	}
	intersectsSphere(e) {
		return this.clampPoint(e.center, Gx), Gx.distanceToSquared(e.center) <= e.radius * e.radius
	}
	intersectsPlane(e) {
		let t, n;
		return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
	}
	intersectsTriangle(e) {
		if (this.isEmpty()) return !1;
		this.getCenter(Kx), Jx.subVectors(this.max, Kx), qx.subVectors(e.a, Kx), jx.subVectors(e.b, Kx), Yx.subVectors(e.c, Kx), Xx.subVectors(jx, qx), $x.subVectors(Yx, jx), Zx.subVectors(qx, Yx);
		let t = [0, -Xx.z, Xx.y, 0, -$x.z, $x.y, 0, -Zx.z, Zx.y, Xx.z, 0, -Xx.x, $x.z, 0, -$x.x, Zx.z, 0, -Zx.x, -Xx.y, Xx.x, 0, -$x.y, $x.x, 0, -Zx.y, Zx.x, 0];
		return !!tb(t, qx, jx, Yx, Jx) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!tb(t, qx, jx, Yx, Jx) && (Qx.crossVectors(Xx, $x), t = [Qx.x, Qx.y, Qx.z], tb(t, qx, jx, Yx, Jx)))
	}
	clampPoint(e, t) {
		return t.copy(e).clamp(this.min, this.max)
	}
	distanceToPoint(e) {
		return Gx.copy(e).clamp(this.min, this.max).sub(e).length()
	}
	getBoundingSphere(e) {
		return this.getCenter(e.center), e.radius = .5 * this.getSize(Gx).length(), e
	}
	intersect(e) {
		return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
	}
	union(e) {
		return this.min.min(e.min), this.max.max(e.max), this
	}
	applyMatrix4(e) {
		return this.isEmpty() || (Hx[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Hx[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Hx[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Hx[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Hx[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Hx[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Hx[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Hx[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Hx)), this
	}
	translate(e) {
		return this.min.add(e), this.max.add(e), this
	}
	equals(e) {
		return e.min.equals(this.min) && e.max.equals(this.max)
	}
}
Vx.prototype.isBox3 = !0;
const Hx = [new zx, new zx, new zx, new zx, new zx, new zx, new zx, new zx],
	Gx = new zx,
	Wx = new Vx,
	qx = new zx,
	jx = new zx,
	Yx = new zx,
	Xx = new zx,
	$x = new zx,
	Zx = new zx,
	Kx = new zx,
	Jx = new zx,
	Qx = new zx,
	eb = new zx;

function tb(e, t, n, i, r) {
	for (let s = 0, a = e.length - 3; s <= a; s += 3) {
		eb.fromArray(e, s);
		const a = r.x * Math.abs(eb.x) + r.y * Math.abs(eb.y) + r.z * Math.abs(eb.z),
			o = t.dot(eb),
			l = n.dot(eb),
			c = i.dot(eb);
		if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
	}
	return !0
}
const nb = new Vx,
	ib = new zx,
	rb = new zx,
	sb = new zx;
class ab {
	constructor(e = new zx, t = -1) {
		this.center = e, this.radius = t
	}
	set(e, t) {
		return this.center.copy(e), this.radius = t, this
	}
	setFromPoints(e, t) {
		const n = this.center;
		void 0 !== t ? n.copy(t) : nb.setFromPoints(e).getCenter(n);
		let i = 0;
		for (let r = 0, s = e.length; r < s; r++) i = Math.max(i, n.distanceToSquared(e[r]));
		return this.radius = Math.sqrt(i), this
	}
	copy(e) {
		return this.center.copy(e.center), this.radius = e.radius, this
	}
	isEmpty() {
		return this.radius < 0
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), this.radius = -1, this
	}
	containsPoint(e) {
		return e.distanceToSquared(this.center) <= this.radius * this.radius
	}
	distanceToPoint(e) {
		return e.distanceTo(this.center) - this.radius
	}
	intersectsSphere(e) {
		const t = this.radius + e.radius;
		return e.center.distanceToSquared(this.center) <= t * t
	}
	intersectsBox(e) {
		return e.intersectsSphere(this)
	}
	intersectsPlane(e) {
		return Math.abs(e.distanceToPoint(this.center)) <= this.radius
	}
	clampPoint(e, t) {
		const n = this.center.distanceToSquared(e);
		return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
	}
	getBoundingBox(e) {
		return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
	}
	applyMatrix4(e) {
		return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
	}
	translate(e) {
		return this.center.add(e), this
	}
	expandByPoint(e) {
		sb.subVectors(e, this.center);
		const t = sb.lengthSq();
		if (t > this.radius * this.radius) {
			const e = Math.sqrt(t),
				n = .5 * (e - this.radius);
			this.center.add(sb.multiplyScalar(n / e)), this.radius += n
		}
		return this
	}
	union(e) {
		return rb.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(ib.copy(e.center).add(rb)), this.expandByPoint(ib.copy(e.center).sub(rb)), this
	}
	equals(e) {
		return e.center.equals(this.center) && e.radius === this.radius
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}
const ob = new zx,
	lb = new zx,
	cb = new zx,
	ub = new zx,
	hb = new zx,
	db = new zx,
	pb = new zx;
class fb {
	constructor(e = new zx, t = new zx(0, 0, -1)) {
		this.origin = e, this.direction = t
	}
	set(e, t) {
		return this.origin.copy(e), this.direction.copy(t), this
	}
	copy(e) {
		return this.origin.copy(e.origin), this.direction.copy(e.direction), this
	}
	at(e, t) {
		return t.copy(this.direction).multiplyScalar(e).add(this.origin)
	}
	lookAt(e) {
		return this.direction.copy(e).sub(this.origin).normalize(), this
	}
	recast(e) {
		return this.origin.copy(this.at(e, ob)), this
	}
	closestPointToPoint(e, t) {
		t.subVectors(e, this.origin);
		const n = t.dot(this.direction);
		return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
	}
	distanceToPoint(e) {
		return Math.sqrt(this.distanceSqToPoint(e))
	}
	distanceSqToPoint(e) {
		const t = ob.subVectors(e, this.origin).dot(this.direction);
		return t < 0 ? this.origin.distanceToSquared(e) : (ob.copy(this.direction).multiplyScalar(t).add(this.origin), ob.distanceToSquared(e))
	}
	distanceSqToSegment(e, t, n, i) {
		lb.copy(e).add(t).multiplyScalar(.5), cb.copy(t).sub(e).normalize(), ub.copy(this.origin).sub(lb);
		const r = .5 * e.distanceTo(t),
			s = -this.direction.dot(cb),
			a = ub.dot(this.direction),
			o = -ub.dot(cb),
			l = ub.lengthSq(),
			c = Math.abs(1 - s * s);
		let u, h, d, p;
		if (c > 0)
			if (u = s * o - a, h = s * a - o, p = r * c, u >= 0)
				if (h >= -p)
					if (h <= p) {
						const e = 1 / c;
						u *= e, h *= e, d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l
					} else h = r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
		else h = -r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
		else h <= -p ? (u = Math.max(0, -(-s * r + a)), h = u > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -o), r), d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * r + a)), h = u > 0 ? r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l);
		else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l;
		return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(cb).multiplyScalar(h).add(lb), d
	}
	intersectSphere(e, t) {
		ob.subVectors(e.center, this.origin);
		const n = ob.dot(this.direction),
			i = ob.dot(ob) - n * n,
			r = e.radius * e.radius;
		if (i > r) return null;
		const s = Math.sqrt(r - i),
			a = n - s,
			o = n + s;
		return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
	}
	intersectsSphere(e) {
		return this.distanceSqToPoint(e.center) <= e.radius * e.radius
	}
	distanceToPlane(e) {
		const t = e.normal.dot(this.direction);
		if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
		const n = -(this.origin.dot(e.normal) + e.constant) / t;
		return n >= 0 ? n : null
	}
	intersectPlane(e, t) {
		const n = this.distanceToPlane(e);
		return null === n ? null : this.at(n, t)
	}
	intersectsPlane(e) {
		const t = e.distanceToPoint(this.origin);
		if (0 === t) return !0;
		return e.normal.dot(this.direction) * t < 0
	}
	intersectBox(e, t) {
		let n, i, r, s, a, o;
		const l = 1 / this.direction.x,
			c = 1 / this.direction.y,
			u = 1 / this.direction.z,
			h = this.origin;
		return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), u >= 0 ? (a = (e.min.z - h.z) * u, o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, o = (e.min.z - h.z) * u), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
	}
	intersectsBox(e) {
		return null !== this.intersectBox(e, ob)
	}
	intersectTriangle(e, t, n, i, r) {
		hb.subVectors(t, e), db.subVectors(n, e), pb.crossVectors(hb, db);
		let s, a = this.direction.dot(pb);
		if (a > 0) {
			if (i) return null;
			s = 1
		} else {
			if (!(a < 0)) return null;
			s = -1, a = -a
		}
		ub.subVectors(this.origin, e);
		const o = s * this.direction.dot(db.crossVectors(ub, db));
		if (o < 0) return null;
		const l = s * this.direction.dot(hb.cross(ub));
		if (l < 0) return null;
		if (o + l > a) return null;
		const c = -s * ub.dot(pb);
		return c < 0 ? null : this.at(c / a, r)
	}
	applyMatrix4(e) {
		return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
	}
	equals(e) {
		return e.origin.equals(this.origin) && e.direction.equals(this.direction)
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}
class mb {
	constructor() {
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
	}
	set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) {
		const g = this.elements;
		return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	clone() {
		return (new mb).fromArray(this.elements)
	}
	copy(e) {
		const t = this.elements,
			n = e.elements;
		return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
	}
	copyPosition(e) {
		const t = this.elements,
			n = e.elements;
		return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
	}
	setFromMatrix3(e) {
		const t = e.elements;
		return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
	}
	extractBasis(e, t, n) {
		return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
	}
	makeBasis(e, t, n) {
		return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
	}
	extractRotation(e) {
		const t = this.elements,
			n = e.elements,
			i = 1 / gb.setFromMatrixColumn(e, 0).length(),
			r = 1 / gb.setFromMatrixColumn(e, 1).length(),
			s = 1 / gb.setFromMatrixColumn(e, 2).length();
		return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
	}
	makeRotationFromEuler(e) {
		!e || e.isEuler;
		const t = this.elements,
			n = e.x,
			i = e.y,
			r = e.z,
			s = Math.cos(n),
			a = Math.sin(n),
			o = Math.cos(i),
			l = Math.sin(i),
			c = Math.cos(r),
			u = Math.sin(r);
		if ("XYZ" === e.order) {
			const e = s * c,
				n = s * u,
				i = a * c,
				r = a * u;
			t[0] = o * c, t[4] = -o * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * o
		} else if ("YXZ" === e.order) {
			const e = o * c,
				n = o * u,
				i = l * c,
				r = l * u;
			t[0] = e + r * a, t[4] = i * a - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -a, t[2] = n * a - i, t[6] = r + e * a, t[10] = s * o
		} else if ("ZXY" === e.order) {
			const e = o * c,
				n = o * u,
				i = l * c,
				r = l * u;
			t[0] = e - r * a, t[4] = -s * u, t[8] = i + n * a, t[1] = n + i * a, t[5] = s * c, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o
		} else if ("ZYX" === e.order) {
			const e = s * c,
				n = s * u,
				i = a * c,
				r = a * u;
			t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = a * o, t[10] = s * o
		} else if ("YZX" === e.order) {
			const e = s * o,
				n = s * l,
				i = a * o,
				r = a * l;
			t[0] = o * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u
		} else if ("XZY" === e.order) {
			const e = s * o,
				n = s * l,
				i = a * o,
				r = a * l;
			t[0] = o * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = s * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = a * c, t[10] = r * u + e
		}
		return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
	}
	makeRotationFromQuaternion(e) {
		return this.compose(_b, e, yb)
	}
	lookAt(e, t, n) {
		const i = this.elements;
		return wb.subVectors(e, t), 0 === wb.lengthSq() && (wb.z = 1), wb.normalize(), xb.crossVectors(n, wb), 0 === xb.lengthSq() && (1 === Math.abs(n.z) ? wb.x += 1e-4 : wb.z += 1e-4, wb.normalize(), xb.crossVectors(n, wb)), xb.normalize(), bb.crossVectors(wb, xb), i[0] = xb.x, i[4] = bb.x, i[8] = wb.x, i[1] = xb.y, i[5] = bb.y, i[9] = wb.y, i[2] = xb.z, i[6] = bb.z, i[10] = wb.z, this
	}
	multiply(e, t) {
		return void 0 !== t ? this.multiplyMatrices(e, t) : this.multiplyMatrices(this, e)
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this)
	}
	multiplyMatrices(e, t) {
		const n = e.elements,
			i = t.elements,
			r = this.elements,
			s = n[0],
			a = n[4],
			o = n[8],
			l = n[12],
			c = n[1],
			u = n[5],
			h = n[9],
			d = n[13],
			p = n[2],
			f = n[6],
			m = n[10],
			g = n[14],
			v = n[3],
			_ = n[7],
			y = n[11],
			x = n[15],
			b = i[0],
			w = i[4],
			S = i[8],
			M = i[12],
			T = i[1],
			C = i[5],
			E = i[9],
			A = i[13],
			P = i[2],
			L = i[6],
			I = i[10],
			D = i[14],
			R = i[3],
			k = i[7],
			N = i[11],
			O = i[15];
		return r[0] = s * b + a * T + o * P + l * R, r[4] = s * w + a * C + o * L + l * k, r[8] = s * S + a * E + o * I + l * N, r[12] = s * M + a * A + o * D + l * O, r[1] = c * b + u * T + h * P + d * R, r[5] = c * w + u * C + h * L + d * k, r[9] = c * S + u * E + h * I + d * N, r[13] = c * M + u * A + h * D + d * O, r[2] = p * b + f * T + m * P + g * R, r[6] = p * w + f * C + m * L + g * k, r[10] = p * S + f * E + m * I + g * N, r[14] = p * M + f * A + m * D + g * O, r[3] = v * b + _ * T + y * P + x * R, r[7] = v * w + _ * C + y * L + x * k, r[11] = v * S + _ * E + y * I + x * N, r[15] = v * M + _ * A + y * D + x * O, this
	}
	multiplyScalar(e) {
		const t = this.elements;
		return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			n = e[4],
			i = e[8],
			r = e[12],
			s = e[1],
			a = e[5],
			o = e[9],
			l = e[13],
			c = e[2],
			u = e[6],
			h = e[10],
			d = e[14];
		return e[3] * (+r * o * u - i * l * u - r * a * h + n * l * h + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + r * s * h - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * u - t * a * d - r * s * u + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * u + t * a * h + i * s * u - n * s * h + n * o * c)
	}
	transpose() {
		const e = this.elements;
		let t;
		return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
	}
	setPosition(e, t, n) {
		const i = this.elements;
		return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
	}
	invert() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			i = e[2],
			r = e[3],
			s = e[4],
			a = e[5],
			o = e[6],
			l = e[7],
			c = e[8],
			u = e[9],
			h = e[10],
			d = e[11],
			p = e[12],
			f = e[13],
			m = e[14],
			g = e[15],
			v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g,
			_ = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g,
			y = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g,
			x = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m,
			b = t * v + n * _ + i * y + r * x;
		if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const w = 1 / b;
		return e[0] = v * w, e[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w, e[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * w, e[3] = (u * o * r - a * h * r - u * i * l + n * h * l + a * i * d - n * o * d) * w, e[4] = _ * w, e[5] = (c * m * r - p * h * r + p * i * d - t * m * d - c * i * g + t * h * g) * w, e[6] = (p * o * r - s * m * r - p * i * l + t * m * l + s * i * g - t * o * g) * w, e[7] = (s * h * r - c * o * r + c * i * l - t * h * l - s * i * d + t * o * d) * w, e[8] = y * w, e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * w, e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * w, e[11] = (c * a * r - s * u * r - c * n * l + t * u * l + s * n * d - t * a * d) * w, e[12] = x * w, e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * m + t * u * m) * w, e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * m - t * a * m) * w, e[15] = (s * u * i - c * a * i + c * n * o - t * u * o - s * n * h + t * a * h) * w, this
	}
	scale(e) {
		const t = this.elements,
			n = e.x,
			i = e.y,
			r = e.z;
		return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
	}
	getMaxScaleOnAxis() {
		const e = this.elements,
			t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
			n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
			i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
		return Math.sqrt(Math.max(t, n, i))
	}
	makeTranslation(e, t, n) {
		return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
	}
	makeRotationX(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
	}
	makeRotationY(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
	}
	makeRotationZ(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	makeRotationAxis(e, t) {
		const n = Math.cos(t),
			i = Math.sin(t),
			r = 1 - n,
			s = e.x,
			a = e.y,
			o = e.z,
			l = r * s,
			c = r * a;
		return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this
	}
	makeScale(e, t, n) {
		return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
	}
	makeShear(e, t, n, i, r, s) {
		return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this
	}
	compose(e, t, n) {
		const i = this.elements,
			r = t._x,
			s = t._y,
			a = t._z,
			o = t._w,
			l = r + r,
			c = s + s,
			u = a + a,
			h = r * l,
			d = r * c,
			p = r * u,
			f = s * c,
			m = s * u,
			g = a * u,
			v = o * l,
			_ = o * c,
			y = o * u,
			x = n.x,
			b = n.y,
			w = n.z;
		return i[0] = (1 - (f + g)) * x, i[1] = (d + y) * x, i[2] = (p - _) * x, i[3] = 0, i[4] = (d - y) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + _) * w, i[9] = (m - v) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
	}
	decompose(e, t, n) {
		const i = this.elements;
		let r = gb.set(i[0], i[1], i[2]).length();
		const s = gb.set(i[4], i[5], i[6]).length(),
			a = gb.set(i[8], i[9], i[10]).length();
		this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], vb.copy(this);
		const o = 1 / r,
			l = 1 / s,
			c = 1 / a;
		return vb.elements[0] *= o, vb.elements[1] *= o, vb.elements[2] *= o, vb.elements[4] *= l, vb.elements[5] *= l, vb.elements[6] *= l, vb.elements[8] *= c, vb.elements[9] *= c, vb.elements[10] *= c, t.setFromRotationMatrix(vb), n.x = r, n.y = s, n.z = a, this
	}
	makePerspective(e, t, n, i, r, s) {
		const a = this.elements,
			o = 2 * r / (t - e),
			l = 2 * r / (n - i),
			c = (t + e) / (t - e),
			u = (n + i) / (n - i),
			h = -(s + r) / (s - r),
			d = -2 * s * r / (s - r);
		return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
	}
	makeOrthographic(e, t, n, i, r, s) {
		const a = this.elements,
			o = 1 / (t - e),
			l = 1 / (n - i),
			c = 1 / (s - r),
			u = (t + e) * o,
			h = (n + i) * l,
			d = (s + r) * c;
		return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
	}
	equals(e) {
		const t = this.elements,
			n = e.elements;
		for (let i = 0; i < 16; i++)
			if (t[i] !== n[i]) return !1;
		return !0
	}
	fromArray(e, t = 0) {
		for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
		return this
	}
	toArray(e = [], t = 0) {
		const n = this.elements;
		return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
	}
}
mb.prototype.isMatrix4 = !0;
const gb = new zx,
	vb = new mb,
	_b = new zx(0, 0, 0),
	yb = new zx(1, 1, 1),
	xb = new zx,
	bb = new zx,
	wb = new zx,
	Sb = new mb,
	Mb = new Fx;
class Tb {
	constructor(e = 0, t = 0, n = 0, i = Tb.DefaultOrder) {
		this._x = e, this._y = t, this._z = n, this._order = i
	}
	get x() {
		return this._x
	}
	set x(e) {
		this._x = e, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(e) {
		this._y = e, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(e) {
		this._z = e, this._onChangeCallback()
	}
	get order() {
		return this._order
	}
	set order(e) {
		this._order = e, this._onChangeCallback()
	}
	set(e, t, n, i = this._order) {
		return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order)
	}
	copy(e) {
		return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
	}
	setFromRotationMatrix(e, t = this._order, n = !0) {
		const i = e.elements,
			r = i[0],
			s = i[4],
			a = i[8],
			o = i[1],
			l = i[5],
			c = i[9],
			u = i[2],
			h = i[6],
			d = i[10];
		switch (t) {
			case "XYZ":
				this._y = Math.asin(wx(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0);
				break;
			case "YXZ":
				this._x = Math.asin(-wx(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
				break;
			case "ZXY":
				this._x = Math.asin(wx(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
				break;
			case "ZYX":
				this._y = Math.asin(-wx(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
				break;
			case "YZX":
				this._z = Math.asin(wx(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, d));
				break;
			case "XZY":
				this._z = Math.asin(-wx(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0)
		}
		return this._order = t, !0 === n && this._onChangeCallback(), this
	}
	setFromQuaternion(e, t, n) {
		return Sb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Sb, t, n)
	}
	setFromVector3(e, t = this._order) {
		return this.set(e.x, e.y, e.z, t)
	}
	reorder(e) {
		return Mb.setFromEuler(this), this.setFromQuaternion(Mb, e)
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
	}
	fromArray(e) {
		return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
	}
	toArray(e = [], t = 0) {
		return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
	}
	toVector3(e) {
		return e ? e.set(this._x, this._y, this._z) : new zx(this._x, this._y, this._z)
	}
	_onChange(e) {
		return this._onChangeCallback = e, this
	}
	_onChangeCallback() {}
}
Tb.prototype.isEuler = !0, Tb.DefaultOrder = "XYZ", Tb.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Cb {
	constructor() {
		this.mask = 1
	}
	set(e) {
		this.mask = 1 << e | 0
	}
	enable(e) {
		this.mask |= 1 << e | 0
	}
	enableAll() {
		this.mask = -1
	}
	toggle(e) {
		this.mask ^= 1 << e | 0
	}
	disable(e) {
		this.mask &= ~(1 << e | 0)
	}
	disableAll() {
		this.mask = 0
	}
	test(e) {
		return 0 != (this.mask & e.mask)
	}
}
let Eb = 0;
const Ab = new zx,
	Pb = new Fx,
	Lb = new mb,
	Ib = new zx,
	Db = new zx,
	Rb = new zx,
	kb = new Fx,
	Nb = new zx(1, 0, 0),
	Ob = new zx(0, 1, 0),
	Fb = new zx(0, 0, 1),
	zb = {
		type: "added"
	},
	Ub = {
		type: "removed"
	};
class Bb extends gx {
	constructor() {
		super(), Object.defineProperty(this, "id", {
			value: Eb++
		}), this.uuid = bx(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Bb.DefaultUp.clone();
		const e = new zx,
			t = new Tb,
			n = new Fx,
			i = new zx(1, 1, 1);
		t._onChange((function() {
			n.setFromEuler(t, !1)
		})), n._onChange((function() {
			t.setFromQuaternion(n, void 0, !1)
		})), Object.defineProperties(this, {
			position: {
				configurable: !0,
				enumerable: !0,
				value: e
			},
			rotation: {
				configurable: !0,
				enumerable: !0,
				value: t
			},
			quaternion: {
				configurable: !0,
				enumerable: !0,
				value: n
			},
			scale: {
				configurable: !0,
				enumerable: !0,
				value: i
			},
			modelViewMatrix: {
				value: new mb
			},
			normalMatrix: {
				value: new Ex
			}
		}), this.matrix = new mb, this.matrixWorld = new mb, this.matrixAutoUpdate = Bb.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Cb, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
	}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(e) {
		this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
	}
	applyQuaternion(e) {
		return this.quaternion.premultiply(e), this
	}
	setRotationFromAxisAngle(e, t) {
		this.quaternion.setFromAxisAngle(e, t)
	}
	setRotationFromEuler(e) {
		this.quaternion.setFromEuler(e, !0)
	}
	setRotationFromMatrix(e) {
		this.quaternion.setFromRotationMatrix(e)
	}
	setRotationFromQuaternion(e) {
		this.quaternion.copy(e)
	}
	rotateOnAxis(e, t) {
		return Pb.setFromAxisAngle(e, t), this.quaternion.multiply(Pb), this
	}
	rotateOnWorldAxis(e, t) {
		return Pb.setFromAxisAngle(e, t), this.quaternion.premultiply(Pb), this
	}
	rotateX(e) {
		return this.rotateOnAxis(Nb, e)
	}
	rotateY(e) {
		return this.rotateOnAxis(Ob, e)
	}
	rotateZ(e) {
		return this.rotateOnAxis(Fb, e)
	}
	translateOnAxis(e, t) {
		return Ab.copy(e).applyQuaternion(this.quaternion), this.position.add(Ab.multiplyScalar(t)), this
	}
	translateX(e) {
		return this.translateOnAxis(Nb, e)
	}
	translateY(e) {
		return this.translateOnAxis(Ob, e)
	}
	translateZ(e) {
		return this.translateOnAxis(Fb, e)
	}
	localToWorld(e) {
		return e.applyMatrix4(this.matrixWorld)
	}
	worldToLocal(e) {
		return e.applyMatrix4(Lb.copy(this.matrixWorld).invert())
	}
	lookAt(e, t, n) {
		e.isVector3 ? Ib.copy(e) : Ib.set(e, t, n);
		const i = this.parent;
		this.updateWorldMatrix(!0, !1), Db.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Lb.lookAt(Db, Ib, this.up) : Lb.lookAt(Ib, Db, this.up), this.quaternion.setFromRotationMatrix(Lb), i && (Lb.extractRotation(i.matrixWorld), Pb.setFromRotationMatrix(Lb), this.quaternion.premultiply(Pb.invert()))
	}
	add(e) {
		if (arguments.length > 1) {
			for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
			return this
		}
		return e === this || e && e.isObject3D && (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(zb)), this
	}
	remove(e) {
		if (arguments.length > 1) {
			for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
			return this
		}
		const t = this.children.indexOf(e);
		return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Ub)), this
	}
	removeFromParent() {
		const e = this.parent;
		return null !== e && e.remove(this), this
	}
	clear() {
		for (let e = 0; e < this.children.length; e++) {
			const t = this.children[e];
			t.parent = null, t.dispatchEvent(Ub)
		}
		return this.children.length = 0, this
	}
	attach(e) {
		return this.updateWorldMatrix(!0, !1), Lb.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Lb.multiply(e.parent.matrixWorld)), e.applyMatrix4(Lb), this.add(e), e.updateWorldMatrix(!1, !0), this
	}
	getObjectById(e) {
		return this.getObjectByProperty("id", e)
	}
	getObjectByName(e) {
		return this.getObjectByProperty("name", e)
	}
	getObjectByProperty(e, t) {
		if (this[e] === t) return this;
		for (let n = 0, i = this.children.length; n < i; n++) {
			const i = this.children[n].getObjectByProperty(e, t);
			if (void 0 !== i) return i
		}
	}
	getWorldPosition(e) {
		return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
	}
	getWorldQuaternion(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Db, e, Rb), e
	}
	getWorldScale(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Db, kb, e), e
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(t[8], t[9], t[10]).normalize()
	}
	raycast() {}
	traverse(e) {
		e(this);
		const t = this.children;
		for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
	}
	traverseVisible(e) {
		if (!1 === this.visible) return;
		e(this);
		const t = this.children;
		for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
	}
	traverseAncestors(e) {
		const t = this.parent;
		null !== t && (e(t), t.traverseAncestors(e))
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}
	updateMatrixWorld(e) {
		this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
		const t = this.children;
		for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
	}
	updateWorldMatrix(e, t) {
		const n = this.parent;
		if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
			const e = this.children;
			for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(!1, !0)
		}
	}
	toJSON(e) {
		const t = void 0 === e || "string" == typeof e,
			n = {};
		t && (e = {
			geometries: {},
			materials: {},
			textures: {},
			images: {},
			shapes: {},
			skeletons: {},
			animations: {}
		}, n.metadata = {
			version: 4.5,
			type: "Object",
			generator: "Object3D.toJSON"
		});
		const i = {};

		function r(t, n) {
			return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
		}
		if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			i.geometry = r(e.geometries, this.geometry);
			const t = this.geometry.parameters;
			if (void 0 !== t && void 0 !== t.shapes) {
				const n = t.shapes;
				if (Array.isArray(n))
					for (let t = 0, i = n.length; t < i; t++) {
						const i = n[t];
						r(e.shapes, i)
					} else r(e.shapes, n)
			}
		}
		if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
			if (Array.isArray(this.material)) {
				const t = [];
				for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
				i.material = t
			} else i.material = r(e.materials, this.material);
		if (this.children.length > 0) {
			i.children = [];
			for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
		}
		if (this.animations.length > 0) {
			i.animations = [];
			for (let t = 0; t < this.animations.length; t++) {
				const n = this.animations[t];
				i.animations.push(r(e.animations, n))
			}
		}
		if (t) {
			const t = s(e.geometries),
				i = s(e.materials),
				r = s(e.textures),
				a = s(e.images),
				o = s(e.shapes),
				l = s(e.skeletons),
				c = s(e.animations);
			t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
		}
		return n.object = i, n;

		function s(e) {
			const t = [];
			for (const n in e) {
				const i = e[n];
				delete i.metadata, t.push(i)
			}
			return t
		}
	}
	clone(e) {
		return (new this.constructor).copy(this, e)
	}
	copy(e, t = !0) {
		if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
			for (let n = 0; n < e.children.length; n++) {
				const t = e.children[n];
				this.add(t.clone())
			}
		return this
	}
}
Bb.DefaultUp = new zx(0, 1, 0), Bb.DefaultMatrixAutoUpdate = !0, Bb.prototype.isObject3D = !0;
const Vb = new zx,
	Hb = new zx,
	Gb = new zx,
	Wb = new zx,
	qb = new zx,
	jb = new zx,
	Yb = new zx,
	Xb = new zx,
	$b = new zx,
	Zb = new zx;
class Kb {
	constructor(e = new zx, t = new zx, n = new zx) {
		this.a = e, this.b = t, this.c = n
	}
	static getNormal(e, t, n, i) {
		i.subVectors(n, t), Vb.subVectors(e, t), i.cross(Vb);
		const r = i.lengthSq();
		return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
	}
	static getBarycoord(e, t, n, i, r) {
		Vb.subVectors(i, t), Hb.subVectors(n, t), Gb.subVectors(e, t);
		const s = Vb.dot(Vb),
			a = Vb.dot(Hb),
			o = Vb.dot(Gb),
			l = Hb.dot(Hb),
			c = Hb.dot(Gb),
			u = s * l - a * a;
		if (0 === u) return r.set(-2, -1, -1);
		const h = 1 / u,
			d = (l * o - a * c) * h,
			p = (s * c - a * o) * h;
		return r.set(1 - d - p, p, d)
	}
	static containsPoint(e, t, n, i) {
		return this.getBarycoord(e, t, n, i, Wb), Wb.x >= 0 && Wb.y >= 0 && Wb.x + Wb.y <= 1
	}
	static getUV(e, t, n, i, r, s, a, o) {
		return this.getBarycoord(e, t, n, i, Wb), o.set(0, 0), o.addScaledVector(r, Wb.x), o.addScaledVector(s, Wb.y), o.addScaledVector(a, Wb.z), o
	}
	static isFrontFacing(e, t, n, i) {
		return Vb.subVectors(n, t), Hb.subVectors(e, t), Vb.cross(Hb).dot(i) < 0
	}
	set(e, t, n) {
		return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
	}
	setFromPointsAndIndices(e, t, n, i) {
		return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
	}
	setFromAttributeAndIndices(e, t, n, i) {
		return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
	}
	getArea() {
		return Vb.subVectors(this.c, this.b), Hb.subVectors(this.a, this.b), .5 * Vb.cross(Hb).length()
	}
	getMidpoint(e) {
		return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	}
	getNormal(e) {
		return Kb.getNormal(this.a, this.b, this.c, e)
	}
	getPlane(e) {
		return e.setFromCoplanarPoints(this.a, this.b, this.c)
	}
	getBarycoord(e, t) {
		return Kb.getBarycoord(e, this.a, this.b, this.c, t)
	}
	getUV(e, t, n, i, r) {
		return Kb.getUV(e, this.a, this.b, this.c, t, n, i, r)
	}
	containsPoint(e) {
		return Kb.containsPoint(e, this.a, this.b, this.c)
	}
	isFrontFacing(e) {
		return Kb.isFrontFacing(this.a, this.b, this.c, e)
	}
	intersectsBox(e) {
		return e.intersectsTriangle(this)
	}
	closestPointToPoint(e, t) {
		const n = this.a,
			i = this.b,
			r = this.c;
		let s, a;
		qb.subVectors(i, n), jb.subVectors(r, n), Xb.subVectors(e, n);
		const o = qb.dot(Xb),
			l = jb.dot(Xb);
		if (o <= 0 && l <= 0) return t.copy(n);
		$b.subVectors(e, i);
		const c = qb.dot($b),
			u = jb.dot($b);
		if (c >= 0 && u <= c) return t.copy(i);
		const h = o * u - c * l;
		if (h <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(qb, s);
		Zb.subVectors(e, r);
		const d = qb.dot(Zb),
			p = jb.dot(Zb);
		if (p >= 0 && d <= p) return t.copy(r);
		const f = d * l - o * p;
		if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(jb, a);
		const m = c * p - d * u;
		if (m <= 0 && u - c >= 0 && d - p >= 0) return Yb.subVectors(r, i), a = (u - c) / (u - c + (d - p)), t.copy(i).addScaledVector(Yb, a);
		const g = 1 / (m + f + h);
		return s = f * g, a = h * g, t.copy(n).addScaledVector(qb, s).addScaledVector(jb, a)
	}
	equals(e) {
		return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
	}
}
let Jb = 0;
class Qb extends gx {
	constructor() {
		super(), Object.defineProperty(this, "id", {
			value: Jb++
		}), this.uuid = bx(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.format = 1023, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
	}
	get alphaTest() {
		return this._alphaTest
	}
	set alphaTest(e) {
		this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString()
	}
	setValues(e) {
		if (void 0 !== e)
			for (const t in e) {
				const n = e[t];
				if (void 0 === n) continue;
				if ("shading" === t) {
					this.flatShading = 1 === n;
					continue
				}
				const i = this[t];
				void 0 !== i && (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n)
			}
	}
	toJSON(e) {
		const t = void 0 === e || "string" == typeof e;
		t && (e = {
			textures: {},
			images: {}
		});
		const n = {
			metadata: {
				version: 4.5,
				type: "Material",
				generator: "Material.toJSON"
			}
		};

		function i(e) {
			const t = [];
			for (const n in e) {
				const i = e[n];
				delete i.metadata, t.push(i)
			}
			return t
		}
		if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), 1023 !== this.format && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
			const t = i(e.textures),
				r = i(e.images);
			t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
		}
		return n
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
		const t = e.clippingPlanes;
		let n = null;
		if (null !== t) {
			const e = t.length;
			n = new Array(e);
			for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
		}
		return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	set needsUpdate(e) {
		!0 === e && this.version++
	}
}
Qb.prototype.isMaterial = !0;
const ew = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	},
	tw = {
		h: 0,
		s: 0,
		l: 0
	},
	nw = {
		h: 0,
		s: 0,
		l: 0
	};

function iw(e, t, n) {
	return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
}

function rw(e) {
	return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
}

function sw(e) {
	return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
}
class aw {
	constructor(e, t, n) {
		return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
	}
	set(e) {
		return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
	}
	setScalar(e) {
		return this.r = e, this.g = e, this.b = e, this
	}
	setHex(e) {
		return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
	}
	setRGB(e, t, n) {
		return this.r = e, this.g = t, this.b = n, this
	}
	setHSL(e, t, n) {
		var i;
		if (e = (e % (i = 1) + i) % i, t = wx(t, 0, 1), n = wx(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
		else {
			const i = n <= .5 ? n * (1 + t) : n + t - n * t,
				r = 2 * n - i;
			this.r = iw(r, i, e + 1 / 3), this.g = iw(r, i, e), this.b = iw(r, i, e - 1 / 3)
		}
		return this
	}
	setStyle(e) {
		function t(e) {
			void 0 !== e && parseFloat(e)
		}
		let n;
		if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
			let e;
			const i = n[1],
				r = n[2];
			switch (i) {
				case "rgb":
				case "rgba":
					if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
					if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
					break;
				case "hsl":
				case "hsla":
					if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
						const n = parseFloat(e[1]) / 360,
							i = parseInt(e[2], 10) / 100,
							r = parseInt(e[3], 10) / 100;
						return t(e[4]), this.setHSL(n, i, r)
					}
			}
		} else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
			const e = n[1],
				t = e.length;
			if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
			if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
		}
		return e && e.length > 0 ? this.setColorName(e) : this
	}
	setColorName(e) {
		const t = ew[e.toLowerCase()];
		return void 0 !== t && this.setHex(t), this
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b)
	}
	copy(e) {
		return this.r = e.r, this.g = e.g, this.b = e.b, this
	}
	copyGammaToLinear(e, t = 2) {
		return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
	}
	copyLinearToGamma(e, t = 2) {
		const n = t > 0 ? 1 / t : 1;
		return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
	}
	convertGammaToLinear(e) {
		return this.copyGammaToLinear(this, e), this
	}
	convertLinearToGamma(e) {
		return this.copyLinearToGamma(this, e), this
	}
	copySRGBToLinear(e) {
		return this.r = rw(e.r), this.g = rw(e.g), this.b = rw(e.b), this
	}
	copyLinearToSRGB(e) {
		return this.r = sw(e.r), this.g = sw(e.g), this.b = sw(e.b), this
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this
	}
	getHex() {
		return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
	}
	getHexString() {
		return ("000000" + this.getHex().toString(16)).slice(-6)
	}
	getHSL(e) {
		const t = this.r,
			n = this.g,
			i = this.b,
			r = Math.max(t, n, i),
			s = Math.min(t, n, i);
		let a, o;
		const l = (s + r) / 2;
		if (s === r) a = 0, o = 0;
		else {
			const e = r - s;
			switch (o = l <= .5 ? e / (r + s) : e / (2 - r - s), r) {
				case t:
					a = (n - i) / e + (n < i ? 6 : 0);
					break;
				case n:
					a = (i - t) / e + 2;
					break;
				case i:
					a = (t - n) / e + 4
			}
			a /= 6
		}
		return e.h = a, e.s = o, e.l = l, e
	}
	getStyle() {
		return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
	}
	offsetHSL(e, t, n) {
		return this.getHSL(tw), tw.h += e, tw.s += t, tw.l += n, this.setHSL(tw.h, tw.s, tw.l), this
	}
	add(e) {
		return this.r += e.r, this.g += e.g, this.b += e.b, this
	}
	addColors(e, t) {
		return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
	}
	addScalar(e) {
		return this.r += e, this.g += e, this.b += e, this
	}
	sub(e) {
		return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
	}
	multiply(e) {
		return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
	}
	multiplyScalar(e) {
		return this.r *= e, this.g *= e, this.b *= e, this
	}
	lerp(e, t) {
		return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
	}
	lerpColors(e, t, n) {
		return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
	}
	lerpHSL(e, t) {
		this.getHSL(tw), e.getHSL(nw);
		const n = Sx(tw.h, nw.h, t),
			i = Sx(tw.s, nw.s, t),
			r = Sx(tw.l, nw.l, t);
		return this.setHSL(n, i, r), this
	}
	equals(e) {
		return e.r === this.r && e.g === this.g && e.b === this.b
	}
	fromArray(e, t = 0) {
		return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
	}
	toArray(e = [], t = 0) {
		return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
	}
	fromBufferAttribute(e, t) {
		return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
	}
	toJSON() {
		return this.getHex()
	}
}
aw.NAMES = ew, aw.prototype.isColor = !0, aw.prototype.r = 1, aw.prototype.g = 1, aw.prototype.b = 1;
class ow extends Qb {
	constructor(e) {
		super(), this.type = "MeshBasicMaterial", this.color = new aw(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
	}
}
ow.prototype.isMeshBasicMaterial = !0;
const lw = new zx,
	cw = new Cx;
class uw {
	constructor(e, t, n) {
		if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = 35044, this.updateRange = {
			offset: 0,
			count: -1
		}, this.version = 0
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		!0 === e && this.version++
	}
	setUsage(e) {
		return this.usage = e, this
	}
	copy(e) {
		return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
	}
	copyAt(e, t, n) {
		e *= this.itemSize, n *= t.itemSize;
		for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
		return this
	}
	copyArray(e) {
		return this.array.set(e), this
	}
	copyColorsArray(e) {
		const t = this.array;
		let n = 0;
		for (let i = 0, r = e.length; i < r; i++) {
			let r = e[i];
			void 0 === r && (r = new aw), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
		}
		return this
	}
	copyVector2sArray(e) {
		const t = this.array;
		let n = 0;
		for (let i = 0, r = e.length; i < r; i++) {
			let r = e[i];
			void 0 === r && (r = new Cx), t[n++] = r.x, t[n++] = r.y
		}
		return this
	}
	copyVector3sArray(e) {
		const t = this.array;
		let n = 0;
		for (let i = 0, r = e.length; i < r; i++) {
			let r = e[i];
			void 0 === r && (r = new zx), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
		}
		return this
	}
	copyVector4sArray(e) {
		const t = this.array;
		let n = 0;
		for (let i = 0, r = e.length; i < r; i++) {
			let r = e[i];
			void 0 === r && (r = new kx), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
		}
		return this
	}
	applyMatrix3(e) {
		if (2 === this.itemSize)
			for (let t = 0, n = this.count; t < n; t++) cw.fromBufferAttribute(this, t), cw.applyMatrix3(e), this.setXY(t, cw.x, cw.y);
		else if (3 === this.itemSize)
			for (let t = 0, n = this.count; t < n; t++) lw.fromBufferAttribute(this, t), lw.applyMatrix3(e), this.setXYZ(t, lw.x, lw.y, lw.z);
		return this
	}
	applyMatrix4(e) {
		for (let t = 0, n = this.count; t < n; t++) lw.x = this.getX(t), lw.y = this.getY(t), lw.z = this.getZ(t), lw.applyMatrix4(e), this.setXYZ(t, lw.x, lw.y, lw.z);
		return this
	}
	applyNormalMatrix(e) {
		for (let t = 0, n = this.count; t < n; t++) lw.x = this.getX(t), lw.y = this.getY(t), lw.z = this.getZ(t), lw.applyNormalMatrix(e), this.setXYZ(t, lw.x, lw.y, lw.z);
		return this
	}
	transformDirection(e) {
		for (let t = 0, n = this.count; t < n; t++) lw.x = this.getX(t), lw.y = this.getY(t), lw.z = this.getZ(t), lw.transformDirection(e), this.setXYZ(t, lw.x, lw.y, lw.z);
		return this
	}
	set(e, t = 0) {
		return this.array.set(e, t), this
	}
	getX(e) {
		return this.array[e * this.itemSize]
	}
	setX(e, t) {
		return this.array[e * this.itemSize] = t, this
	}
	getY(e) {
		return this.array[e * this.itemSize + 1]
	}
	setY(e, t) {
		return this.array[e * this.itemSize + 1] = t, this
	}
	getZ(e) {
		return this.array[e * this.itemSize + 2]
	}
	setZ(e, t) {
		return this.array[e * this.itemSize + 2] = t, this
	}
	getW(e) {
		return this.array[e * this.itemSize + 3]
	}
	setW(e, t) {
		return this.array[e * this.itemSize + 3] = t, this
	}
	setXY(e, t, n) {
		return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
	}
	setXYZ(e, t, n, i) {
		return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
	}
	setXYZW(e, t, n, i, r) {
		return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
	}
	onUpload(e) {
		return this.onUploadCallback = e, this
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this)
	}
	toJSON() {
		const e = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call(this.array),
			normalized: this.normalized
		};
		return "" !== this.name && (e.name = this.name), 35044 !== this.usage && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
	}
}
uw.prototype.isBufferAttribute = !0;
class hw extends uw {
	constructor(e, t, n) {
		super(new Uint8Array(e), t, n)
	}
}
class dw extends uw {
	constructor(e, t, n) {
		super(new Uint16Array(e), t, n)
	}
}
class pw extends uw {
	constructor(e, t, n) {
		super(new Uint32Array(e), t, n)
	}
}(class extends uw {
	constructor(e, t, n) {
		super(new Uint16Array(e), t, n)
	}
}).prototype.isFloat16BufferAttribute = !0;
class fw extends uw {
	constructor(e, t, n) {
		super(new Float32Array(e), t, n)
	}
}
let mw = 0;
const gw = new mb,
	vw = new Bb,
	_w = new zx,
	yw = new Vx,
	xw = new Vx,
	bw = new zx;
class ww extends gx {
	constructor() {
		super(), Object.defineProperty(this, "id", {
			value: mw++
		}), this.uuid = bx(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
			start: 0,
			count: Infinity
		}, this.userData = {}
	}
	getIndex() {
		return this.index
	}
	setIndex(e) {
		return Array.isArray(e) ? this.index = new(Ax(e) > 65535 ? pw : dw)(e, 1) : this.index = e, this
	}
	getAttribute(e) {
		return this.attributes[e]
	}
	setAttribute(e, t) {
		return this.attributes[e] = t, this
	}
	deleteAttribute(e) {
		return delete this.attributes[e], this
	}
	hasAttribute(e) {
		return void 0 !== this.attributes[e]
	}
	addGroup(e, t, n = 0) {
		this.groups.push({
			start: e,
			count: t,
			materialIndex: n
		})
	}
	clearGroups() {
		this.groups = []
	}
	setDrawRange(e, t) {
		this.drawRange.start = e, this.drawRange.count = t
	}
	applyMatrix4(e) {
		const t = this.attributes.position;
		void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
		const n = this.attributes.normal;
		if (void 0 !== n) {
			const t = (new Ex).getNormalMatrix(e);
			n.applyNormalMatrix(t), n.needsUpdate = !0
		}
		const i = this.attributes.tangent;
		return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
	}
	applyQuaternion(e) {
		return gw.makeRotationFromQuaternion(e), this.applyMatrix4(gw), this
	}
	rotateX(e) {
		return gw.makeRotationX(e), this.applyMatrix4(gw), this
	}
	rotateY(e) {
		return gw.makeRotationY(e), this.applyMatrix4(gw), this
	}
	rotateZ(e) {
		return gw.makeRotationZ(e), this.applyMatrix4(gw), this
	}
	translate(e, t, n) {
		return gw.makeTranslation(e, t, n), this.applyMatrix4(gw), this
	}
	scale(e, t, n) {
		return gw.makeScale(e, t, n), this.applyMatrix4(gw), this
	}
	lookAt(e) {
		return vw.lookAt(e), vw.updateMatrix(), this.applyMatrix4(vw.matrix), this
	}
	center() {
		return this.computeBoundingBox(), this.boundingBox.getCenter(_w).negate(), this.translate(_w.x, _w.y, _w.z), this
	}
	setFromPoints(e) {
		const t = [];
		for (let n = 0, i = e.length; n < i; n++) {
			const i = e[n];
			t.push(i.x, i.y, i.z || 0)
		}
		return this.setAttribute("position", new fw(t, 3)), this
	}
	computeBoundingBox() {
		null === this.boundingBox && (this.boundingBox = new Vx);
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) this.boundingBox.set(new zx(-Infinity, -Infinity, -Infinity), new zx(Infinity, Infinity, Infinity));
		else {
			if (void 0 !== e) {
				if (this.boundingBox.setFromBufferAttribute(e), t)
					for (let e = 0, n = t.length; e < n; e++) {
						const n = t[e];
						yw.setFromBufferAttribute(n), this.morphTargetsRelative ? (bw.addVectors(this.boundingBox.min, yw.min), this.boundingBox.expandByPoint(bw), bw.addVectors(this.boundingBox.max, yw.max), this.boundingBox.expandByPoint(bw)) : (this.boundingBox.expandByPoint(yw.min), this.boundingBox.expandByPoint(yw.max))
					}
			} else this.boundingBox.makeEmpty();
			isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)
		}
	}
	computeBoundingSphere() {
		null === this.boundingSphere && (this.boundingSphere = new ab);
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) this.boundingSphere.set(new zx, Infinity);
		else if (e) {
			const n = this.boundingSphere.center;
			if (yw.setFromBufferAttribute(e), t)
				for (let e = 0, r = t.length; e < r; e++) {
					const n = t[e];
					xw.setFromBufferAttribute(n), this.morphTargetsRelative ? (bw.addVectors(yw.min, xw.min), yw.expandByPoint(bw), bw.addVectors(yw.max, xw.max), yw.expandByPoint(bw)) : (yw.expandByPoint(xw.min), yw.expandByPoint(xw.max))
				}
			yw.getCenter(n);
			let i = 0;
			for (let t = 0, r = e.count; t < r; t++) bw.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(bw));
			if (t)
				for (let r = 0, s = t.length; r < s; r++) {
					const s = t[r],
						a = this.morphTargetsRelative;
					for (let t = 0, r = s.count; t < r; t++) bw.fromBufferAttribute(s, t), a && (_w.fromBufferAttribute(e, t), bw.add(_w)), i = Math.max(i, n.distanceToSquared(bw))
				}
			this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius)
		}
	}
	computeTangents() {
		const e = this.index,
			t = this.attributes;
		if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return;
		const n = e.array,
			i = t.position.array,
			r = t.normal.array,
			s = t.uv.array,
			a = i.length / 3;
		void 0 === t.tangent && this.setAttribute("tangent", new uw(new Float32Array(4 * a), 4));
		const o = t.tangent.array,
			l = [],
			c = [];
		for (let T = 0; T < a; T++) l[T] = new zx, c[T] = new zx;
		const u = new zx,
			h = new zx,
			d = new zx,
			p = new Cx,
			f = new Cx,
			m = new Cx,
			g = new zx,
			v = new zx;

		function _(e, t, n) {
			u.fromArray(i, 3 * e), h.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
			const r = 1 / (f.x * m.y - m.x * f.y);
			isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
		}
		let y = this.groups;
		0 === y.length && (y = [{
			start: 0,
			count: n.length
		}]);
		for (let T = 0, C = y.length; T < C; ++T) {
			const e = y[T],
				t = e.start;
			for (let i = t, r = t + e.count; i < r; i += 3) _(n[i + 0], n[i + 1], n[i + 2])
		}
		const x = new zx,
			b = new zx,
			w = new zx,
			S = new zx;

		function M(e) {
			w.fromArray(r, 3 * e), S.copy(w);
			const t = l[e];
			x.copy(t), x.sub(w.multiplyScalar(w.dot(t))).normalize(), b.crossVectors(S, t);
			const n = b.dot(c[e]) < 0 ? -1 : 1;
			o[4 * e] = x.x, o[4 * e + 1] = x.y, o[4 * e + 2] = x.z, o[4 * e + 3] = n
		}
		for (let T = 0, C = y.length; T < C; ++T) {
			const e = y[T],
				t = e.start;
			for (let i = t, r = t + e.count; i < r; i += 3) M(n[i + 0]), M(n[i + 1]), M(n[i + 2])
		}
	}
	computeVertexNormals() {
		const e = this.index,
			t = this.getAttribute("position");
		if (void 0 !== t) {
			let n = this.getAttribute("normal");
			if (void 0 === n) n = new uw(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
			else
				for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
			const i = new zx,
				r = new zx,
				s = new zx,
				a = new zx,
				o = new zx,
				l = new zx,
				c = new zx,
				u = new zx;
			if (e)
				for (let h = 0, d = e.count; h < d; h += 3) {
					const d = e.getX(h + 0),
						p = e.getX(h + 1),
						f = e.getX(h + 2);
					i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
				} else
					for (let e = 0, h = t.count; e < h; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
			this.normalizeNormals(), n.needsUpdate = !0
		}
	}
	merge(e, t) {
		if (!e || !e.isBufferGeometry) return;
		void 0 === t && (t = 0);
		const n = this.attributes;
		for (const i in n) {
			if (void 0 === e.attributes[i]) continue;
			const r = n[i].array,
				s = e.attributes[i],
				a = s.array,
				o = s.itemSize * t,
				l = Math.min(a.length, r.length - o);
			for (let e = 0, t = o; e < l; e++, t++) r[t] = a[e]
		}
		return this
	}
	normalizeNormals() {
		const e = this.attributes.normal;
		for (let t = 0, n = e.count; t < n; t++) bw.fromBufferAttribute(e, t), bw.normalize(), e.setXYZ(t, bw.x, bw.y, bw.z)
	}
	toNonIndexed() {
		function e(e, t) {
			const n = e.array,
				i = e.itemSize,
				r = e.normalized,
				s = new n.constructor(t.length * i);
			let a = 0,
				o = 0;
			for (let l = 0, c = t.length; l < c; l++) {
				a = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * i;
				for (let e = 0; e < i; e++) s[o++] = n[a++]
			}
			return new uw(s, i, r)
		}
		if (null === this.index) return this;
		const t = new ww,
			n = this.index.array,
			i = this.attributes;
		for (const a in i) {
			const r = e(i[a], n);
			t.setAttribute(a, r)
		}
		const r = this.morphAttributes;
		for (const a in r) {
			const i = [],
				s = r[a];
			for (let t = 0, r = s.length; t < r; t++) {
				const r = e(s[t], n);
				i.push(r)
			}
			t.morphAttributes[a] = i
		}
		t.morphTargetsRelative = this.morphTargetsRelative;
		const s = this.groups;
		for (let a = 0, o = s.length; a < o; a++) {
			const e = s[a];
			t.addGroup(e.start, e.count, e.materialIndex)
		}
		return t
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.5,
				type: "BufferGeometry",
				generator: "BufferGeometry.toJSON"
			}
		};
		if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
			const t = this.parameters;
			for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
			return e
		}
		e.data = {
			attributes: {}
		};
		const t = this.index;
		null !== t && (e.data.index = {
			type: t.array.constructor.name,
			array: Array.prototype.slice.call(t.array)
		});
		const n = this.attributes;
		for (const o in n) {
			const t = n[o];
			e.data.attributes[o] = t.toJSON(e.data)
		}
		const i = {};
		let r = !1;
		for (const o in this.morphAttributes) {
			const t = this.morphAttributes[o],
				n = [];
			for (let i = 0, r = t.length; i < r; i++) {
				const r = t[i];
				n.push(r.toJSON(e.data))
			}
			n.length > 0 && (i[o] = n, r = !0)
		}
		r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
		const s = this.groups;
		s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
		const a = this.boundingSphere;
		return null !== a && (e.data.boundingSphere = {
			center: a.center.toArray(),
			radius: a.radius
		}), e
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
		const t = {};
		this.name = e.name;
		const n = e.index;
		null !== n && this.setIndex(n.clone(t));
		const i = e.attributes;
		for (const l in i) {
			const e = i[l];
			this.setAttribute(l, e.clone(t))
		}
		const r = e.morphAttributes;
		for (const l in r) {
			const e = [],
				n = r[l];
			for (let i = 0, r = n.length; i < r; i++) e.push(n[i].clone(t));
			this.morphAttributes[l] = e
		}
		this.morphTargetsRelative = e.morphTargetsRelative;
		const s = e.groups;
		for (let l = 0, c = s.length; l < c; l++) {
			const e = s[l];
			this.addGroup(e.start, e.count, e.materialIndex)
		}
		const a = e.boundingBox;
		null !== a && (this.boundingBox = a.clone());
		const o = e.boundingSphere;
		return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
ww.prototype.isBufferGeometry = !0;
const Sw = new mb,
	Mw = new fb,
	Tw = new ab,
	Cw = new zx,
	Ew = new zx,
	Aw = new zx,
	Pw = new zx,
	Lw = new zx,
	Iw = new zx,
	Dw = new zx,
	Rw = new zx,
	kw = new zx,
	Nw = new Cx,
	Ow = new Cx,
	Fw = new Cx,
	zw = new zx,
	Uw = new zx;
class Bw extends Bb {
	constructor(e = new ww, t = new ow) {
		super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e) {
		return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				n = Object.keys(t);
			if (n.length > 0) {
				const e = t[n[0]];
				if (void 0 !== e) {
					this.morphTargetInfluences = [], this.morphTargetDictionary = {};
					for (let t = 0, n = e.length; t < n; t++) {
						const n = e[t].name || String(t);
						this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
					}
				}
			}
		} else {
			const t = e.morphTargets;
			void 0 !== t && t.length
		}
	}
	raycast(e, t) {
		const n = this.geometry,
			i = this.material,
			r = this.matrixWorld;
		if (void 0 === i) return;
		if (null === n.boundingSphere && n.computeBoundingSphere(), Tw.copy(n.boundingSphere), Tw.applyMatrix4(r), !1 === e.ray.intersectsSphere(Tw)) return;
		if (Sw.copy(r).invert(), Mw.copy(e.ray).applyMatrix4(Sw), null !== n.boundingBox && !1 === Mw.intersectsBox(n.boundingBox)) return;
		let s;
		if (n.isBufferGeometry) {
			const r = n.index,
				a = n.attributes.position,
				o = n.morphAttributes.position,
				l = n.morphTargetsRelative,
				c = n.attributes.uv,
				u = n.attributes.uv2,
				h = n.groups,
				d = n.drawRange;
			if (null !== r)
				if (Array.isArray(i))
					for (let n = 0, p = h.length; n < p; n++) {
						const p = h[n],
							f = i[p.materialIndex];
						for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
							const i = r.getX(n),
								h = r.getX(n + 1),
								d = r.getX(n + 2);
							s = Vw(this, f, e, Mw, a, o, l, c, u, i, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, t.push(s))
						}
					} else {
						for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
							const h = r.getX(n),
								d = r.getX(n + 1),
								p = r.getX(n + 2);
							s = Vw(this, i, e, Mw, a, o, l, c, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
						}
					} else if (void 0 !== a)
						if (Array.isArray(i))
							for (let n = 0, p = h.length; n < p; n++) {
								const r = h[n],
									p = i[r.materialIndex];
								for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) {
									s = Vw(this, p, e, Mw, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s))
								}
							} else {
								for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3) {
									s = Vw(this, i, e, Mw, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s))
								}
							}
		} else n.isGeometry
	}
}

function Vw(e, t, n, i, r, s, a, o, l, c, u, h) {
	Cw.fromBufferAttribute(r, c), Ew.fromBufferAttribute(r, u), Aw.fromBufferAttribute(r, h);
	const d = e.morphTargetInfluences;
	if (s && d) {
		Dw.set(0, 0, 0), Rw.set(0, 0, 0), kw.set(0, 0, 0);
		for (let e = 0, t = s.length; e < t; e++) {
			const t = d[e],
				n = s[e];
			0 !== t && (Pw.fromBufferAttribute(n, c), Lw.fromBufferAttribute(n, u), Iw.fromBufferAttribute(n, h), a ? (Dw.addScaledVector(Pw, t), Rw.addScaledVector(Lw, t), kw.addScaledVector(Iw, t)) : (Dw.addScaledVector(Pw.sub(Cw), t), Rw.addScaledVector(Lw.sub(Ew), t), kw.addScaledVector(Iw.sub(Aw), t)))
		}
		Cw.add(Dw), Ew.add(Rw), Aw.add(kw)
	}
	e.isSkinnedMesh && (e.boneTransform(c, Cw), e.boneTransform(u, Ew), e.boneTransform(h, Aw));
	const p = function(e, t, n, i, r, s, a, o) {
		let l;
		if (l = 1 === t.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== t.side, o), null === l) return null;
		Uw.copy(o), Uw.applyMatrix4(e.matrixWorld);
		const c = n.ray.origin.distanceTo(Uw);
		return c < n.near || c > n.far ? null : {
			distance: c,
			point: Uw.clone(),
			object: e
		}
	}(e, t, n, i, Cw, Ew, Aw, zw);
	if (p) {
		o && (Nw.fromBufferAttribute(o, c), Ow.fromBufferAttribute(o, u), Fw.fromBufferAttribute(o, h), p.uv = Kb.getUV(zw, Cw, Ew, Aw, Nw, Ow, Fw, new Cx)), l && (Nw.fromBufferAttribute(l, c), Ow.fromBufferAttribute(l, u), Fw.fromBufferAttribute(l, h), p.uv2 = Kb.getUV(zw, Cw, Ew, Aw, Nw, Ow, Fw, new Cx));
		const e = {
			a: c,
			b: u,
			c: h,
			normal: new zx,
			materialIndex: 0
		};
		Kb.getNormal(Cw, Ew, Aw, e.normal), p.face = e
	}
	return p
}
Bw.prototype.isMesh = !0;
class Hw extends ww {
	constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
		super(), this.type = "BoxGeometry", this.parameters = {
			width: e,
			height: t,
			depth: n,
			widthSegments: i,
			heightSegments: r,
			depthSegments: s
		};
		const a = this;
		i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
		const o = [],
			l = [],
			c = [],
			u = [];
		let h = 0,
			d = 0;

		function p(e, t, n, i, r, s, p, f, m, g, v) {
			const _ = s / m,
				y = p / g,
				x = s / 2,
				b = p / 2,
				w = f / 2,
				S = m + 1,
				M = g + 1;
			let T = 0,
				C = 0;
			const E = new zx;
			for (let a = 0; a < M; a++) {
				const s = a * y - b;
				for (let o = 0; o < S; o++) {
					const h = o * _ - x;
					E[e] = h * i, E[t] = s * r, E[n] = w, l.push(E.x, E.y, E.z), E[e] = 0, E[t] = 0, E[n] = f > 0 ? 1 : -1, c.push(E.x, E.y, E.z), u.push(o / m), u.push(1 - a / g), T += 1
				}
			}
			for (let a = 0; a < g; a++)
				for (let e = 0; e < m; e++) {
					const t = h + e + S * a,
						n = h + e + S * (a + 1),
						i = h + (e + 1) + S * (a + 1),
						r = h + (e + 1) + S * a;
					o.push(t, n, r), o.push(n, i, r), C += 6
				}
			a.addGroup(d, C, v), d += C, h += T
		}
		p("z", "y", "x", -1, -1, n, t, e, s, r, 0), p("z", "y", "x", 1, -1, n, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, s, 2), p("x", "z", "y", 1, -1, e, n, -t, i, s, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new fw(l, 3)), this.setAttribute("normal", new fw(c, 3)), this.setAttribute("uv", new fw(u, 2))
	}
	static fromJSON(e) {
		return new Hw(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
	}
}

function Gw(e) {
	const t = {};
	for (const n in e) {
		t[n] = {};
		for (const i in e[n]) {
			const r = e[n][i];
			r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
		}
	}
	return t
}

function Ww(e) {
	const t = {};
	for (let n = 0; n < e.length; n++) {
		const i = Gw(e[n]);
		for (const e in i) t[e] = i[e]
	}
	return t
}
const qw = {
	clone: Gw,
	merge: Ww
};
class jw extends Qb {
	constructor(e) {
		super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}", this.fragmentShader = "void main(){gl_FragColor=vec4(1.0,0.0,0.0,1.0);}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1
		}, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (e.attributes, this.setValues(e))
	}
	copy(e) {
		return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Gw(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		t.glslVersion = this.glslVersion, t.uniforms = {};
		for (const i in this.uniforms) {
			const n = this.uniforms[i].value;
			n && n.isTexture ? t.uniforms[i] = {
				type: "t",
				value: n.toJSON(e).uuid
			} : n && n.isColor ? t.uniforms[i] = {
				type: "c",
				value: n.getHex()
			} : n && n.isVector2 ? t.uniforms[i] = {
				type: "v2",
				value: n.toArray()
			} : n && n.isVector3 ? t.uniforms[i] = {
				type: "v3",
				value: n.toArray()
			} : n && n.isVector4 ? t.uniforms[i] = {
				type: "v4",
				value: n.toArray()
			} : n && n.isMatrix3 ? t.uniforms[i] = {
				type: "m3",
				value: n.toArray()
			} : n && n.isMatrix4 ? t.uniforms[i] = {
				type: "m4",
				value: n.toArray()
			} : t.uniforms[i] = {
				value: n
			}
		}
		Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
		const n = {};
		for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
		return Object.keys(n).length > 0 && (t.extensions = n), t
	}
}
jw.prototype.isShaderMaterial = !0;
class Yw extends Bb {
	constructor() {
		super(), this.type = "Camera", this.matrixWorldInverse = new mb, this.projectionMatrix = new mb, this.projectionMatrixInverse = new mb
	}
	copy(e, t) {
		return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(-t[8], -t[9], -t[10]).normalize()
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	updateWorldMatrix(e, t) {
		super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}
Yw.prototype.isCamera = !0;
class Xw extends Yw {
	constructor(e = 50, t = 1, n = .1, i = 2e3) {
		super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
	}
	copy(e, t) {
		return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
	}
	setFocalLength(e) {
		const t = .5 * this.getFilmHeight() / e;
		this.fov = 2 * _x * Math.atan(t), this.updateProjectionMatrix()
	}
	getFocalLength() {
		const e = Math.tan(.5 * vx * this.fov);
		return .5 * this.getFilmHeight() / e
	}
	getEffectiveFOV() {
		return 2 * _x * Math.atan(Math.tan(.5 * vx * this.fov) / this.zoom)
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1)
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1)
	}
	setViewOffset(e, t, n, i, r, s) {
		this.aspect = e / t, null === this.view && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const e = this.near;
		let t = e * Math.tan(.5 * vx * this.fov) / this.zoom,
			n = 2 * t,
			i = this.aspect * n,
			r = -.5 * i;
		const s = this.view;
		if (null !== this.view && this.view.enabled) {
			const e = s.fullWidth,
				a = s.fullHeight;
			r += s.offsetX * i / e, t -= s.offsetY * n / a, i *= s.width / e, n *= s.height / a
		}
		const a = this.filmOffset;
		0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
	}
}
Xw.prototype.isPerspectiveCamera = !0;
class $w extends Bb {
	constructor(e, t, n) {
		if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return;
		this.renderTarget = n;
		const i = new Xw(90, 1, e, t);
		i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new zx(1, 0, 0)), this.add(i);
		const r = new Xw(90, 1, e, t);
		r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new zx(-1, 0, 0)), this.add(r);
		const s = new Xw(90, 1, e, t);
		s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new zx(0, 1, 0)), this.add(s);
		const a = new Xw(90, 1, e, t);
		a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new zx(0, -1, 0)), this.add(a);
		const o = new Xw(90, 1, e, t);
		o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new zx(0, 0, 1)), this.add(o);
		const l = new Xw(90, 1, e, t);
		l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new zx(0, 0, -1)), this.add(l)
	}
	update(e, t) {
		null === this.parent && this.updateMatrixWorld();
		const n = this.renderTarget,
			[i, r, s, a, o, l] = this.children,
			c = e.xr.enabled,
			u = e.getRenderTarget();
		e.xr.enabled = !1;
		const h = n.texture.generateMipmaps;
		n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c
	}
}
class Zw extends Dx {
	constructor(e, t, n, i, r, s, a, o, l, c) {
		super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, n, i, r, s, a, o, l, c), this.flipY = !1
	}
	get images() {
		return this.image
	}
	set images(e) {
		this.image = e
	}
}
Zw.prototype.isCubeTexture = !0;
class Kw extends Nx {
	constructor(e, t, n) {
		Number.isInteger(t) && (t = n), super(e, e, t), t = t || {}, this.texture = new Zw(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : 1006, this.texture._needsFlipEnvMap = !1
	}
	fromEquirectangularTexture(e, t) {
		this.texture.type = t.type, this.texture.format = 1023, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
		const n = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: "varying vec3 vWorldDirection;vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}void main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
				fragmentShader: "uniform sampler2D tEquirect;varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);gl_FragColor=texture2D(tEquirect,sampleUV);}"
			},
			i = new Hw(5, 5, 5),
			r = new jw({
				name: "CubemapFromEquirect",
				uniforms: Gw(n.uniforms),
				vertexShader: n.vertexShader,
				fragmentShader: n.fragmentShader,
				side: 1,
				blending: 0
			});
		r.uniforms.tEquirect.value = t;
		const s = new Bw(i, r),
			a = t.minFilter;
		1008 === t.minFilter && (t.minFilter = 1006);
		return new $w(1, 10, this).update(e, s), t.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
	}
	clear(e, t, n, i) {
		const r = e.getRenderTarget();
		for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(t, n, i);
		e.setRenderTarget(r)
	}
}
Kw.prototype.isWebGLCubeRenderTarget = !0;
const Jw = new zx,
	Qw = new zx,
	eS = new Ex;
class tS {
	constructor(e = new zx(1, 0, 0), t = 0) {
		this.normal = e, this.constant = t
	}
	set(e, t) {
		return this.normal.copy(e), this.constant = t, this
	}
	setComponents(e, t, n, i) {
		return this.normal.set(e, t, n), this.constant = i, this
	}
	setFromNormalAndCoplanarPoint(e, t) {
		return this.normal.copy(e), this.constant = -t.dot(this.normal), this
	}
	setFromCoplanarPoints(e, t, n) {
		const i = Jw.subVectors(n, t).cross(Qw.subVectors(e, t)).normalize();
		return this.setFromNormalAndCoplanarPoint(i, e), this
	}
	copy(e) {
		return this.normal.copy(e.normal), this.constant = e.constant, this
	}
	normalize() {
		const e = 1 / this.normal.length();
		return this.normal.multiplyScalar(e), this.constant *= e, this
	}
	negate() {
		return this.constant *= -1, this.normal.negate(), this
	}
	distanceToPoint(e) {
		return this.normal.dot(e) + this.constant
	}
	distanceToSphere(e) {
		return this.distanceToPoint(e.center) - e.radius
	}
	projectPoint(e, t) {
		return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
	}
	intersectLine(e, t) {
		const n = e.delta(Jw),
			i = this.normal.dot(n);
		if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
		const r = -(e.start.dot(this.normal) + this.constant) / i;
		return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
	}
	intersectsLine(e) {
		const t = this.distanceToPoint(e.start),
			n = this.distanceToPoint(e.end);
		return t < 0 && n > 0 || n < 0 && t > 0
	}
	intersectsBox(e) {
		return e.intersectsPlane(this)
	}
	intersectsSphere(e) {
		return e.intersectsPlane(this)
	}
	coplanarPoint(e) {
		return e.copy(this.normal).multiplyScalar(-this.constant)
	}
	applyMatrix4(e, t) {
		const n = t || eS.getNormalMatrix(e),
			i = this.coplanarPoint(Jw).applyMatrix4(e),
			r = this.normal.applyMatrix3(n).normalize();
		return this.constant = -i.dot(r), this
	}
	translate(e) {
		return this.constant -= e.dot(this.normal), this
	}
	equals(e) {
		return e.normal.equals(this.normal) && e.constant === this.constant
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}
tS.prototype.isPlane = !0;
const nS = new ab,
	iS = new zx;
class rS {
	constructor(e = new tS, t = new tS, n = new tS, i = new tS, r = new tS, s = new tS) {
		this.planes = [e, t, n, i, r, s]
	}
	set(e, t, n, i, r, s) {
		const a = this.planes;
		return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
	}
	copy(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
		return this
	}
	setFromProjectionMatrix(e) {
		const t = this.planes,
			n = e.elements,
			i = n[0],
			r = n[1],
			s = n[2],
			a = n[3],
			o = n[4],
			l = n[5],
			c = n[6],
			u = n[7],
			h = n[8],
			d = n[9],
			p = n[10],
			f = n[11],
			m = n[12],
			g = n[13],
			v = n[14],
			_ = n[15];
		return t[0].setComponents(a - i, u - o, f - h, _ - m).normalize(), t[1].setComponents(a + i, u + o, f + h, _ + m).normalize(), t[2].setComponents(a + r, u + l, f + d, _ + g).normalize(), t[3].setComponents(a - r, u - l, f - d, _ - g).normalize(), t[4].setComponents(a - s, u - c, f - p, _ - v).normalize(), t[5].setComponents(a + s, u + c, f + p, _ + v).normalize(), this
	}
	intersectsObject(e) {
		const t = e.geometry;
		return null === t.boundingSphere && t.computeBoundingSphere(), nS.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(nS)
	}
	intersectsSprite(e) {
		return nS.center.set(0, 0, 0), nS.radius = .7071067811865476, nS.applyMatrix4(e.matrixWorld), this.intersectsSphere(nS)
	}
	intersectsSphere(e) {
		const t = this.planes,
			n = e.center,
			i = -e.radius;
		for (let r = 0; r < 6; r++) {
			if (t[r].distanceToPoint(n) < i) return !1
		}
		return !0
	}
	intersectsBox(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++) {
			const i = t[n];
			if (iS.x = i.normal.x > 0 ? e.max.x : e.min.x, iS.y = i.normal.y > 0 ? e.max.y : e.min.y, iS.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(iS) < 0) return !1
		}
		return !0
	}
	containsPoint(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++)
			if (t[n].distanceToPoint(e) < 0) return !1;
		return !0
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}

function sS() {
	let e = null,
		t = !1,
		n = null,
		i = null;

	function r(t, s) {
		n(t, s), i = e.requestAnimationFrame(r)
	}
	return {
		start: function() {
			!0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
		},
		stop: function() {
			e.cancelAnimationFrame(i), t = !1
		},
		setAnimationLoop: function(e) {
			n = e
		},
		setContext: function(t) {
			e = t
		}
	}
}

function aS(e, t) {
	const n = t.isWebGL2,
		i = new WeakMap;
	return {
		get: function(e) {
			return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
		},
		remove: function(t) {
			t.isInterleavedBufferAttribute && (t = t.data);
			const n = i.get(t);
			n && (e.deleteBuffer(n.buffer), i.delete(t))
		},
		update: function(t, r) {
			if (t.isGLBufferAttribute) {
				const e = i.get(t);
				return void((!e || e.version < t.version) && i.set(t, {
					buffer: t.buffer,
					type: t.type,
					bytesPerElement: t.elementSize,
					version: t.version
				}))
			}
			t.isInterleavedBufferAttribute && (t = t.data);
			const s = i.get(t);
			void 0 === s ? i.set(t, function(t, i) {
				const r = t.array,
					s = t.usage,
					a = e.createBuffer();
				e.bindBuffer(i, a), e.bufferData(i, r, s), t.onUploadCallback();
				let o = 5126;
				return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array || (r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n && (o = 5131) : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = 5121)), {
					buffer: a,
					type: o,
					bytesPerElement: r.BYTES_PER_ELEMENT,
					version: t.version
				}
			}(t, r)) : s.version < t.version && (! function(t, i, r) {
				const s = i.array,
					a = i.updateRange;
				e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1)
			}(s.buffer, t, r), s.version = t.version)
		}
	}
}
class oS extends ww {
	constructor(e = 1, t = 1, n = 1, i = 1) {
		super(), this.type = "PlaneGeometry", this.parameters = {
			width: e,
			height: t,
			widthSegments: n,
			heightSegments: i
		};
		const r = e / 2,
			s = t / 2,
			a = Math.floor(n),
			o = Math.floor(i),
			l = a + 1,
			c = o + 1,
			u = e / a,
			h = t / o,
			d = [],
			p = [],
			f = [],
			m = [];
		for (let g = 0; g < c; g++) {
			const e = g * h - s;
			for (let t = 0; t < l; t++) {
				const n = t * u - r;
				p.push(n, -e, 0), f.push(0, 0, 1), m.push(t / a), m.push(1 - g / o)
			}
		}
		for (let g = 0; g < o; g++)
			for (let e = 0; e < a; e++) {
				const t = e + l * g,
					n = e + l * (g + 1),
					i = e + 1 + l * (g + 1),
					r = e + 1 + l * g;
				d.push(t, n, r), d.push(n, i, r)
			}
		this.setIndex(d), this.setAttribute("position", new fw(p, 3)), this.setAttribute("normal", new fw(f, 3)), this.setAttribute("uv", new fw(m, 2))
	}
	static fromJSON(e) {
		return new oS(e.width, e.height, e.widthSegments, e.heightSegments)
	}
}
const lS = {
		alphamap_fragment: "#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,vUv).g;\n#endif",
		alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
		alphatest_fragment: "#ifdef USE_ALPHATEST\nif(diffuseColor.a<alphaTest)discard;\n#endif",
		alphatest_pars_fragment: "#ifdef USE_ALPHATEST\nuniform float alphaTest;\n#endif",
		aomap_fragment: "#ifdef USE_AOMAP\nfloat ambientOcclusion=(texture2D(aoMap,vUv2).r-1.0)*aoMapIntensity+1.0;reflectedLight.indirectDiffuse*=ambientOcclusion;\n#if defined(USE_ENVMAP)&&defined(STANDARD)\nfloat dotNV=saturate(dot(geometry.normal,geometry.viewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);\n#endif\n#endif",
		aomap_pars_fragment: "#ifdef USE_AOMAP\nuniform sampler2D aoMap;uniform float aoMapIntensity;\n#endif",
		begin_vertex: "vec3 transformed=vec3(position);",
		beginnormal_vertex: "vec3 objectNormal=vec3(normal);\n#ifdef USE_TANGENT\nvec3 objectTangent=vec3(tangent.xyz);\n#endif",
		bsdfs: "vec3 BRDF_Lambert(const in vec3 diffuseColor){return RECIPROCAL_PI*diffuseColor;}vec3 F_Schlick(const in vec3 f0,const in float f90,const in float dotVH){float fresnel=exp2((-5.55473*dotVH-6.98316)*dotVH);return f0*(1.0-fresnel)+(f90*fresnel);}float V_GGX_SmithCorrelated(const in float alpha,const in float dotNL,const in float dotNV){float a2=pow2(alpha);float gv=dotNL*sqrt(a2+(1.0-a2)*pow2(dotNV));float gl=dotNV*sqrt(a2+(1.0-a2)*pow2(dotNL));return 0.5/max(gv+gl,EPSILON);}float D_GGX(const in float alpha,const in float dotNH){float a2=pow2(alpha);float denom=pow2(dotNH)*(a2-1.0)+1.0;return RECIPROCAL_PI*a2/pow2(denom);}vec3 BRDF_GGX(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated(alpha,dotNL,dotNV);float D=D_GGX(alpha,dotNH);return F*(V*D);}vec2 LTC_Uv(const in vec3 N,const in vec3 V,const in float roughness){const float LUT_SIZE=64.0;const float LUT_SCALE=(LUT_SIZE-1.0)/LUT_SIZE;const float LUT_BIAS=0.5/LUT_SIZE;float dotNV=saturate(dot(N,V));vec2 uv=vec2(roughness,sqrt(1.0-dotNV));uv=uv*LUT_SCALE+LUT_BIAS;return uv;}float LTC_ClippedSphereFormFactor(const in vec3 f){float l=length(f);return max((l*l+f.z)/(l+1.0),0.0);}vec3 LTC_EdgeVectorFormFactor(const in vec3 v1,const in vec3 v2){float x=dot(v1,v2);float y=abs(x);float a=0.8543985+(0.4965155+0.0145206*y)*y;float b=3.4175940+(4.1616724+y)*y;float v=a/b;float theta_sintheta=(x>0.0)?v:0.5*inversesqrt(max(1.0-x*x,1e-7))-v;return cross(v1,v2)*theta_sintheta;}vec3 LTC_Evaluate(const in vec3 N,const in vec3 V,const in vec3 P,const in mat3 mInv,const in vec3 rectCoords[4]){vec3 v1=rectCoords[1]-rectCoords[0];vec3 v2=rectCoords[3]-rectCoords[0];vec3 lightNormal=cross(v1,v2);if(dot(lightNormal,P-rectCoords[0])<0.0)return vec3(0.0);vec3 T1,T2;T1=normalize(V-N*dot(V,N));T2=-cross(N,T1);mat3 mat=mInv*transposeMat3(mat3(T1,T2,N));vec3 coords[4];coords[0]=mat*(rectCoords[0]-P);coords[1]=mat*(rectCoords[1]-P);coords[2]=mat*(rectCoords[2]-P);coords[3]=mat*(rectCoords[3]-P);coords[0]=normalize(coords[0]);coords[1]=normalize(coords[1]);coords[2]=normalize(coords[2]);coords[3]=normalize(coords[3]);vec3 vectorFormFactor=vec3(0.0);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[0],coords[1]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[1],coords[2]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[2],coords[3]);vectorFormFactor+=LTC_EdgeVectorFormFactor(coords[3],coords[0]);float result=LTC_ClippedSphereFormFactor(vectorFormFactor);return vec3(result);}float G_BlinnPhong_Implicit(){return 0.25;}float D_BlinnPhong(const in float shininess,const in float dotNH){return RECIPROCAL_PI*(shininess*0.5+1.0)*pow(dotNH,shininess);}vec3 BRDF_BlinnPhong(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float shininess){vec3 halfDir=normalize(lightDir+viewDir);float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));vec3 F=F_Schlick(specularColor,1.0,dotVH);float G=G_BlinnPhong_Implicit();float D=D_BlinnPhong(shininess,dotNH);return F*(G*D);}\n#if defined(USE_SHEEN)\nfloat D_Charlie(float roughness,float dotNH){float alpha=pow2(roughness);float invAlpha=1.0/alpha;float cos2h=dotNH*dotNH;float sin2h=max(1.0-cos2h,0.0078125);return(2.0+invAlpha)*pow(sin2h,invAlpha*0.5)/(2.0*PI);}float V_Neubelt(float dotNV,float dotNL){return saturate(1.0/(4.0*(dotNL+dotNV-dotNL*dotNV)));}vec3 BRDF_Sheen(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,vec3 sheenTint,const in float sheenRoughness){vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float D=D_Charlie(sheenRoughness,dotNH);float V=V_Neubelt(dotNV,dotNL);return sheenTint*(D*V);}\n#endif",
		bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;uniform float bumpScale;vec2 dHdxy_fwd(){vec2 dSTdx=dFdx(vUv);vec2 dSTdy=dFdy(vUv);float Hll=bumpScale*texture2D(bumpMap,vUv).x;float dBx=bumpScale*texture2D(bumpMap,vUv+dSTdx).x-Hll;float dBy=bumpScale*texture2D(bumpMap,vUv+dSTdy).x-Hll;return vec2(dBx,dBy);}vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=vec3(dFdx(surf_pos.x),dFdx(surf_pos.y),dFdx(surf_pos.z));vec3 vSigmaY=vec3(dFdy(surf_pos.x),dFdy(surf_pos.y),dFdy(surf_pos.z));vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}\n#endif",
		clipping_planes_fragment: "#if NUM_CLIPPING_PLANES>0\nvec4 plane;\n#pragma unroll_loop_start\nfor(int i=0;i<UNION_CLIPPING_PLANES;i++){plane=clippingPlanes[i];if(dot(vClipPosition,plane.xyz)>plane.w)discard;}\n#pragma unroll_loop_end\n#if UNION_CLIPPING_PLANES<NUM_CLIPPING_PLANES\nbool clipped=true;\n#pragma unroll_loop_start\nfor(int i=UNION_CLIPPING_PLANES;i<NUM_CLIPPING_PLANES;i++){plane=clippingPlanes[i];clipped=(dot(vClipPosition,plane.xyz)>plane.w)&&clipped;}\n#pragma unroll_loop_end\nif(clipped)discard;\n#endif\n#endif",
		clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;uniform vec4 clippingPlanes[NUM_CLIPPING_PLANES];\n#endif",
		clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES>0\nvarying vec3 vClipPosition;\n#endif",
		clipping_planes_vertex: "#if NUM_CLIPPING_PLANES>0\nvClipPosition=-mvPosition.xyz;\n#endif",
		color_fragment: "#if defined(USE_COLOR_ALPHA)\ndiffuseColor*=vColor;\n#elif defined(USE_COLOR)\ndiffuseColor.rgb*=vColor;\n#endif",
		color_pars_fragment: "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)\nvarying vec3 vColor;\n#endif",
		color_pars_vertex: "#if defined(USE_COLOR_ALPHA)\nvarying vec4 vColor;\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvarying vec3 vColor;\n#endif",
		color_vertex: "#if defined(USE_COLOR_ALPHA)\nvColor=vec4(1.0);\n#elif defined(USE_COLOR)||defined(USE_INSTANCING_COLOR)\nvColor=vec3(1.0);\n#endif\n#ifdef USE_COLOR\nvColor*=color;\n#endif\n#ifdef USE_INSTANCING_COLOR\nvColor.xyz*=instanceColor.xyz;\n#endif",
		common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\n#define whiteComplement(a)(1.0-saturate(a))\nfloat pow2(const in float x){return x*x;}float pow3(const in float x){return x*x*x;}float pow4(const in float x){float x2=x*x;return x2*x2;}float max3(const in vec3 v){return max(max(v.x,v.y),v.z);}float average(const in vec3 color){return dot(color,vec3(0.3333));}highp float rand(const in vec2 uv){const highp float a=12.9898,b=78.233,c=43758.5453;highp float dt=dot(uv.xy,vec2(a,b)),sn=mod(dt,PI);return fract(sin(sn)*c);}\n#ifdef HIGH_PRECISION\nfloat precisionSafeLength(vec3 v){return length(v);}\n#else\nfloat precisionSafeLength(vec3 v){float maxComponent=max3(abs(v));return length(v/maxComponent)*maxComponent;}\n#endif\nstruct IncidentLight{vec3 color;vec3 direction;bool visible;};struct ReflectedLight{vec3 directDiffuse;vec3 directSpecular;vec3 indirectDiffuse;vec3 indirectSpecular;};struct GeometricContext{vec3 position;vec3 normal;vec3 viewDir;\n#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal;\n#endif\n};vec3 transformDirection(in vec3 dir,in mat4 matrix){return normalize((matrix*vec4(dir,0.0)).xyz);}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}mat3 transposeMat3(const in mat3 m){mat3 tmp;tmp[0]=vec3(m[0].x,m[1].x,m[2].x);tmp[1]=vec3(m[0].y,m[1].y,m[2].y);tmp[2]=vec3(m[0].z,m[1].z,m[2].z);return tmp;}float linearToRelativeLuminance(const in vec3 color){vec3 weights=vec3(0.2126,0.7152,0.0722);return dot(weights,color.rgb);}bool isPerspectiveMatrix(mat4 m){return m[2][3]==-1.0;}vec2 equirectUv(in vec3 dir){float u=atan(dir.z,dir.x)*RECIPROCAL_PI2+0.5;float v=asin(clamp(dir.y,-1.0,1.0))*RECIPROCAL_PI+0.5;return vec2(u,v);}",
		cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction){vec3 absDirection=abs(direction);float face=-1.0;if(absDirection.x>absDirection.z){if(absDirection.x>absDirection.y)face=direction.x>0.0?0.0:3.0;else face=direction.y>0.0?1.0:4.0;}else{if(absDirection.z>absDirection.y)face=direction.z>0.0?2.0:5.0;else face=direction.y>0.0?1.0:4.0;}return face;}vec2 getUV(vec3 direction,float face){vec2 uv;if(face==0.0){uv=vec2(direction.z,direction.y)/abs(direction.x);}else if(face==1.0){uv=vec2(-direction.x,-direction.z)/abs(direction.y);}else if(face==2.0){uv=vec2(-direction.x,direction.y)/abs(direction.z);}else if(face==3.0){uv=vec2(-direction.z,direction.y)/abs(direction.x);}else if(face==4.0){uv=vec2(-direction.x,direction.z)/abs(direction.y);}else{uv=vec2(direction.x,direction.y)/abs(direction.z);}return 0.5*(uv+1.0);}vec3 bilinearCubeUV(sampler2D envMap,vec3 direction,float mipInt){float face=getFace(direction);float filterInt=max(cubeUV_minMipLevel-mipInt,0.0);mipInt=max(mipInt,cubeUV_minMipLevel);float faceSize=exp2(mipInt);float texelSize=1.0/(3.0*cubeUV_maxTileSize);vec2 uv=getUV(direction,face)*(faceSize-1.0);vec2 f=fract(uv);uv+=0.5-f;if(face>2.0){uv.y+=faceSize;face-=3.0;}uv.x+=face*faceSize;if(mipInt<cubeUV_maxMipLevel){uv.y+=2.0*cubeUV_maxTileSize;}uv.y+=filterInt*2.0*cubeUV_minTileSize;uv.x+=3.0*max(0.0,cubeUV_maxTileSize-2.0*faceSize);uv*=texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);return mix(tm,bm,f.y);}\n#define r0 1.0\n#define v0 0.339\n#define m0-2.0\n#define r1 0.8\n#define v1 0.276\n#define m1-1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness){float mip=0.0;if(roughness>=r1){mip=(r0-roughness)*(m1-m0)/(r0-r1)+m0;}else if(roughness>=r4){mip=(r1-roughness)*(m4-m1)/(r1-r4)+m1;}else if(roughness>=r5){mip=(r4-roughness)*(m5-m4)/(r4-r5)+m4;}else if(roughness>=r6){mip=(r5-roughness)*(m6-m5)/(r5-r6)+m5;}else{mip=-2.0*log2(1.16*roughness);}return mip;}vec4 textureCubeUV(sampler2D envMap,vec3 sampleDir,float roughness){float mip=clamp(roughnessToMip(roughness),m0,cubeUV_maxMipLevel);float mipF=fract(mip);float mipInt=floor(mip);vec3 color0=bilinearCubeUV(envMap,sampleDir,mipInt);if(mipF==0.0){return vec4(color0,1.0);}else{vec3 color1=bilinearCubeUV(envMap,sampleDir,mipInt+1.0);return vec4(mix(color0,color1,mipF),1.0);}}\n#endif",
		defaultnormal_vertex: "vec3 transformedNormal=objectNormal;\n#ifdef USE_INSTANCING\nmat3 m=mat3(instanceMatrix);transformedNormal/=vec3(dot(m[0],m[0]),dot(m[1],m[1]),dot(m[2],m[2]));transformedNormal=m*transformedNormal;\n#endif\ntransformedNormal=normalMatrix*transformedNormal;\n#ifdef FLIP_SIDED\ntransformedNormal=-transformedNormal;\n#endif\n#ifdef USE_TANGENT\nvec3 transformedTangent=(modelViewMatrix*vec4(objectTangent,0.0)).xyz;\n#ifdef FLIP_SIDED\ntransformedTangent=-transformedTangent;\n#endif\n#endif",
		displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;uniform float displacementScale;uniform float displacementBias;\n#endif",
		displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\ntransformed+=normalize(objectNormal)*(texture2D(displacementMap,vUv).x*displacementScale+displacementBias);\n#endif",
		emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\nvec4 emissiveColor=texture2D(emissiveMap,vUv);emissiveColor.rgb=emissiveMapTexelToLinear(emissiveColor).rgb;totalEmissiveRadiance*=emissiveColor.rgb;\n#endif",
		emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\nuniform sampler2D emissiveMap;\n#endif",
		encodings_fragment: "gl_FragColor=linearToOutputTexel(gl_FragColor);",
		encodings_pars_fragment: "vec4 LinearToLinear(in vec4 value){return value;}vec4 GammaToLinear(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(gammaFactor)),value.a);}vec4 LinearToGamma(in vec4 value,in float gammaFactor){return vec4(pow(value.rgb,vec3(1.0/gammaFactor)),value.a);}vec4 sRGBToLinear(in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}vec4 LinearTosRGB(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}vec4 RGBEToLinear(in vec4 value){return vec4(value.rgb*exp2(value.a*255.0-128.0),1.0);}vec4 LinearToRGBE(in vec4 value){float maxComponent=max(max(value.r,value.g),value.b);float fExp=clamp(ceil(log2(maxComponent)),-128.0,127.0);return vec4(value.rgb/exp2(fExp),(fExp+128.0)/255.0);}vec4 RGBMToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*value.a*maxRange,1.0);}vec4 LinearToRGBM(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float M=clamp(maxRGB/maxRange,0.0,1.0);M=ceil(M*255.0)/255.0;return vec4(value.rgb/(M*maxRange),M);}vec4 RGBDToLinear(in vec4 value,in float maxRange){return vec4(value.rgb*((maxRange/255.0)/value.a),1.0);}vec4 LinearToRGBD(in vec4 value,in float maxRange){float maxRGB=max(value.r,max(value.g,value.b));float D=max(maxRange/maxRGB,1.0);D=clamp(floor(D)/255.0,0.0,1.0);return vec4(value.rgb*(D*(255.0/maxRange)),D);}const mat3 cLogLuvM=mat3(0.2209,0.3390,0.4184,0.1138,0.6780,0.7319,0.0102,0.1130,0.2969);vec4 LinearToLogLuv(in vec4 value){vec3 Xp_Y_XYZp=cLogLuvM*value.rgb;Xp_Y_XYZp=max(Xp_Y_XYZp,vec3(1e-6,1e-6,1e-6));vec4 vResult;vResult.xy=Xp_Y_XYZp.xy/Xp_Y_XYZp.z;float Le=2.0*log2(Xp_Y_XYZp.y)+127.0;vResult.w=fract(Le);vResult.z=(Le-(floor(vResult.w*255.0))/255.0)/255.0;return vResult;}const mat3 cLogLuvInverseM=mat3(6.0014,-2.7008,-1.7996,-1.3320,3.1029,-5.7721,0.3008,-1.0882,5.6268);vec4 LogLuvToLinear(in vec4 value){float Le=value.z*255.0+value.w;vec3 Xp_Y_XYZp;Xp_Y_XYZp.y=exp2((Le-127.0)/2.0);Xp_Y_XYZp.z=Xp_Y_XYZp.y/value.y;Xp_Y_XYZp.x=value.x*Xp_Y_XYZp.z;vec3 vRGB=cLogLuvInverseM*Xp_Y_XYZp.rgb;return vec4(max(vRGB,0.0),1.0);}",
		envmap_fragment: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvec3 cameraToFrag;if(isOrthographic){cameraToFrag=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToFrag=normalize(vWorldPosition-cameraPosition);}vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvec3 reflectVec=reflect(cameraToFrag,worldNormal);\n#else\nvec3 reflectVec=refract(cameraToFrag,worldNormal,refractionRatio);\n#endif\n#else\nvec3 reflectVec=vReflect;\n#endif\n#ifdef ENVMAP_TYPE_CUBE\nvec4 envColor=textureCube(envMap,vec3(flipEnvMap*reflectVec.x,reflectVec.yz));envColor=envMapTexelToLinear(envColor);\n#elif defined(ENVMAP_TYPE_CUBE_UV)\nvec4 envColor=textureCubeUV(envMap,reflectVec,0.0);\n#else\nvec4 envColor=vec4(0.0);\n#endif\n#ifdef ENVMAP_BLENDING_MULTIPLY\noutgoingLight=mix(outgoingLight,outgoingLight*envColor.xyz,specularStrength*reflectivity);\n#elif defined(ENVMAP_BLENDING_MIX)\noutgoingLight=mix(outgoingLight,envColor.xyz,specularStrength*reflectivity);\n#elif defined(ENVMAP_BLENDING_ADD)\noutgoingLight+=envColor.xyz*specularStrength*reflectivity;\n#endif\n#endif",
		envmap_common_pars_fragment: "#ifdef USE_ENVMAP\nuniform float envMapIntensity;uniform float flipEnvMap;uniform int maxMipLevel;\n#ifdef ENVMAP_TYPE_CUBE\nuniform samplerCube envMap;\n#else\nuniform sampler2D envMap;\n#endif\n#endif",
		envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;uniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
		envmap_pars_vertex: "#ifdef USE_ENVMAP\n#if defined(USE_BUMPMAP)||defined(USE_NORMALMAP)||defined(PHONG)\n#define ENV_WORLDPOS\n#endif\n#ifdef ENV_WORLDPOS\nvarying vec3 vWorldPosition;\n#else\nvarying vec3 vReflect;uniform float refractionRatio;\n#endif\n#endif",
		envmap_physical_pars_fragment: "#if defined(USE_ENVMAP)\n#ifdef ENVMAP_MODE_REFRACTION\nuniform float refractionRatio;\n#endif\nvec3 getIBLIrradiance(const in vec3 normal){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,worldNormal,1.0);return PI*envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec;\n#ifdef ENVMAP_MODE_REFLECTION\nreflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));\n#else\nreflectVec=refract(-viewDir,normal,refractionRatio);\n#endif\nreflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*envMapIntensity;\n#else\nreturn vec3(0.0);\n#endif\n}\n#endif",
		envmap_vertex: "#ifdef USE_ENVMAP\n#ifdef ENV_WORLDPOS\nvWorldPosition=worldPosition.xyz;\n#else\nvec3 cameraToVertex;if(isOrthographic){cameraToVertex=normalize(vec3(-viewMatrix[0][2],-viewMatrix[1][2],-viewMatrix[2][2]));}else{cameraToVertex=normalize(worldPosition.xyz-cameraPosition);}vec3 worldNormal=inverseTransformDirection(transformedNormal,viewMatrix);\n#ifdef ENVMAP_MODE_REFLECTION\nvReflect=reflect(cameraToVertex,worldNormal);\n#else\nvReflect=refract(cameraToVertex,worldNormal,refractionRatio);\n#endif\n#endif\n#endif",
		fog_vertex: "#ifdef USE_FOG\nvFogDepth=-mvPosition.z;\n#endif",
		fog_pars_vertex: "#ifdef USE_FOG\nvarying float vFogDepth;\n#endif",
		fog_fragment: "#ifdef USE_FOG\n#ifdef FOG_EXP2\nfloat fogFactor=1.0-exp(-fogDensity*fogDensity*vFogDepth*vFogDepth);\n#else\nfloat fogFactor=smoothstep(fogNear,fogFar,vFogDepth);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,fogColor,fogFactor);\n#endif",
		fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;varying float vFogDepth;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;uniform float fogFar;\n#endif\n#endif",
		gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\nuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance(vec3 normal,vec3 lightDirection){float dotNL=dot(normal,lightDirection);vec2 coord=vec2(dotNL*0.5+0.5,0.0);\n#ifdef USE_GRADIENTMAP\nreturn texture2D(gradientMap,coord).rgb;\n#else\nreturn(coord.x<0.7)?vec3(0.7):vec3(1.0);\n#endif\n}",
		lightmap_fragment: "#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance*=PI;\n#endif\nreflectedLight.indirectDiffuse+=lightMapIrradiance;\n#endif",
		lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nuniform sampler2D lightMap;uniform float lightMapIntensity;\n#endif",
		lights_lambert_vertex: "vec3 diffuse=vec3(1.0);GeometricContext geometry;geometry.position=mvPosition.xyz;geometry.normal=normalize(transformedNormal);geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(-mvPosition.xyz);GeometricContext backGeometry;backGeometry.position=geometry.position;backGeometry.normal=-geometry.normal;backGeometry.viewDir=geometry.viewDir;vLightFront=vec3(0.0);vIndirectFront=vec3(0.0);\n#ifdef DOUBLE_SIDED\nvLightBack=vec3(0.0);vIndirectBack=vec3(0.0);\n#endif\nIncidentLight directLight;float dotNL;vec3 directLightColor_Diffuse;vIndirectFront+=getAmbientLightIrradiance(ambientLightColor);vIndirectFront+=getLightProbeIrradiance(lightProbe,geometry.normal);\n#ifdef DOUBLE_SIDED\nvIndirectBack+=getAmbientLightIrradiance(ambientLightColor);vIndirectBack+=getLightProbeIrradiance(lightProbe,backGeometry.normal);\n#endif\n#if NUM_POINT_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHTS;i++){getPointLightInfo(pointLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHTS;i++){getSpotLightInfo(spotLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHTS;i++){getDirectionalLightInfo(directionalLights[i],geometry,directLight);dotNL=dot(geometry.normal,directLight.direction);directLightColor_Diffuse=directLight.color;vLightFront+=saturate(dotNL)*directLightColor_Diffuse;\n#ifdef DOUBLE_SIDED\nvLightBack+=saturate(-dotNL)*directLightColor_Diffuse;\n#endif\n}\n#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_HEMI_LIGHTS;i++){vIndirectFront+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);\n#ifdef DOUBLE_SIDED\nvIndirectBack+=getHemisphereLightIrradiance(hemisphereLights[i],backGeometry.normal);\n#endif\n}\n#pragma unroll_loop_end\n#endif",
		lights_pars_begin: "uniform bool receiveShadow;uniform vec3 ambientLightColor;uniform vec3 lightProbe[9];vec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){float x=normal.x,y=normal.y,z=normal.z;vec3 result=shCoefficients[0]*0.886227;result+=shCoefficients[1]*2.0*0.511664*y;result+=shCoefficients[2]*2.0*0.511664*z;result+=shCoefficients[3]*2.0*0.511664*x;result+=shCoefficients[4]*2.0*0.429043*x*y;result+=shCoefficients[5]*2.0*0.429043*y*z;result+=shCoefficients[6]*(0.743125*z*z-0.247708);result+=shCoefficients[7]*2.0*0.429043*x*z;result+=shCoefficients[8]*0.429043*(x*x-y*y);return result;}vec3 getLightProbeIrradiance(const in vec3 lightProbe[9],const in vec3 normal){vec3 worldNormal=inverseTransformDirection(normal,viewMatrix);vec3 irradiance=shGetIrradianceAt(worldNormal,lightProbe);return irradiance;}vec3 getAmbientLightIrradiance(const in vec3 ambientLightColor){vec3 irradiance=ambientLightColor;return irradiance;}float getDistanceAttenuation(const in float lightDistance,const in float cutoffDistance,const in float decayExponent){\n#if defined(PHYSICALLY_CORRECT_LIGHTS)\nfloat distanceFalloff=1.0/max(pow(lightDistance,decayExponent),0.01);if(cutoffDistance>0.0){distanceFalloff*=pow2(saturate(1.0-pow4(lightDistance/cutoffDistance)));}return distanceFalloff;\n#else\nif(cutoffDistance>0.0&&decayExponent>0.0){return pow(saturate(-lightDistance/cutoffDistance+1.0),decayExponent);}return 1.0;\n#endif\n}float getSpotAttenuation(const in float coneCosine,const in float penumbraCosine,const in float angleCosine){return smoothstep(coneCosine,penumbraCosine,angleCosine);}\n#if NUM_DIR_LIGHTS>0\nstruct DirectionalLight{vec3 direction;vec3 color;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];void getDirectionalLightInfo(const in DirectionalLight directionalLight,const in GeometricContext geometry,out IncidentLight light){light.color=directionalLight.color;light.direction=directionalLight.direction;light.visible=true;}\n#endif\n#if NUM_POINT_LIGHTS>0\nstruct PointLight{vec3 position;vec3 color;float distance;float decay;};uniform PointLight pointLights[NUM_POINT_LIGHTS];void getPointLightInfo(const in PointLight pointLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=pointLight.position-geometry.position;light.direction=normalize(lVector);float lightDistance=length(lVector);light.color=pointLight.color;light.color*=getDistanceAttenuation(lightDistance,pointLight.distance,pointLight.decay);light.visible=(light.color!=vec3(0.0));}\n#endif\n#if NUM_SPOT_LIGHTS>0\nstruct SpotLight{vec3 position;vec3 direction;vec3 color;float distance;float decay;float coneCos;float penumbraCos;};uniform SpotLight spotLights[NUM_SPOT_LIGHTS];void getSpotLightInfo(const in SpotLight spotLight,const in GeometricContext geometry,out IncidentLight light){vec3 lVector=spotLight.position-geometry.position;light.direction=normalize(lVector);float angleCos=dot(light.direction,spotLight.direction);float spotAttenuation=getSpotAttenuation(spotLight.coneCos,spotLight.penumbraCos,angleCos);if(spotAttenuation>0.0){float lightDistance=length(lVector);light.color=spotLight.color*spotAttenuation;light.color*=getDistanceAttenuation(lightDistance,spotLight.distance,spotLight.decay);light.visible=(light.color!=vec3(0.0));}else{light.color=vec3(0.0);light.visible=false;}}\n#endif\n#if NUM_RECT_AREA_LIGHTS>0\nstruct RectAreaLight{vec3 color;vec3 position;vec3 halfWidth;vec3 halfHeight;};uniform sampler2D ltc_1;uniform sampler2D ltc_2;uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS>0\nstruct HemisphereLight{vec3 direction;vec3 skyColor;vec3 groundColor;};uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];vec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight,const in vec3 normal){float dotNL=dot(normal,hemiLight.direction);float hemiDiffuseWeight=0.5*dotNL+0.5;vec3 irradiance=mix(hemiLight.groundColor,hemiLight.skyColor,hemiDiffuseWeight);return irradiance;}\n#endif",
		lights_toon_fragment: "ToonMaterial material;material.diffuseColor=diffuseColor.rgb;",
		lights_toon_pars_fragment: "varying vec3 vViewPosition;struct ToonMaterial{vec3 diffuseColor;};void RE_Direct_Toon(const in IncidentLight directLight,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){vec3 irradiance=getGradientIrradiance(geometry.normal,directLight.direction)*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Toon(const in vec3 irradiance,const in GeometricContext geometry,const in ToonMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}\n#define RE_Direct RE_Direct_Toon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD(material)(0)",
		lights_phong_fragment: "BlinnPhongMaterial material;material.diffuseColor=diffuseColor.rgb;material.specularColor=specular;material.specularShininess=shininess;material.specularStrength=specularStrength;",
		lights_phong_pars_fragment: "varying vec3 vViewPosition;struct BlinnPhongMaterial{vec3 diffuseColor;vec3 specularColor;float specularShininess;float specularStrength;};void RE_Direct_BlinnPhong(const in IncidentLight directLight,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);reflectedLight.directSpecular+=irradiance*BRDF_BlinnPhong(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularShininess)*material.specularStrength;}void RE_IndirectDiffuse_BlinnPhong(const in vec3 irradiance,const in GeometricContext geometry,const in BlinnPhongMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}\n#define RE_Direct RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD(material)(0)",
		lights_physical_fragment: "PhysicalMaterial material;material.diffuseColor=diffuseColor.rgb*(1.0-metalnessFactor);vec3 dxy=max(abs(dFdx(geometryNormal)),abs(dFdy(geometryNormal)));float geometryRoughness=max(max(dxy.x,dxy.y),dxy.z);material.roughness=max(roughnessFactor,0.0525);material.roughness+=geometryRoughness;material.roughness=min(material.roughness,1.0);\n#ifdef IOR\n#ifdef SPECULAR\nfloat specularIntensityFactor=specularIntensity;vec3 specularTintFactor=specularTint;\n#ifdef USE_SPECULARINTENSITYMAP\nspecularIntensityFactor*=texture2D(specularIntensityMap,vUv).a;\n#endif\n#ifdef USE_SPECULARTINTMAP\nspecularTintFactor*=specularTintMapTexelToLinear(texture2D(specularTintMap,vUv)).rgb;\n#endif\nmaterial.specularF90=mix(specularIntensityFactor,1.0,metalnessFactor);\n#else\nfloat specularIntensityFactor=1.0;vec3 specularTintFactor=vec3(1.0);material.specularF90=1.0;\n#endif\nmaterial.specularColor=mix(min(pow2((ior-1.0)/(ior+1.0))*specularTintFactor,vec3(1.0))*specularIntensityFactor,diffuseColor.rgb,metalnessFactor);\n#else\nmaterial.specularColor=mix(vec3(0.04),diffuseColor.rgb,metalnessFactor);material.specularF90=1.0;\n#endif\n#ifdef USE_CLEARCOAT\nmaterial.clearcoat=clearcoat;material.clearcoatRoughness=clearcoatRoughness;material.clearcoatF0=vec3(0.04);material.clearcoatF90=1.0;\n#ifdef USE_CLEARCOATMAP\nmaterial.clearcoat*=texture2D(clearcoatMap,vUv).x;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nmaterial.clearcoatRoughness*=texture2D(clearcoatRoughnessMap,vUv).y;\n#endif\nmaterial.clearcoat=saturate(material.clearcoat);material.clearcoatRoughness=max(material.clearcoatRoughness,0.0525);material.clearcoatRoughness+=geometryRoughness;material.clearcoatRoughness=min(material.clearcoatRoughness,1.0);\n#endif\n#ifdef USE_SHEEN\nmaterial.sheenTint=sheenTint;material.sheenRoughness=clamp(sheenRoughness,0.07,1.0);\n#endif",
		lights_physical_pars_fragment: "struct PhysicalMaterial{vec3 diffuseColor;float roughness;vec3 specularColor;float specularF90;\n#ifdef USE_CLEARCOAT\nfloat clearcoat;float clearcoatRoughness;vec3 clearcoatF0;float clearcoatF90;\n#endif\n#ifdef USE_SHEEN\nvec3 sheenTint;float sheenRoughness;\n#endif\n};vec3 clearcoatSpecular=vec3(0.0);vec2 DFGApprox(const in vec3 normal,const in vec3 viewDir,const in float roughness){float dotNV=saturate(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 fab=vec2(-1.04,1.04)*a004+r.zw;return fab;}vec3 EnvironmentBRDF(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness){vec2 fab=DFGApprox(normal,viewDir,roughness);return specularColor*fab.x+specularF90*fab.y;}void computeMultiscattering(const in vec3 normal,const in vec3 viewDir,const in vec3 specularColor,const in float specularF90,const in float roughness,inout vec3 singleScatter,inout vec3 multiScatter){vec2 fab=DFGApprox(normal,viewDir,roughness);vec3 FssEss=specularColor*fab.x+specularF90*fab.y;float Ess=fab.x+fab.y;float Ems=1.0-Ess;vec3 Favg=specularColor+(1.0-specularColor)*0.047619;vec3 Fms=FssEss*Favg/(1.0-Ems*Favg);singleScatter+=FssEss;multiScatter+=Fms*Ems;}\n#if NUM_RECT_AREA_LIGHTS>0\nvoid RE_Direct_RectArea_Physical(const in RectAreaLight rectAreaLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){vec3 normal=geometry.normal;vec3 viewDir=geometry.viewDir;vec3 position=geometry.position;vec3 lightPos=rectAreaLight.position;vec3 halfWidth=rectAreaLight.halfWidth;vec3 halfHeight=rectAreaLight.halfHeight;vec3 lightColor=rectAreaLight.color;float roughness=material.roughness;vec3 rectCoords[4];rectCoords[0]=lightPos+halfWidth-halfHeight;rectCoords[1]=lightPos-halfWidth-halfHeight;rectCoords[2]=lightPos-halfWidth+halfHeight;rectCoords[3]=lightPos+halfWidth+halfHeight;vec2 uv=LTC_Uv(normal,viewDir,roughness);vec4 t1=texture2D(ltc_1,uv);vec4 t2=texture2D(ltc_2,uv);mat3 mInv=mat3(vec3(t1.x,0,t1.y),vec3(0,1,0),vec3(t1.z,0,t1.w));vec3 fresnel=(material.specularColor*t2.x+(vec3(1.0)-material.specularColor)*t2.y);reflectedLight.directSpecular+=lightColor*fresnel*LTC_Evaluate(normal,viewDir,position,mInv,rectCoords);reflectedLight.directDiffuse+=lightColor*material.diffuseColor*LTC_Evaluate(normal,viewDir,position,mat3(1.0),rectCoords);}\n#endif\nvoid RE_Direct_Physical(const in IncidentLight directLight,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){float dotNL=saturate(dot(geometry.normal,directLight.direction));vec3 irradiance=dotNL*directLight.color;\n#ifdef USE_CLEARCOAT\nfloat dotNLcc=saturate(dot(geometry.clearcoatNormal,directLight.direction));vec3 ccIrradiance=dotNLcc*directLight.color;clearcoatSpecular+=ccIrradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.clearcoatNormal,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);\n#endif\n#ifdef USE_SHEEN\nreflectedLight.directSpecular+=irradiance*BRDF_Sheen(directLight.direction,geometry.viewDir,geometry.normal,material.sheenTint,material.sheenRoughness);\n#endif\nreflectedLight.directSpecular+=irradiance*BRDF_GGX(directLight.direction,geometry.viewDir,geometry.normal,material.specularColor,material.specularF90,material.roughness);reflectedLight.directDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectDiffuse_Physical(const in vec3 irradiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){reflectedLight.indirectDiffuse+=irradiance*BRDF_Lambert(material.diffuseColor);}void RE_IndirectSpecular_Physical(const in vec3 radiance,const in vec3 irradiance,const in vec3 clearcoatRadiance,const in GeometricContext geometry,const in PhysicalMaterial material,inout ReflectedLight reflectedLight){\n#ifdef USE_CLEARCOAT\nclearcoatSpecular+=clearcoatRadiance*EnvironmentBRDF(geometry.clearcoatNormal,geometry.viewDir,material.clearcoatF0,material.clearcoatF90,material.clearcoatRoughness);\n#endif\nvec3 singleScattering=vec3(0.0);vec3 multiScattering=vec3(0.0);vec3 cosineWeightedIrradiance=irradiance*RECIPROCAL_PI;computeMultiscattering(geometry.normal,geometry.viewDir,material.specularColor,material.specularF90,material.roughness,singleScattering,multiScattering);vec3 diffuse=material.diffuseColor*(1.0-(singleScattering+multiScattering));reflectedLight.indirectSpecular+=radiance*singleScattering;reflectedLight.indirectSpecular+=multiScattering*cosineWeightedIrradiance;reflectedLight.indirectDiffuse+=diffuse*cosineWeightedIrradiance;}\n#define RE_Direct RE_Direct_Physical\n#define RE_Direct_RectArea RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion(const in float dotNV,const in float ambientOcclusion,const in float roughness){return saturate(pow(dotNV+ambientOcclusion,exp2(-16.0*roughness-1.0))-1.0+ambientOcclusion);}",
		lights_fragment_begin: "GeometricContext geometry;geometry.position=-vViewPosition;geometry.normal=normal;geometry.viewDir=(isOrthographic)?vec3(0,0,1):normalize(vViewPosition);\n#ifdef USE_CLEARCOAT\ngeometry.clearcoatNormal=clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if (NUM_POINT_LIGHTS>0)&&defined(RE_Direct)\nPointLight pointLight;\n#if defined(USE_SHADOWMAP)&&NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHTS;i++){pointLight=pointLights[i];getPointLightInfo(pointLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_POINT_LIGHT_SHADOWS)\npointLightShadow=pointLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getPointShadow(pointShadowMap[i],pointLightShadow.shadowMapSize,pointLightShadow.shadowBias,pointLightShadow.shadowRadius,vPointShadowCoord[i],pointLightShadow.shadowCameraNear,pointLightShadow.shadowCameraFar):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_SPOT_LIGHTS>0)&&defined(RE_Direct)\nSpotLight spotLight;\n#if defined(USE_SHADOWMAP)&&NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHTS;i++){spotLight=spotLights[i];getSpotLightInfo(spotLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_SPOT_LIGHT_SHADOWS)\nspotLightShadow=spotLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(spotShadowMap[i],spotLightShadow.shadowMapSize,spotLightShadow.shadowBias,spotLightShadow.shadowRadius,vSpotShadowCoord[i]):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_DIR_LIGHTS>0)&&defined(RE_Direct)\nDirectionalLight directionalLight;\n#if defined(USE_SHADOWMAP)&&NUM_DIR_LIGHT_SHADOWS>0\nDirectionalLightShadow directionalLightShadow;\n#endif\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHTS;i++){directionalLight=directionalLights[i];getDirectionalLightInfo(directionalLight,geometry,directLight);\n#if defined(USE_SHADOWMAP)&&(UNROLLED_LOOP_INDEX<NUM_DIR_LIGHT_SHADOWS)\ndirectionalLightShadow=directionalLightShadows[i];directLight.color*=all(bvec2(directLight.visible,receiveShadow))?getShadow(directionalShadowMap[i],directionalLightShadow.shadowMapSize,directionalLightShadow.shadowBias,directionalLightShadow.shadowRadius,vDirectionalShadowCoord[i]):1.0;\n#endif\nRE_Direct(directLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if (NUM_RECT_AREA_LIGHTS>0)&&defined(RE_Direct_RectArea)\nRectAreaLight rectAreaLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_RECT_AREA_LIGHTS;i++){rectAreaLight=rectAreaLights[i];RE_Direct_RectArea(rectAreaLight,geometry,material,reflectedLight);}\n#pragma unroll_loop_end\n#endif\n#if defined(RE_IndirectDiffuse)\nvec3 iblIrradiance=vec3(0.0);vec3 irradiance=getAmbientLightIrradiance(ambientLightColor);irradiance+=getLightProbeIrradiance(lightProbe,geometry.normal);\n#if (NUM_HEMI_LIGHTS>0)\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_HEMI_LIGHTS;i++){irradiance+=getHemisphereLightIrradiance(hemisphereLights[i],geometry.normal);}\n#pragma unroll_loop_end\n#endif\n#endif\n#if defined(RE_IndirectSpecular)\nvec3 radiance=vec3(0.0);vec3 clearcoatRadiance=vec3(0.0);\n#endif",
		lights_fragment_maps: "#if defined(RE_IndirectDiffuse)\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);vec3 lightMapIrradiance=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#ifndef PHYSICALLY_CORRECT_LIGHTS\nlightMapIrradiance*=PI;\n#endif\nirradiance+=lightMapIrradiance;\n#endif\n#if defined(USE_ENVMAP)&&defined(STANDARD)&&defined(ENVMAP_TYPE_CUBE_UV)\niblIrradiance+=getIBLIrradiance(geometry.normal);\n#endif\n#endif\n#if defined(USE_ENVMAP)&&defined(RE_IndirectSpecular)\nradiance+=getIBLRadiance(geometry.viewDir,geometry.normal,material.roughness);\n#ifdef USE_CLEARCOAT\nclearcoatRadiance+=getIBLRadiance(geometry.viewDir,geometry.clearcoatNormal,material.clearcoatRoughness);\n#endif\n#endif",
		lights_fragment_end: "#if defined(RE_IndirectDiffuse)\nRE_IndirectDiffuse(irradiance,geometry,material,reflectedLight);\n#endif\n#if defined(RE_IndirectSpecular)\nRE_IndirectSpecular(radiance,iblIrradiance,clearcoatRadiance,geometry,material,reflectedLight);\n#endif",
		logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\ngl_FragDepthEXT=vIsPerspective==0.0?gl_FragCoord.z:log2(vFragDepth)*logDepthBufFC*0.5;\n#endif",
		logdepthbuf_pars_fragment: "#if defined(USE_LOGDEPTHBUF)&&defined(USE_LOGDEPTHBUF_EXT)\nuniform float logDepthBufFC;varying float vFragDepth;varying float vIsPerspective;\n#endif",
		logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvarying float vFragDepth;varying float vIsPerspective;\n#else\nuniform float logDepthBufFC;\n#endif\n#endif",
		logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n#ifdef USE_LOGDEPTHBUF_EXT\nvFragDepth=1.0+gl_Position.w;vIsPerspective=float(isPerspectiveMatrix(projectionMatrix));\n#else\nif(isPerspectiveMatrix(projectionMatrix)){gl_Position.z=log2(max(EPSILON,gl_Position.w+1.0))*logDepthBufFC-1.0;gl_Position.z*=gl_Position.w;}\n#endif\n#endif",
		map_fragment: "#ifdef USE_MAP\nvec4 texelColor=texture2D(map,vUv);texelColor=mapTexelToLinear(texelColor);diffuseColor*=texelColor;\n#endif",
		map_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
		map_particle_fragment: "#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nvec2 uv=(uvTransform*vec3(gl_PointCoord.x,1.0-gl_PointCoord.y,1)).xy;\n#endif\n#ifdef USE_MAP\nvec4 mapTexel=texture2D(map,uv);diffuseColor*=mapTexelToLinear(mapTexel);\n#endif\n#ifdef USE_ALPHAMAP\ndiffuseColor.a*=texture2D(alphaMap,uv).g;\n#endif",
		map_particle_pars_fragment: "#if defined(USE_MAP)||defined(USE_ALPHAMAP)\nuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\nuniform sampler2D alphaMap;\n#endif",
		metalnessmap_fragment: "float metalnessFactor=metalness;\n#ifdef USE_METALNESSMAP\nvec4 texelMetalness=texture2D(metalnessMap,vUv);metalnessFactor*=texelMetalness.b;\n#endif",
		metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\nuniform sampler2D metalnessMap;\n#endif",
		morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nobjectNormal*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor(int i=0;i<MORPHTARGETS_COUNT;i++){if(morphTargetInfluences[i]>0.0)objectNormal+=getMorph(gl_VertexID,i,1,2)*morphTargetInfluences[i];}\n#else\nobjectNormal+=morphNormal0*morphTargetInfluences[0];objectNormal+=morphNormal1*morphTargetInfluences[1];objectNormal+=morphNormal2*morphTargetInfluences[2];objectNormal+=morphNormal3*morphTargetInfluences[3];\n#endif\n#endif",
		morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\nuniform float morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nuniform float morphTargetInfluences[MORPHTARGETS_COUNT];uniform sampler2DArray morphTargetsTexture;uniform vec2 morphTargetsTextureSize;vec3 getMorph(const in int vertexIndex,const in int morphTargetIndex,const in int offset,const in int stride){float texelIndex=float(vertexIndex*stride+offset);float y=floor(texelIndex/morphTargetsTextureSize.x);float x=texelIndex-y*morphTargetsTextureSize.x;vec3 morphUV=vec3((x+0.5)/morphTargetsTextureSize.x,y/morphTargetsTextureSize.y,morphTargetIndex);return texture(morphTargetsTexture,morphUV).xyz;}\n#else\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[8];\n#else\nuniform float morphTargetInfluences[4];\n#endif\n#endif\n#endif",
		morphtarget_vertex: "#ifdef USE_MORPHTARGETS\ntransformed*=morphTargetBaseInfluence;\n#ifdef MORPHTARGETS_TEXTURE\nfor(int i=0;i<MORPHTARGETS_COUNT;i++){\n#ifndef USE_MORPHNORMALS\nif(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,1)*morphTargetInfluences[i];\n#else\nif(morphTargetInfluences[i]>0.0)transformed+=getMorph(gl_VertexID,i,0,2)*morphTargetInfluences[i];\n#endif\n}\n#else\ntransformed+=morphTarget0*morphTargetInfluences[0];transformed+=morphTarget1*morphTargetInfluences[1];transformed+=morphTarget2*morphTargetInfluences[2];transformed+=morphTarget3*morphTargetInfluences[3];\n#ifndef USE_MORPHNORMALS\ntransformed+=morphTarget4*morphTargetInfluences[4];transformed+=morphTarget5*morphTargetInfluences[5];transformed+=morphTarget6*morphTargetInfluences[6];transformed+=morphTarget7*morphTargetInfluences[7];\n#endif\n#endif\n#endif",
		normal_fragment_begin: "float faceDirection=gl_FrontFacing?1.0:-1.0;\n#ifdef FLAT_SHADED\nvec3 fdx=vec3(dFdx(vViewPosition.x),dFdx(vViewPosition.y),dFdx(vViewPosition.z));vec3 fdy=vec3(dFdy(vViewPosition.x),dFdy(vViewPosition.y),dFdy(vViewPosition.z));vec3 normal=normalize(cross(fdx,fdy));\n#else\nvec3 normal=normalize(vNormal);\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\n#ifdef USE_TANGENT\nvec3 tangent=normalize(vTangent);vec3 bitangent=normalize(vBitangent);\n#ifdef DOUBLE_SIDED\ntangent=tangent*faceDirection;bitangent=bitangent*faceDirection;\n#endif\n#if defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP)\nmat3 vTBN=mat3(tangent,bitangent,normal);\n#endif\n#endif\n#endif\nvec3 geometryNormal=normal;",
		normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\nnormal=texture2D(normalMap,vUv).xyz*2.0-1.0;\n#ifdef FLIP_SIDED\nnormal=-normal;\n#endif\n#ifdef DOUBLE_SIDED\nnormal=normal*faceDirection;\n#endif\nnormal=normalize(normalMatrix*normal);\n#elif defined(TANGENTSPACE_NORMALMAP)\nvec3 mapN=texture2D(normalMap,vUv).xyz*2.0-1.0;mapN.xy*=normalScale;\n#ifdef USE_TANGENT\nnormal=normalize(vTBN*mapN);\n#else\nnormal=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#endif\n#elif defined(USE_BUMPMAP)\nnormal=perturbNormalArb(-vViewPosition,normal,dHdxy_fwd(),faceDirection);\n#endif",
		normal_pars_fragment: "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif",
		normal_pars_vertex: "#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#ifdef USE_TANGENT\nvarying vec3 vTangent;varying vec3 vBitangent;\n#endif\n#endif",
		normal_vertex: "#ifndef FLAT_SHADED\nvNormal=normalize(transformedNormal);\n#ifdef USE_TANGENT\nvTangent=normalize(transformedTangent);vBitangent=normalize(cross(vNormal,vTangent)*tangent.w);\n#endif\n#endif",
		normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat3 normalMatrix;\n#endif\n#if !defined(USE_TANGENT)&&(defined(TANGENTSPACE_NORMALMAP)||defined(USE_CLEARCOAT_NORMALMAP))\nvec3 perturbNormal2Arb(vec3 eye_pos,vec3 surf_norm,vec3 mapN,float faceDirection){vec3 q0=vec3(dFdx(eye_pos.x),dFdx(eye_pos.y),dFdx(eye_pos.z));vec3 q1=vec3(dFdy(eye_pos.x),dFdy(eye_pos.y),dFdy(eye_pos.z));vec2 st0=dFdx(vUv.st);vec2 st1=dFdy(vUv.st);vec3 N=surf_norm;vec3 q1perp=cross(q1,N);vec3 q0perp=cross(N,q0);vec3 T=q1perp*st0.x+q0perp*st1.x;vec3 B=q1perp*st0.y+q0perp*st1.y;float det=max(dot(T,T),dot(B,B));float scale=(det==0.0)?0.0:faceDirection*inversesqrt(det);return normalize(T*(mapN.x*scale)+B*(mapN.y*scale)+N*mapN.z);}\n#endif",
		clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\nvec3 clearcoatNormal=geometryNormal;\n#endif",
		clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\nvec3 clearcoatMapN=texture2D(clearcoatNormalMap,vUv).xyz*2.0-1.0;clearcoatMapN.xy*=clearcoatNormalScale;\n#ifdef USE_TANGENT\nclearcoatNormal=normalize(vTBN*clearcoatMapN);\n#else\nclearcoatNormal=perturbNormal2Arb(-vViewPosition,clearcoatNormal,clearcoatMapN,faceDirection);\n#endif\n#endif",
		clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\nuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\nuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\nuniform sampler2D clearcoatNormalMap;uniform vec2 clearcoatNormalScale;\n#endif",
		output_fragment: "#ifdef OPAQUE\ndiffuseColor.a=1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a*=transmissionAlpha+0.1;\n#endif\ngl_FragColor=vec4(outgoingLight,diffuseColor.a);",
		packing: "vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}",
		premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\ngl_FragColor.rgb*=gl_FragColor.a;\n#endif",
		project_vertex: "vec4 mvPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nmvPosition=instanceMatrix*mvPosition;\n#endif\nmvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;",
		dithering_fragment: "#ifdef DITHERING\ngl_FragColor.rgb=dithering(gl_FragColor.rgb);\n#endif",
		dithering_pars_fragment: "#ifdef DITHERING\nvec3 dithering(vec3 color){float grid_position=rand(gl_FragCoord.xy);vec3 dither_shift_RGB=vec3(0.25/255.0,-0.25/255.0,0.25/255.0);dither_shift_RGB=mix(2.0*dither_shift_RGB,-2.0*dither_shift_RGB,grid_position);return color+dither_shift_RGB;}\n#endif",
		roughnessmap_fragment: "float roughnessFactor=roughness;\n#ifdef USE_ROUGHNESSMAP\nvec4 texelRoughness=texture2D(roughnessMap,vUv);roughnessFactor*=texelRoughness.g;\n#endif",
		roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\nuniform sampler2D roughnessMap;\n#endif",
		shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\nfloat texture2DCompare(sampler2D depths,vec2 uv,float compare){return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));}vec2 texture2DDistribution(sampler2D shadow,vec2 uv){return unpackRGBATo2Half(texture2D(shadow,uv));}float VSMShadow(sampler2D shadow,vec2 uv,float compare){float occlusion=1.0;vec2 distribution=texture2DDistribution(shadow,uv);float hard_shadow=step(compare,distribution.x);if(hard_shadow!=1.0){float distance=compare-distribution.x;float variance=max(0.00000,distribution.y*distribution.y);float softness_probability=variance/(variance+distance*distance);softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0);occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);}return occlusion;}float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord){float shadow=1.0;shadowCoord.xyz/=shadowCoord.w;shadowCoord.z+=shadowBias;bvec4 inFrustumVec=bvec4(shadowCoord.x>=0.0,shadowCoord.x<=1.0,shadowCoord.y>=0.0,shadowCoord.y<=1.0);bool inFrustum=all(inFrustumVec);bvec2 frustumTestVec=bvec2(inFrustum,shadowCoord.z<=1.0);bool frustumTest=all(frustumTestVec);if(frustumTest){\n#if defined(SHADOWMAP_TYPE_PCF)\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx0=-texelSize.x*shadowRadius;float dy0=-texelSize.y*shadowRadius;float dx1=+texelSize.x*shadowRadius;float dy1=+texelSize.y*shadowRadius;float dx2=dx0/2.0;float dy2=dy0/2.0;float dx3=dx1/2.0;float dy3=dy1/2.0;shadow=(texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy1),shadowCoord.z))*(1.0/17.0);\n#elif defined(SHADOWMAP_TYPE_PCF_SOFT)\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx=texelSize.x;float dy=texelSize.y;vec2 uv=shadowCoord.xy;vec2 f=fract(uv*shadowMapSize+0.5);uv-=f*texelSize;shadow=(texture2DCompare(shadowMap,uv,shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(dx,0.0),shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(0.0,dy),shadowCoord.z)+texture2DCompare(shadowMap,uv+texelSize,shadowCoord.z)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,0.0),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,0.0),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,dy),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(0.0,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(0.0,2.0*dy),shadowCoord.z),f.y)+mix(texture2DCompare(shadowMap,uv+vec2(dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(dx,2.0*dy),shadowCoord.z),f.y)+mix(mix(texture2DCompare(shadowMap,uv+vec2(-dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,-dy),shadowCoord.z),f.x),mix(texture2DCompare(shadowMap,uv+vec2(-dx,2.0*dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,2.0*dy),shadowCoord.z),f.x),f.y))*(1.0/9.0);\n#elif defined(SHADOWMAP_TYPE_VSM)\nshadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);\n#else\nshadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);\n#endif\n}return shadow;}vec2 cubeToUV(vec3 v,float texelSizeY){vec3 absV=abs(v);float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));absV*=scaleToCube;v*=scaleToCube*(1.0-2.0*texelSizeY);vec2 planar=v.xy;float almostATexel=1.5*texelSizeY;float almostOne=1.0-almostATexel;if(absV.z>=almostOne){if(v.z>0.0)planar.x=4.0-v.x;}else if(absV.x>=almostOne){float signX=sign(v.x);planar.x=v.z*signX+2.0*signX;}else if(absV.y>=almostOne){float signY=sign(v.y);planar.x=v.x+2.0*signY+2.0;planar.y=v.z*signY-2.0;}return vec2(0.125,0.25)*planar+vec2(0.375,0.75);}float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));vec3 lightToPosition=shadowCoord.xyz;float dp=(length(lightToPosition)-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);dp+=shadowBias;vec3 bd3D=normalize(lightToPosition);\n#if defined(SHADOWMAP_TYPE_PCF)||defined(SHADOWMAP_TYPE_PCF_SOFT)||defined(SHADOWMAP_TYPE_VSM)\nvec2 offset=vec2(-1,1)*shadowRadius*texelSize.y;return(texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxx,texelSize.y),dp))*(1.0/9.0);\n#else\nreturn texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);\n#endif\n}\n#endif",
		shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#endif",
		shadowmap_vertex: "#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0||NUM_SPOT_LIGHT_SHADOWS>0||NUM_POINT_LIGHT_SHADOWS>0\nvec3 shadowWorldNormal=inverseTransformDirection(transformedNormal,viewMatrix);vec4 shadowWorldPosition;\n#endif\n#if NUM_DIR_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadows[i].shadowNormalBias,0);vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);vSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);vPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#endif",
		shadowmask_pars_fragment: "float getShadowMask(){float shadow=1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS>0\nDirectionalLightShadow directionalLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow?getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]):1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS>0\nSpotLightShadow spotLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow?getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]):1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS>0\nPointLightShadow pointLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow?getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar):1.0;}\n#pragma unroll_loop_end\n#endif\n#endif\nreturn shadow;}",
		skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX=getBoneMatrix(skinIndex.x);mat4 boneMatY=getBoneMatrix(skinIndex.y);mat4 boneMatZ=getBoneMatrix(skinIndex.z);mat4 boneMatW=getBoneMatrix(skinIndex.w);\n#endif",
		skinning_pars_vertex: "#ifdef USE_SKINNING\nuniform mat4 bindMatrix;uniform mat4 bindMatrixInverse;\n#ifdef BONE_TEXTURE\nuniform highp sampler2D boneTexture;uniform int boneTextureSize;mat4 getBoneMatrix(const in float i){float j=i*4.0;float x=mod(j,float(boneTextureSize));float y=floor(j/float(boneTextureSize));float dx=1.0/float(boneTextureSize);float dy=1.0/float(boneTextureSize);y=dy*(y+0.5);vec4 v1=texture2D(boneTexture,vec2(dx*(x+0.5),y));vec4 v2=texture2D(boneTexture,vec2(dx*(x+1.5),y));vec4 v3=texture2D(boneTexture,vec2(dx*(x+2.5),y));vec4 v4=texture2D(boneTexture,vec2(dx*(x+3.5),y));mat4 bone=mat4(v1,v2,v3,v4);return bone;}\n#else\nuniform mat4 boneMatrices[MAX_BONES];mat4 getBoneMatrix(const in float i){mat4 bone=boneMatrices[int(i)];return bone;}\n#endif\n#endif",
		skinning_vertex: "#ifdef USE_SKINNING\nvec4 skinVertex=bindMatrix*vec4(transformed,1.0);vec4 skinned=vec4(0.0);skinned+=boneMatX*skinVertex*skinWeight.x;skinned+=boneMatY*skinVertex*skinWeight.y;skinned+=boneMatZ*skinVertex*skinWeight.z;skinned+=boneMatW*skinVertex*skinWeight.w;transformed=(bindMatrixInverse*skinned).xyz;\n#endif",
		skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix=mat4(0.0);skinMatrix+=skinWeight.x*boneMatX;skinMatrix+=skinWeight.y*boneMatY;skinMatrix+=skinWeight.z*boneMatZ;skinMatrix+=skinWeight.w*boneMatW;skinMatrix=bindMatrixInverse*skinMatrix*bindMatrix;objectNormal=vec4(skinMatrix*vec4(objectNormal,0.0)).xyz;\n#ifdef USE_TANGENT\nobjectTangent=vec4(skinMatrix*vec4(objectTangent,0.0)).xyz;\n#endif\n#endif",
		specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular=texture2D(specularMap,vUv);specularStrength=texelSpecular.r;\n#else\nspecularStrength=1.0;\n#endif",
		specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
		tonemapping_fragment: "#if defined(TONE_MAPPING)\ngl_FragColor.rgb=toneMapping(gl_FragColor.rgb);\n#endif",
		tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a)clamp(a,0.0,1.0)\n#endif\nuniform float toneMappingExposure;vec3 LinearToneMapping(vec3 color){return toneMappingExposure*color;}vec3 ReinhardToneMapping(vec3 color){color*=toneMappingExposure;return saturate(color/(vec3(1.0)+color));}vec3 OptimizedCineonToneMapping(vec3 color){color*=toneMappingExposure;color=max(vec3(0.0),color-0.004);return pow((color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06),vec3(2.2));}vec3 RRTAndODTFit(vec3 v){vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}vec3 ACESFilmicToneMapping(vec3 color){const mat3 ACESInputMat=mat3(vec3(0.59719,0.07600,0.02840),vec3(0.35458,0.90834,0.13383),vec3(0.04823,0.01566,0.83777));const mat3 ACESOutputMat=mat3(vec3(1.60475,-0.10208,-0.00327),vec3(-0.53108,1.10813,-0.07276),vec3(-0.07367,-0.00605,1.07602));color*=toneMappingExposure/0.6;color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;return saturate(color);}vec3 CustomToneMapping(vec3 color){return color;}",
		transmission_fragment: "#ifdef USE_TRANSMISSION\nfloat transmissionAlpha=1.0;float transmissionFactor=transmission;float thicknessFactor=thickness;\n#ifdef USE_TRANSMISSIONMAP\ntransmissionFactor*=texture2D(transmissionMap,vUv).r;\n#endif\n#ifdef USE_THICKNESSMAP\nthicknessFactor*=texture2D(thicknessMap,vUv).g;\n#endif\nvec3 pos=vWorldPosition;vec3 v=normalize(cameraPosition-pos);vec3 n=inverseTransformDirection(normal,viewMatrix);vec4 transmission=getIBLVolumeRefraction(n,v,roughnessFactor,material.diffuseColor,material.specularColor,material.specularF90,pos,modelMatrix,viewMatrix,projectionMatrix,ior,thicknessFactor,attenuationTint,attenuationDistance);totalDiffuse=mix(totalDiffuse,transmission.rgb,transmissionFactor);transmissionAlpha=mix(transmissionAlpha,transmission.a,transmissionFactor);\n#endif",
		transmission_pars_fragment: "#ifdef USE_TRANSMISSION\nuniform float transmission;uniform float thickness;uniform float attenuationDistance;uniform vec3 attenuationTint;\n#ifdef USE_TRANSMISSIONMAP\nuniform sampler2D transmissionMap;\n#endif\n#ifdef USE_THICKNESSMAP\nuniform sampler2D thicknessMap;\n#endif\nuniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform mat4 modelMatrix;uniform mat4 projectionMatrix;varying vec3 vWorldPosition;vec3 getVolumeTransmissionRay(vec3 n,vec3 v,float thickness,float ior,mat4 modelMatrix){vec3 refractionVector=refract(-v,normalize(n),1.0/ior);vec3 modelScale;modelScale.x=length(vec3(modelMatrix[0].xyz));modelScale.y=length(vec3(modelMatrix[1].xyz));modelScale.z=length(vec3(modelMatrix[2].xyz));return normalize(refractionVector)*thickness*modelScale;}float applyIorToRoughness(float roughness,float ior){return roughness*clamp(ior*2.0-2.0,0.0,1.0);}vec4 getTransmissionSample(vec2 fragCoord,float roughness,float ior){float framebufferLod=log2(transmissionSamplerSize.x)*applyIorToRoughness(roughness,ior);\n#ifdef TEXTURE_LOD_EXT\nreturn texture2DLodEXT(transmissionSamplerMap,fragCoord.xy,framebufferLod);\n#else\nreturn texture2D(transmissionSamplerMap,fragCoord.xy,framebufferLod);\n#endif\n}vec3 applyVolumeAttenuation(vec3 radiance,float transmissionDistance,vec3 attenuationColor,float attenuationDistance){if(attenuationDistance==0.0){return radiance;}else{vec3 attenuationCoefficient=-log(attenuationColor)/attenuationDistance;vec3 transmittance=exp(-attenuationCoefficient*transmissionDistance);return transmittance*radiance;}}vec4 getIBLVolumeRefraction(vec3 n,vec3 v,float roughness,vec3 diffuseColor,vec3 specularColor,float specularF90,vec3 position,mat4 modelMatrix,mat4 viewMatrix,mat4 projMatrix,float ior,float thickness,vec3 attenuationColor,float attenuationDistance){vec3 transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix);vec3 refractedRayExit=position+transmissionRay;vec4 ndcPos=projMatrix*viewMatrix*vec4(refractedRayExit,1.0);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.0;refractionCoords/=2.0;vec4 transmittedLight=getTransmissionSample(refractionCoords,roughness,ior);vec3 attenuatedColor=applyVolumeAttenuation(transmittedLight.rgb,length(transmissionRay),attenuationColor,attenuationDistance);vec3 F=EnvironmentBRDF(n,v,specularColor,specularF90,roughness);return vec4((1.0-F)*attenuatedColor*diffuseColor,transmittedLight.a);}\n#endif",
		uv_pars_fragment: "#if (defined(USE_UV)&&!defined(UVS_VERTEX_ONLY))\nvarying vec2 vUv;\n#endif",
		uv_pars_vertex: "#ifdef USE_UV\n#ifdef UVS_VERTEX_ONLY\nvec2 vUv;\n#else\nvarying vec2 vUv;\n#endif\nuniform mat3 uvTransform;\n#endif",
		uv_vertex: "#ifdef USE_UV\nvUv=(uvTransform*vec3(uv,1)).xy;\n#endif",
		uv2_pars_fragment: "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvarying vec2 vUv2;\n#endif",
		uv2_pars_vertex: "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nattribute vec2 uv2;varying vec2 vUv2;uniform mat3 uv2Transform;\n#endif",
		uv2_vertex: "#if defined(USE_LIGHTMAP)||defined(USE_AOMAP)\nvUv2=(uv2Transform*vec3(uv2,1)).xy;\n#endif",
		worldpos_vertex: "#if defined(USE_ENVMAP)||defined(DISTANCE)||defined(USE_SHADOWMAP)||defined(USE_TRANSMISSION)\nvec4 worldPosition=vec4(transformed,1.0);\n#ifdef USE_INSTANCING\nworldPosition=instanceMatrix*worldPosition;\n#endif\nworldPosition=modelMatrix*worldPosition;\n#endif",
		background_vert: "varying vec2 vUv;uniform mat3 uvTransform;void main(){vUv=(uvTransform*vec3(uv,1)).xy;gl_Position=vec4(position.xy,1.0,1.0);}",
		background_frag: "uniform sampler2D t2D;varying vec2 vUv;void main(){vec4 texColor=texture2D(t2D,vUv);gl_FragColor=mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
		cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\ngl_Position.z=gl_Position.w;}",
		cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;varying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main(){vec3 vReflect=vWorldDirection;\n#include <envmap_fragment>\ngl_FragColor=envColor;gl_FragColor.a*=opacity;\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
		depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;void main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvHighPrecisionZW=gl_Position.zw;}",
		depth_frag: "#if DEPTH_PACKING==3200\nuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;void main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#if DEPTH_PACKING==3200\ndiffuseColor.a=opacity;\n#endif\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <logdepthbuf_fragment>\nfloat fragCoordZ=0.5*vHighPrecisionZW[0]/vHighPrecisionZW[1]+0.5;\n#if DEPTH_PACKING==3200\ngl_FragColor=vec4(vec3(1.0-fragCoordZ),opacity);\n#elif DEPTH_PACKING==3201\ngl_FragColor=packDepthToRGBA(fragCoordZ);\n#endif\n}",
		distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <skinbase_vertex>\n#ifdef USE_DISPLACEMENTMAP\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <clipping_planes_vertex>\nvWorldPosition=worldPosition.xyz;}",
		distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;uniform float nearDistance;uniform float farDistance;varying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(1.0);\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\nfloat dist=length(vWorldPosition-referencePosition);dist=(dist-nearDistance)/(farDistance-nearDistance);dist=saturate(dist);gl_FragColor=packDepthToRGBA(dist);}",
		equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vWorldDirection=transformDirection(position,modelMatrix);\n#include <begin_vertex>\n#include <project_vertex>\n}",
		equirect_frag: "uniform sampler2D tEquirect;varying vec3 vWorldDirection;\n#include <common>\nvoid main(){vec3 direction=normalize(vWorldDirection);vec2 sampleUV=equirectUv(direction);vec4 texColor=texture2D(tEquirect,sampleUV);gl_FragColor=mapTexelToLinear(texColor);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n}",
		linedashed_vert: "uniform float scale;attribute float lineDistance;varying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){vLineDistance=scale*lineDistance;\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
		linedashed_frag: "uniform vec3 diffuse;uniform float opacity;uniform float dashSize;uniform float totalSize;varying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nif(mod(vLineDistance,totalSize)>dashSize){discard;}vec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <color_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
		meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#if defined(USE_ENVMAP)||defined(USE_SKINNING)\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#endif\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <fog_vertex>\n}",
		meshbasic_frag: "uniform vec3 diffuse;uniform float opacity;\n#ifndef FLAT_SHADED\nvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\nReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#ifdef USE_LIGHTMAP\nvec4 lightMapTexel=texture2D(lightMap,vUv2);reflectedLight.indirectDiffuse+=lightMapTexelToLinear(lightMapTexel).rgb*lightMapIntensity;\n#else\nreflectedLight.indirectDiffuse+=vec3(1.0);\n#endif\n#include <aomap_fragment>\nreflectedLight.indirectDiffuse*=diffuseColor.rgb;vec3 outgoingLight=reflectedLight.indirectDiffuse;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;varying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <lights_lambert_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
		meshlambert_frag: "uniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;varying vec3 vLightFront;varying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <emissivemap_fragment>\n#ifdef DOUBLE_SIDED\nreflectedLight.indirectDiffuse+=(gl_FrontFacing)?vIndirectFront:vIndirectBack;\n#else\nreflectedLight.indirectDiffuse+=vIndirectFront;\n#endif\n#include <lightmap_fragment>\nreflectedLight.indirectDiffuse*=BRDF_Lambert(diffuseColor.rgb);\n#ifdef DOUBLE_SIDED\nreflectedLight.directDiffuse=(gl_FrontFacing)?vLightFront:vLightBack;\n#else\nreflectedLight.directDiffuse=vLightFront;\n#endif\nreflectedLight.directDiffuse*=BRDF_Lambert(diffuseColor.rgb)*getShadowMask();\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\nvViewPosition=-mvPosition.xyz;}",
		meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;uniform float opacity;uniform sampler2D matcap;varying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\nvec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 uv=vec2(dot(x,normal),dot(y,normal))*0.495+0.5;\n#ifdef USE_MATCAP\nvec4 matcapColor=texture2D(matcap,uv);matcapColor=matcapTexelToLinear(matcapColor);\n#else\nvec4 matcapColor=vec4(1.0);\n#endif\nvec3 outgoingLight=diffuseColor.rgb*matcapColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		meshnormal_vert: "#define NORMAL\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvViewPosition=-mvPosition.xyz;\n#endif\n}",
		meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined(FLAT_SHADED)||defined(USE_BUMPMAP)||defined(TANGENTSPACE_NORMALMAP)\nvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\n#include <logdepthbuf_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\ngl_FragColor=vec4(packNormalToRGB(normal),opacity);}",
		meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
		meshphong_frag: "#define PHONG\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <specularmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\nvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n#ifdef USE_TRANSMISSION\nvWorldPosition=worldPosition.xyz;\n#endif\n}",
		meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n#define IOR\n#define SPECULAR\n#endif\nuniform vec3 diffuse;uniform vec3 emissive;uniform float roughness;uniform float metalness;uniform float opacity;\n#ifdef IOR\nuniform float ior;\n#endif\n#ifdef SPECULAR\nuniform float specularIntensity;uniform vec3 specularTint;\n#ifdef USE_SPECULARINTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#ifdef USE_SPECULARTINTMAP\nuniform sampler2D specularTintMap;\n#endif\n#endif\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\nuniform vec3 sheenTint;uniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 totalDiffuse=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse;vec3 totalSpecular=reflectedLight.directSpecular+reflectedLight.indirectSpecular;\n#include <transmission_fragment>\nvec3 outgoingLight=totalDiffuse+totalSpecular+totalEmissiveRadiance;\n#ifdef USE_CLEARCOAT\nfloat dotNVcc=saturate(dot(geometry.clearcoatNormal,geometry.viewDir));vec3 Fcc=F_Schlick(material.clearcoatF0,material.clearcoatF90,dotNVcc);outgoingLight=outgoingLight*(1.0-clearcoat*Fcc)+clearcoatSpecular*clearcoat;\n#endif\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <uv2_vertex>\n#include <color_vertex>\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <displacementmap_vertex>\n#include <project_vertex>\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
		meshtoon_frag: "#define TOON\nuniform vec3 diffuse;uniform vec3 emissive;uniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <emissivemap_fragment>\n#include <lights_toon_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n#include <aomap_fragment>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+totalEmissiveRadiance;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",
		points_vert: "uniform float size;uniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <color_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <project_vertex>\ngl_PointSize=size;\n#ifdef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)gl_PointSize*=(scale/-mvPosition.z);\n#endif\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <worldpos_vertex>\n#include <fog_vertex>\n}",
		points_frag: "uniform vec3 diffuse;uniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_particle_fragment>\n#include <color_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n}",
		shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}",
		shadow_frag: "uniform vec3 color;uniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main(){gl_FragColor=vec4(color,opacity*(1.0-getShadowMask()));\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}",
		sprite_vert: "uniform float rotation;uniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main(){\n#include <uv_vertex>\nvec4 mvPosition=modelViewMatrix*vec4(0.0,0.0,0.0,1.0);vec2 scale;scale.x=length(vec3(modelMatrix[0].x,modelMatrix[0].y,modelMatrix[0].z));scale.y=length(vec3(modelMatrix[1].x,modelMatrix[1].y,modelMatrix[1].z));\n#ifndef USE_SIZEATTENUATION\nbool isPerspective=isPerspectiveMatrix(projectionMatrix);if(isPerspective)scale*=-mvPosition.z;\n#endif\nvec2 alignedPosition=(position.xy-(center-vec2(0.5)))*scale;vec2 rotatedPosition;rotatedPosition.x=cos(rotation)*alignedPosition.x-sin(rotation)*alignedPosition.y;rotatedPosition.y=sin(rotation)*alignedPosition.x+cos(rotation)*alignedPosition.y;mvPosition.xy+=rotatedPosition;gl_Position=projectionMatrix*mvPosition;\n#include <logdepthbuf_vertex>\n#include <clipping_planes_vertex>\n#include <fog_vertex>\n}",
		sprite_frag: "uniform vec3 diffuse;uniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main(){\n#include <clipping_planes_fragment>\nvec3 outgoingLight=vec3(0.0);vec4 diffuseColor=vec4(diffuse,opacity);\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\noutgoingLight=diffuseColor.rgb;\n#include <output_fragment>\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}"
	},
	cS = {
		common: {
			diffuse: {
				value: new aw(16777215)
			},
			opacity: {
				value: 1
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Ex
			},
			uv2Transform: {
				value: new Ex
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1
			},
			ior: {
				value: 1.5
			},
			refractionRatio: {
				value: .98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Cx(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 25e-5
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2e3
			},
			fogColor: {
				value: new aw(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new aw(16777215)
			},
			opacity: {
				value: 1
			},
			size: {
				value: 1
			},
			scale: {
				value: 1
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Ex
			}
		},
		sprite: {
			diffuse: {
				value: new aw(16777215)
			},
			opacity: {
				value: 1
			},
			center: {
				value: new Cx(.5, .5)
			},
			rotation: {
				value: 0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Ex
			}
		}
	},
	uS = {
		basic: {
			uniforms: Ww([cS.common, cS.specularmap, cS.envmap, cS.aomap, cS.lightmap, cS.fog]),
			vertexShader: lS.meshbasic_vert,
			fragmentShader: lS.meshbasic_frag
		},
		lambert: {
			uniforms: Ww([cS.common, cS.specularmap, cS.envmap, cS.aomap, cS.lightmap, cS.emissivemap, cS.fog, cS.lights, {
				emissive: {
					value: new aw(0)
				}
			}]),
			vertexShader: lS.meshlambert_vert,
			fragmentShader: lS.meshlambert_frag
		},
		phong: {
			uniforms: Ww([cS.common, cS.specularmap, cS.envmap, cS.aomap, cS.lightmap, cS.emissivemap, cS.bumpmap, cS.normalmap, cS.displacementmap, cS.fog, cS.lights, {
				emissive: {
					value: new aw(0)
				},
				specular: {
					value: new aw(1118481)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: lS.meshphong_vert,
			fragmentShader: lS.meshphong_frag
		},
		standard: {
			uniforms: Ww([cS.common, cS.envmap, cS.aomap, cS.lightmap, cS.emissivemap, cS.bumpmap, cS.normalmap, cS.displacementmap, cS.roughnessmap, cS.metalnessmap, cS.fog, cS.lights, {
				emissive: {
					value: new aw(0)
				},
				roughness: {
					value: 1
				},
				metalness: {
					value: 0
				},
				envMapIntensity: {
					value: 1
				}
			}]),
			vertexShader: lS.meshphysical_vert,
			fragmentShader: lS.meshphysical_frag
		},
		toon: {
			uniforms: Ww([cS.common, cS.aomap, cS.lightmap, cS.emissivemap, cS.bumpmap, cS.normalmap, cS.displacementmap, cS.gradientmap, cS.fog, cS.lights, {
				emissive: {
					value: new aw(0)
				}
			}]),
			vertexShader: lS.meshtoon_vert,
			fragmentShader: lS.meshtoon_frag
		},
		matcap: {
			uniforms: Ww([cS.common, cS.bumpmap, cS.normalmap, cS.displacementmap, cS.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: lS.meshmatcap_vert,
			fragmentShader: lS.meshmatcap_frag
		},
		points: {
			uniforms: Ww([cS.points, cS.fog]),
			vertexShader: lS.points_vert,
			fragmentShader: lS.points_frag
		},
		dashed: {
			uniforms: Ww([cS.common, cS.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: lS.linedashed_vert,
			fragmentShader: lS.linedashed_frag
		},
		depth: {
			uniforms: Ww([cS.common, cS.displacementmap]),
			vertexShader: lS.depth_vert,
			fragmentShader: lS.depth_frag
		},
		normal: {
			uniforms: Ww([cS.common, cS.bumpmap, cS.normalmap, cS.displacementmap, {
				opacity: {
					value: 1
				}
			}]),
			vertexShader: lS.meshnormal_vert,
			fragmentShader: lS.meshnormal_frag
		},
		sprite: {
			uniforms: Ww([cS.sprite, cS.fog]),
			vertexShader: lS.sprite_vert,
			fragmentShader: lS.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Ex
				},
				t2D: {
					value: null
				}
			},
			vertexShader: lS.background_vert,
			fragmentShader: lS.background_frag
		},
		cube: {
			uniforms: Ww([cS.envmap, {
				opacity: {
					value: 1
				}
			}]),
			vertexShader: lS.cube_vert,
			fragmentShader: lS.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: lS.equirect_vert,
			fragmentShader: lS.equirect_frag
		},
		distanceRGBA: {
			uniforms: Ww([cS.common, cS.displacementmap, {
				referencePosition: {
					value: new zx
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1e3
				}
			}]),
			vertexShader: lS.distanceRGBA_vert,
			fragmentShader: lS.distanceRGBA_frag
		},
		shadow: {
			uniforms: Ww([cS.lights, cS.fog, {
				color: {
					value: new aw(0)
				},
				opacity: {
					value: 1
				}
			}]),
			vertexShader: lS.shadow_vert,
			fragmentShader: lS.shadow_frag
		}
	};

function hS(e, t, n, i, r) {
	const s = new aw(0);
	let a, o, l = 0,
		c = null,
		u = 0,
		h = null;

	function d(e, t) {
		n.buffers.color.setClear(e.r, e.g, e.b, t, r)
	}
	return {
		getClearColor: function() {
			return s
		},
		setClearColor: function(e, t = 1) {
			s.set(e), l = t, d(s, l)
		},
		getClearAlpha: function() {
			return l
		},
		setClearAlpha: function(e) {
			l = e, d(s, l)
		},
		render: function(n, r) {
			let p = !1,
				f = !0 === r.isScene ? r.background : null;
			f && f.isTexture && (f = t.get(f));
			const m = e.xr,
				g = m.getSession && m.getSession();
			g && "additive" === g.environmentBlendMode && (f = null), null === f ? d(s, l) : f && f.isColor && (d(f, 1), p = !0), (e.autoClear || p) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || 306 === f.mapping) ? (void 0 === o && (o = new Bw(new Hw(1, 1, 1), new jw({
				name: "BackgroundCubeMaterial",
				uniforms: Gw(uS.cube.uniforms),
				vertexShader: uS.cube.vertexShader,
				fragmentShader: uS.cube.fragmentShader,
				side: 1,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), o.geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function(e, t, n) {
				this.matrixWorld.copyPosition(n.matrixWorld)
			}, Object.defineProperty(o.material, "envMap", {
				get: function() {
					return this.uniforms.envMap.value
				}
			}), i.update(o)), o.material.uniforms.envMap.value = f, o.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, c === f && u === f.version && h === e.toneMapping || (o.material.needsUpdate = !0, c = f, u = f.version, h = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : f && f.isTexture && (void 0 === a && (a = new Bw(new oS(2, 2), new jw({
				name: "BackgroundMaterial",
				uniforms: Gw(uS.background.uniforms),
				vertexShader: uS.background.vertexShader,
				fragmentShader: uS.background.fragmentShader,
				side: 0,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", {
				get: function() {
					return this.uniforms.t2D.value
				}
			}), i.update(a)), a.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), a.material.uniforms.uvTransform.value.copy(f.matrix), c === f && u === f.version && h === e.toneMapping || (a.material.needsUpdate = !0, c = f, u = f.version, h = e.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null))
		}
	}
}

function dS(e, t, n, i) {
	const r = e.getParameter(34921),
		s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
		a = i.isWebGL2 || null !== s,
		o = {},
		l = d(null);
	let c = l;

	function u(t) {
		return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
	}

	function h(t) {
		return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
	}

	function d(e) {
		const t = [],
			n = [],
			i = [];
		for (let s = 0; s < r; s++) t[s] = 0, n[s] = 0, i[s] = 0;
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: t,
			enabledAttributes: n,
			attributeDivisors: i,
			object: e,
			attributes: {},
			index: null
		}
	}

	function p() {
		const e = c.newAttributes;
		for (let t = 0, n = e.length; t < n; t++) e[t] = 0
	}

	function f(e) {
		m(e, 0)
	}

	function m(n, r) {
		const s = c.newAttributes,
			a = c.enabledAttributes,
			o = c.attributeDivisors;
		if (s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) {
			(i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r
		}
	}

	function g() {
		const t = c.newAttributes,
			n = c.enabledAttributes;
		for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
	}

	function v(t, n, r, s, a, o) {
		!0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, a, o) : e.vertexAttribIPointer(t, n, r, a, o)
	}

	function _() {
		y(), c !== l && (c = l, u(c.object))
	}

	function y() {
		l.geometry = null, l.program = null, l.wireframe = !1
	}
	return {
		setup: function(r, l, h, _, y) {
			let x = !1;
			if (a) {
				const t = function(t, n, r) {
					const a = !0 === r.wireframe;
					let l = o[t.id];
					void 0 === l && (l = {}, o[t.id] = l);
					let c = l[n.id];
					void 0 === c && (c = {}, l[n.id] = c);
					let u = c[a];
					void 0 === u && (u = d(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = u);
					return u
				}(_, h, l);
				c !== t && (c = t, u(c.object)), x = function(e, t) {
					const n = c.attributes,
						i = e.attributes;
					let r = 0;
					for (const s in i) {
						const e = n[s],
							t = i[s];
						if (void 0 === e) return !0;
						if (e.attribute !== t) return !0;
						if (e.data !== t.data) return !0;
						r++
					}
					return c.attributesNum !== r || c.index !== t
				}(_, y), x && function(e, t) {
					const n = {},
						i = e.attributes;
					let r = 0;
					for (const s in i) {
						const e = i[s],
							t = {};
						t.attribute = e, e.data && (t.data = e.data), n[s] = t, r++
					}
					c.attributes = n, c.attributesNum = r, c.index = t
				}(_, y)
			} else {
				const e = !0 === l.wireframe;
				c.geometry === _.id && c.program === h.id && c.wireframe === e || (c.geometry = _.id, c.program = h.id, c.wireframe = e, x = !0)
			}!0 === r.isInstancedMesh && (x = !0), null !== y && n.update(y, 34963), x && (! function(r, s, a, o) {
				if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
				p();
				const l = o.attributes,
					c = a.getAttributes(),
					u = s.defaultAttributeValues;
				for (const t in c) {
					const i = c[t];
					if (i.location >= 0) {
						let s = l[t];
						if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (s = r.instanceColor)), void 0 !== s) {
							const t = s.normalized,
								a = s.itemSize,
								l = n.get(s);
							if (void 0 === l) continue;
							const c = l.buffer,
								u = l.type,
								h = l.bytesPerElement;
							if (s.isInterleavedBufferAttribute) {
								const n = s.data,
									l = n.stride,
									d = s.offset;
								if (n && n.isInstancedInterleavedBuffer) {
									for (let e = 0; e < i.locationSize; e++) m(i.location + e, n.meshPerAttribute);
									!0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
								} else
									for (let e = 0; e < i.locationSize; e++) f(i.location + e);
								e.bindBuffer(34962, c);
								for (let e = 0; e < i.locationSize; e++) v(i.location + e, a / i.locationSize, u, t, l * h, (d + a / i.locationSize * e) * h)
							} else {
								if (s.isInstancedBufferAttribute) {
									for (let e = 0; e < i.locationSize; e++) m(i.location + e, s.meshPerAttribute);
									!0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
								} else
									for (let e = 0; e < i.locationSize; e++) f(i.location + e);
								e.bindBuffer(34962, c);
								for (let e = 0; e < i.locationSize; e++) v(i.location + e, a / i.locationSize, u, t, a * h, a / i.locationSize * e * h)
							}
						} else if (void 0 !== u) {
							const n = u[t];
							if (void 0 !== n) switch (n.length) {
								case 2:
									e.vertexAttrib2fv(i.location, n);
									break;
								case 3:
									e.vertexAttrib3fv(i.location, n);
									break;
								case 4:
									e.vertexAttrib4fv(i.location, n);
									break;
								default:
									e.vertexAttrib1fv(i.location, n)
							}
						}
					}
				}
				g()
			}(r, l, h, _), null !== y && e.bindBuffer(34963, n.get(y).buffer))
		},
		reset: _,
		resetDefaultState: y,
		dispose: function() {
			_();
			for (const e in o) {
				const t = o[e];
				for (const e in t) {
					const n = t[e];
					for (const e in n) h(n[e].object), delete n[e];
					delete t[e]
				}
				delete o[e]
			}
		},
		releaseStatesOfGeometry: function(e) {
			if (void 0 === o[e.id]) return;
			const t = o[e.id];
			for (const n in t) {
				const e = t[n];
				for (const t in e) h(e[t].object), delete e[t];
				delete t[n]
			}
			delete o[e.id]
		},
		releaseStatesOfProgram: function(e) {
			for (const t in o) {
				const n = o[t];
				if (void 0 === n[e.id]) continue;
				const i = n[e.id];
				for (const e in i) h(i[e].object), delete i[e];
				delete n[e.id]
			}
		},
		initAttributes: p,
		enableAttribute: f,
		disableUnusedAttributes: g
	}
}

function pS(e, t, n, i) {
	const r = i.isWebGL2;
	let s;
	this.setMode = function(e) {
		s = e
	}, this.render = function(t, i) {
		e.drawArrays(s, t, i), n.update(i, s, 1)
	}, this.renderInstances = function(i, a, o) {
		if (0 === o) return;
		let l, c;
		if (r) l = e, c = "drawArraysInstanced";
		else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return;
		l[c](s, i, a, o), n.update(a, s, o)
	}
}

function fS(e, t, n) {
	let i;

	function r(t) {
		if ("highp" === t) {
			if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
			t = "mediump"
		}
		return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
	}
	const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
	let a = void 0 !== n.precision ? n.precision : "highp";
	const o = r(a);
	o !== a && (a = o);
	const l = s || t.has("WEBGL_draw_buffers"),
		c = !0 === n.logarithmicDepthBuffer,
		u = e.getParameter(34930),
		h = e.getParameter(35660),
		d = e.getParameter(3379),
		p = e.getParameter(34076),
		f = e.getParameter(34921),
		m = e.getParameter(36347),
		g = e.getParameter(36348),
		v = e.getParameter(36349),
		_ = h > 0,
		y = s || t.has("OES_texture_float");
	return {
		isWebGL2: s,
		drawBuffers: l,
		getMaxAnisotropy: function() {
			if (void 0 !== i) return i;
			if (!0 === t.has("EXT_texture_filter_anisotropic")) {
				const n = t.get("EXT_texture_filter_anisotropic");
				i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
			} else i = 0;
			return i
		},
		getMaxPrecision: r,
		precision: a,
		logarithmicDepthBuffer: c,
		maxTextures: u,
		maxVertexTextures: h,
		maxTextureSize: d,
		maxCubemapSize: p,
		maxAttributes: f,
		maxVertexUniforms: m,
		maxVaryings: g,
		maxFragmentUniforms: v,
		vertexTextures: _,
		floatFragmentTextures: y,
		floatVertexTextures: _ && y,
		maxSamples: s ? e.getParameter(36183) : 0
	}
}

function mS(e) {
	const t = this;
	let n = null,
		i = 0,
		r = !1,
		s = !1;
	const a = new tS,
		o = new Ex,
		l = {
			value: null,
			needsUpdate: !1
		};

	function c() {
		l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
	}

	function u(e, n, i, r) {
		const s = null !== e ? e.length : 0;
		let c = null;
		if (0 !== s) {
			if (c = l.value, !0 !== r || null === c) {
				const t = i + 4 * s,
					r = n.matrixWorldInverse;
				o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
				for (let n = 0, l = i; n !== s; ++n, l += 4) a.copy(e[n]).applyMatrix4(r, o), a.normal.toArray(c, l), c[l + 3] = a.constant
			}
			l.value = c, l.needsUpdate = !0
		}
		return t.numPlanes = s, t.numIntersection = 0, c
	}
	this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, s) {
		const a = 0 !== e.length || t || 0 !== i || r;
		return r = t, n = u(e, s, 0), i = e.length, a
	}, this.beginShadows = function() {
		s = !0, u(null)
	}, this.endShadows = function() {
		s = !1, c()
	}, this.setState = function(t, a, o) {
		const h = t.clippingPlanes,
			d = t.clipIntersection,
			p = t.clipShadows,
			f = e.get(t);
		if (!r || null === h || 0 === h.length || s && !p) s ? u(null) : c();
		else {
			const e = s ? 0 : i,
				t = 4 * e;
			let r = f.clippingState || null;
			l.value = r, r = u(h, a, t, o);
			for (let i = 0; i !== t; ++i) r[i] = n[i];
			f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
		}
	}
}

function gS(e) {
	let t = new WeakMap;

	function n(e, t) {
		return 303 === t ? e.mapping = 301 : 304 === t && (e.mapping = 302), e
	}

	function i(e) {
		const n = e.target;
		n.removeEventListener("dispose", i);
		const r = t.get(n);
		void 0 !== r && (t.delete(n), r.dispose())
	}
	return {
		get: function(r) {
			if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
				const s = r.mapping;
				if (303 === s || 304 === s) {
					if (t.has(r)) {
						return n(t.get(r).texture, r.mapping)
					} {
						const s = r.image;
						if (s && s.height > 0) {
							const a = e.getRenderTarget(),
								o = new Kw(s.height / 2);
							return o.fromEquirectangularTexture(e, r), t.set(r, o), e.setRenderTarget(a), r.addEventListener("dispose", i), n(o.texture, r.mapping)
						}
						return null
					}
				}
			}
			return r
		},
		dispose: function() {
			t = new WeakMap
		}
	}
}
uS.physical = {
	uniforms: Ww([uS.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatNormalScale: {
			value: new Cx(1, 1)
		},
		clearcoatNormalMap: {
			value: null
		},
		sheen: {
			value: 0
		},
		sheenTint: {
			value: new aw(0)
		},
		sheenRoughness: {
			value: 0
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionSamplerSize: {
			value: new Cx
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		attenuationDistance: {
			value: 0
		},
		attenuationTint: {
			value: new aw(0)
		},
		specularIntensity: {
			value: 0
		},
		specularIntensityMap: {
			value: null
		},
		specularTint: {
			value: new aw(1, 1, 1)
		},
		specularTintMap: {
			value: null
		}
	}]),
	vertexShader: lS.meshphysical_vert,
	fragmentShader: lS.meshphysical_frag
};
class vS extends Yw {
	constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) {
		super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
	}
	copy(e, t) {
		return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
	}
	setViewOffset(e, t, n, i, r, s) {
		null === this.view && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		const e = (this.right - this.left) / (2 * this.zoom),
			t = (this.top - this.bottom) / (2 * this.zoom),
			n = (this.right + this.left) / 2,
			i = (this.top + this.bottom) / 2;
		let r = n - e,
			s = n + e,
			a = i + t,
			o = i - t;
		if (null !== this.view && this.view.enabled) {
			const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
				t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height
		}
		this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
	}
}
vS.prototype.isOrthographicCamera = !0;
class _S extends jw {
	constructor(e) {
		super(e), this.type = "RawShaderMaterial"
	}
}
_S.prototype.isRawShaderMaterial = !0;
const yS = Math.pow(2, 8),
	xS = [.125, .215, .35, .446, .526, .582],
	bS = 5 + xS.length,
	wS = {
		3e3: 0,
		3001: 1,
		3002: 2,
		3004: 3,
		3005: 4,
		3006: 5,
		3007: 6
	},
	SS = new vS,
	{
		_lodPlanes: MS,
		_sizeLods: TS,
		_sigmas: CS
	} = kS(),
	ES = new aw;
let AS = null;
const PS = (1 + Math.sqrt(5)) / 2,
	LS = 1 / PS,
	IS = [new zx(1, 1, 1), new zx(-1, 1, 1), new zx(1, 1, -1), new zx(-1, 1, -1), new zx(0, PS, LS), new zx(0, PS, -LS), new zx(LS, 0, PS), new zx(-LS, 0, PS), new zx(PS, LS, 0), new zx(-PS, LS, 0)];
class DS {
	constructor(e) {
		this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function(e) {
			const t = new Float32Array(e),
				n = new zx(0, 1, 0);
			return new _S({
				name: "SphericalGaussianBlur",
				defines: {
					n: e
				},
				uniforms: {
					envMap: {
						value: null
					},
					samples: {
						value: 1
					},
					weights: {
						value: t
					},
					latitudinal: {
						value: !1
					},
					dTheta: {
						value: 0
					},
					mipInt: {
						value: 0
					},
					poleAxis: {
						value: n
					},
					inputEncoding: {
						value: wS[3e3]
					},
					outputEncoding: {
						value: wS[3e3]
					}
				},
				vertexShader: US(),
				fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform int samples;uniform float weights[n];uniform bool latitudinal;uniform float dTheta;uniform float mipInt;uniform vec3 poleAxis;\n${BS()}\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\nvec3 getSample(float theta,vec3 axis){float cosTheta=cos(theta);vec3 sampleDirection=vOutputDirection*cosTheta+cross(axis,vOutputDirection)*sin(theta)+axis*dot(axis,vOutputDirection)*(1.0-cosTheta);return bilinearCubeUV(envMap,sampleDirection,mipInt);}void main(){vec3 axis=latitudinal?poleAxis:cross(poleAxis,vOutputDirection);if(all(equal(axis,vec3(0.0)))){axis=vec3(vOutputDirection.z,0.0,-vOutputDirection.x);}axis=normalize(axis);gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb+=weights[0]*getSample(0.0,axis);for(int i=1;i<n;i++){if(i>=samples){break;}float theta=dTheta*float(i);gl_FragColor.rgb+=weights[i]*getSample(-1.0*theta,axis);gl_FragColor.rgb+=weights[i]*getSample(theta,axis);}gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
				blending: 0,
				depthTest: !1,
				depthWrite: !1
			})
		}(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
	}
	fromScene(e, t = 0, n = .1, i = 100) {
		AS = this._renderer.getRenderTarget();
		const r = this._allocateTargets();
		return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
	}
	fromEquirectangular(e) {
		return this._fromTexture(e)
	}
	fromCubemap(e) {
		return this._fromTexture(e)
	}
	compileCubemapShader() {
		null === this._cubemapShader && (this._cubemapShader = zS(), this._compileMaterial(this._cubemapShader))
	}
	compileEquirectangularShader() {
		null === this._equirectShader && (this._equirectShader = FS(), this._compileMaterial(this._equirectShader))
	}
	dispose() {
		this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
		for (let e = 0; e < MS.length; e++) MS[e].dispose()
	}
	_cleanup(e) {
		this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(AS), e.scissorTest = !1, OS(e, 0, 0, e.width, e.height)
	}
	_fromTexture(e) {
		AS = this._renderer.getRenderTarget();
		const t = this._allocateTargets(e);
		return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
	}
	_allocateTargets(e) {
		const t = {
				magFilter: 1003,
				minFilter: 1003,
				generateMipmaps: !1,
				type: 1009,
				format: 1023,
				encoding: RS(e) ? e.encoding : 3002,
				depthBuffer: !1
			},
			n = NS(t);
		return n.depthBuffer = !e, this._pingPongRenderTarget = NS(t), n
	}
	_compileMaterial(e) {
		const t = new Bw(MS[0], e);
		this._renderer.compile(t, SS)
	}
	_sceneToCubeUV(e, t, n, i) {
		const r = new Xw(90, 1, t, n),
			s = [1, -1, 1, 1, 1, 1],
			a = [1, 1, 1, -1, -1, -1],
			o = this._renderer,
			l = o.autoClear,
			c = o.outputEncoding,
			u = o.toneMapping;
		o.getClearColor(ES), o.toneMapping = 0, o.outputEncoding = 3e3, o.autoClear = !1;
		const h = new ow({
				name: "PMREM.Background",
				side: 1,
				depthWrite: !1,
				depthTest: !1
			}),
			d = new Bw(new Hw, h);
		let p = !1;
		const f = e.background;
		f ? f.isColor && (h.color.copy(f), e.background = null, p = !0) : (h.color.copy(ES), p = !0);
		for (let m = 0; m < 6; m++) {
			const t = m % 3;
			0 == t ? (r.up.set(0, s[m], 0), r.lookAt(a[m], 0, 0)) : 1 == t ? (r.up.set(0, 0, s[m]), r.lookAt(0, a[m], 0)) : (r.up.set(0, s[m], 0), r.lookAt(0, 0, a[m])), OS(i, t * yS, m > 2 ? yS : 0, yS, yS), o.setRenderTarget(i), p && o.render(d, r), o.render(e, r)
		}
		d.geometry.dispose(), d.material.dispose(), o.toneMapping = u, o.outputEncoding = c, o.autoClear = l, e.background = f
	}
	_setEncoding(e, t) {
		!0 === this._renderer.capabilities.isWebGL2 && 1023 === t.format && 1009 === t.type && 3001 === t.encoding ? e.value = wS[3e3] : e.value = wS[t.encoding]
	}
	_textureToCubeUV(e, t) {
		const n = this._renderer;
		e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = zS()) : null == this._equirectShader && (this._equirectShader = FS());
		const i = e.isCubeTexture ? this._cubemapShader : this._equirectShader,
			r = new Bw(MS[0], i),
			s = i.uniforms;
		s.envMap.value = e, e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(s.inputEncoding, e), this._setEncoding(s.outputEncoding, t.texture), OS(t, 0, 0, 3 * yS, 2 * yS), n.setRenderTarget(t), n.render(r, SS)
	}
	_applyPMREM(e) {
		const t = this._renderer,
			n = t.autoClear;
		t.autoClear = !1;
		for (let i = 1; i < bS; i++) {
			const t = Math.sqrt(CS[i] * CS[i] - CS[i - 1] * CS[i - 1]),
				n = IS[(i - 1) % IS.length];
			this._blur(e, i - 1, i, t, n)
		}
		t.autoClear = n
	}
	_blur(e, t, n, i, r) {
		const s = this._pingPongRenderTarget;
		this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r)
	}
	_halfBlur(e, t, n, i, r, s, a) {
		const o = this._renderer,
			l = this._blurMaterial,
			c = new Bw(MS[i], l),
			u = l.uniforms,
			h = TS[n] - 1,
			d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
			p = r / d,
			f = isFinite(r) ? 1 + Math.floor(3 * p) : 20,
			m = [];
		let g = 0;
		for (let _ = 0; _ < 20; ++_) {
			const e = _ / p,
				t = Math.exp(-e * e / 2);
			m.push(t), 0 == _ ? g += t : _ < f && (g += 2 * t)
		}
		for (let _ = 0; _ < m.length; _++) m[_] = m[_] / g;
		u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, a && (u.poleAxis.value = a), u.dTheta.value = d, u.mipInt.value = 8 - n, this._setEncoding(u.inputEncoding, e.texture), this._setEncoding(u.outputEncoding, e.texture);
		const v = TS[i];
		OS(t, 3 * Math.max(0, yS - 2 * v), (0 === i ? 0 : 2 * yS) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, SS)
	}
}

function RS(e) {
	return void 0 !== e && 1009 === e.type && (3e3 === e.encoding || 3001 === e.encoding || 3007 === e.encoding)
}

function kS() {
	const e = [],
		t = [],
		n = [];
	let i = 8;
	for (let r = 0; r < bS; r++) {
		const s = Math.pow(2, i);
		t.push(s);
		let a = 1 / s;
		r > 4 ? a = xS[r - 8 + 4 - 1] : 0 == r && (a = 0), n.push(a);
		const o = 1 / (s - 1),
			l = -o / 2,
			c = 1 + o / 2,
			u = [l, l, c, l, c, c, l, l, c, c, l, c],
			h = 6,
			d = 6,
			p = 3,
			f = 2,
			m = 1,
			g = new Float32Array(p * d * h),
			v = new Float32Array(f * d * h),
			_ = new Float32Array(m * d * h);
		for (let e = 0; e < h; e++) {
			const t = e % 3 * 2 / 3 - 1,
				n = e > 2 ? 0 : -1,
				i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
			g.set(i, p * d * e), v.set(u, f * d * e);
			const r = [e, e, e, e, e, e];
			_.set(r, m * d * e)
		}
		const y = new ww;
		y.setAttribute("position", new uw(g, p)), y.setAttribute("uv", new uw(v, f)), y.setAttribute("faceIndex", new uw(_, m)), e.push(y), i > 4 && i--
	}
	return {
		_lodPlanes: e,
		_sizeLods: t,
		_sigmas: n
	}
}

function NS(e) {
	const t = new Nx(3 * yS, 3 * yS, e);
	return t.texture.mapping = 306, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t
}

function OS(e, t, n, i, r) {
	e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
}

function FS() {
	const e = new Cx(1, 1);
	return new _S({
		name: "EquirectangularToCubeUV",
		uniforms: {
			envMap: {
				value: null
			},
			texelSize: {
				value: e
			},
			inputEncoding: {
				value: wS[3e3]
			},
			outputEncoding: {
				value: wS[3e3]
			}
		},
		vertexShader: US(),
		fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform sampler2D envMap;uniform vec2 texelSize;\n${BS()}\n#include <common>\nvoid main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);vec3 outputDirection=normalize(vOutputDirection);vec2 uv=equirectUv(outputDirection);vec2 f=fract(uv/texelSize-0.5);uv-=f*texelSize;vec3 tl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x+=texelSize.x;vec3 tr=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.y+=texelSize.y;vec3 br=envMapTexelToLinear(texture2D(envMap,uv)).rgb;uv.x-=texelSize.x;vec3 bl=envMapTexelToLinear(texture2D(envMap,uv)).rgb;vec3 tm=mix(tl,tr,f.x);vec3 bm=mix(bl,br,f.x);gl_FragColor.rgb=mix(tm,bm,f.y);gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
		blending: 0,
		depthTest: !1,
		depthWrite: !1
	})
}

function zS() {
	return new _S({
		name: "CubemapToCubeUV",
		uniforms: {
			envMap: {
				value: null
			},
			inputEncoding: {
				value: wS[3e3]
			},
			outputEncoding: {
				value: wS[3e3]
			}
		},
		vertexShader: US(),
		fragmentShader: `precision mediump float;precision mediump int;varying vec3 vOutputDirection;uniform samplerCube envMap;\n${BS()}\nvoid main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);gl_FragColor.rgb=envMapTexelToLinear(textureCube(envMap,vec3(-vOutputDirection.x,vOutputDirection.yz))).rgb;gl_FragColor=linearToOutputTexel(gl_FragColor);}`,
		blending: 0,
		depthTest: !1,
		depthWrite: !1
	})
}

function US() {
	return "precision mediump float;precision mediump int;attribute vec3 position;attribute vec2 uv;attribute float faceIndex;varying vec3 vOutputDirection;vec3 getDirection(vec2 uv,float face){uv=2.0*uv-1.0;vec3 direction=vec3(uv,1.0);if(face==0.0){direction=direction.zyx;}else if(face==1.0){direction=direction.xzy;direction.xz*=-1.0;}else if(face==2.0){direction.x*=-1.0;}else if(face==3.0){direction=direction.zyx;direction.xz*=-1.0;}else if(face==4.0){direction=direction.xzy;direction.xy*=-1.0;}else if(face==5.0){direction.z*=-1.0;}return direction;}void main(){vOutputDirection=getDirection(uv,faceIndex);gl_Position=vec4(position,1.0);}"
}

function BS() {
	return "uniform int inputEncoding;uniform int outputEncoding;\n#include <encodings_pars_fragment>\nvec4 inputTexelToLinear(vec4 value){if(inputEncoding==0){return value;}else if(inputEncoding==1){return sRGBToLinear(value);}else if(inputEncoding==2){return RGBEToLinear(value);}else if(inputEncoding==3){return RGBMToLinear(value,7.0);}else if(inputEncoding==4){return RGBMToLinear(value,16.0);}else if(inputEncoding==5){return RGBDToLinear(value,256.0);}else{return GammaToLinear(value,2.2);}}vec4 linearToOutputTexel(vec4 value){if(outputEncoding==0){return value;}else if(outputEncoding==1){return LinearTosRGB(value);}else if(outputEncoding==2){return LinearToRGBE(value);}else if(outputEncoding==3){return LinearToRGBM(value,7.0);}else if(outputEncoding==4){return LinearToRGBM(value,16.0);}else if(outputEncoding==5){return LinearToRGBD(value,256.0);}else{return LinearToGamma(value,2.2);}}vec4 envMapTexelToLinear(vec4 color){return inputTexelToLinear(color);}"
}

function VS(e) {
	let t = new WeakMap,
		n = null;

	function i(e) {
		const n = e.target;
		n.removeEventListener("dispose", i);
		const r = t.get(n);
		void 0 !== r && (t.delete(n), r.dispose())
	}
	return {
		get: function(r) {
			if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
				const s = r.mapping,
					a = 303 === s || 304 === s,
					o = 301 === s || 302 === s;
				if (a || o) {
					if (t.has(r)) return t.get(r).texture; {
						const s = r.image;
						if (a && s && s.height > 0 || o && s && function(e) {
								let t = 0;
								const n = 6;
								for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
								return t === n
							}(s)) {
							const s = e.getRenderTarget();
							null === n && (n = new DS(e));
							const o = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
							return t.set(r, o), e.setRenderTarget(s), r.addEventListener("dispose", i), o.texture
						}
						return null
					}
				}
			}
			return r
		},
		dispose: function() {
			t = new WeakMap, null !== n && (n.dispose(), n = null)
		}
	}
}

function HS(e) {
	const t = {};

	function n(n) {
		if (void 0 !== t[n]) return t[n];
		let i;
		switch (n) {
			case "WEBGL_depth_texture":
				i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
				break;
			case "EXT_texture_filter_anisotropic":
				i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				break;
			case "WEBGL_compressed_texture_s3tc":
				i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
				break;
			case "WEBGL_compressed_texture_pvrtc":
				i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
				break;
			default:
				i = e.getExtension(n)
		}
		return t[n] = i, i
	}
	return {
		has: function(e) {
			return null !== n(e)
		},
		init: function(e) {
			e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("EXT_multisampled_render_to_texture")
		},
		get: function(e) {
			const t = n(e);
			return t
		}
	}
}

function GS(e, t, n, i) {
	const r = {},
		s = new WeakMap;

	function a(e) {
		const o = e.target;
		null !== o.index && t.remove(o.index);
		for (const n in o.attributes) t.remove(o.attributes[n]);
		o.removeEventListener("dispose", a), delete r[o.id];
		const l = s.get(o);
		l && (t.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
	}

	function o(e) {
		const n = [],
			i = e.index,
			r = e.attributes.position;
		let a = 0;
		if (null !== i) {
			const e = i.array;
			a = i.version;
			for (let t = 0, i = e.length; t < i; t += 3) {
				const i = e[t + 0],
					r = e[t + 1],
					s = e[t + 2];
				n.push(i, r, r, s, s, i)
			}
		} else {
			const e = r.array;
			a = r.version;
			for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
				const e = t + 0,
					i = t + 1,
					r = t + 2;
				n.push(e, i, i, r, r, e)
			}
		}
		const o = new(Ax(n) > 65535 ? pw : dw)(n, 1);
		o.version = a;
		const l = s.get(e);
		l && t.remove(l), s.set(e, o)
	}
	return {
		get: function(e, t) {
			return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, n.memory.geometries++), t
		},
		update: function(e) {
			const n = e.attributes;
			for (const r in n) t.update(n[r], 34962);
			const i = e.morphAttributes;
			for (const r in i) {
				const e = i[r];
				for (let n = 0, i = e.length; n < i; n++) t.update(e[n], 34962)
			}
		},
		getWireframeAttribute: function(e) {
			const t = s.get(e);
			if (t) {
				const n = e.index;
				null !== n && t.version < n.version && o(e)
			} else o(e);
			return s.get(e)
		}
	}
}

function WS(e, t, n, i) {
	const r = i.isWebGL2;
	let s, a, o;
	this.setMode = function(e) {
		s = e
	}, this.setIndex = function(e) {
		a = e.type, o = e.bytesPerElement
	}, this.render = function(t, i) {
		e.drawElements(s, i, a, t * o), n.update(i, s, 1)
	}, this.renderInstances = function(i, l, c) {
		if (0 === c) return;
		let u, h;
		if (r) u = e, h = "drawElementsInstanced";
		else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return;
		u[h](s, l, a, i * o, c), n.update(l, s, c)
	}
}

function qS(e) {
	const t = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};
	return {
		memory: {
			geometries: 0,
			textures: 0
		},
		render: t,
		programs: null,
		autoReset: !0,
		reset: function() {
			t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
		},
		update: function(e, n, i) {
			switch (t.calls++, n) {
				case 4:
					t.triangles += i * (e / 3);
					break;
				case 1:
					t.lines += i * (e / 2);
					break;
				case 3:
					t.lines += i * (e - 1);
					break;
				case 2:
					t.lines += i * e;
					break;
				case 0:
					t.points += i * e
			}
		}
	}
}
class jS extends Dx {
	constructor(e = null, t = 1, n = 1, i = 1) {
		super(null), this.image = {
			data: e,
			width: t,
			height: n,
			depth: i
		}, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
	}
}

function YS(e, t) {
	return e[0] - t[0]
}

function XS(e, t) {
	return Math.abs(t[1]) - Math.abs(e[1])
}

function $S(e, t) {
	let n = 1;
	const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
	i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array && (n = 2147483647), e.divideScalar(n)
}

function ZS(e, t, n) {
	const i = {},
		r = new Float32Array(8),
		s = new WeakMap,
		a = new zx,
		o = [];
	for (let l = 0; l < 8; l++) o[l] = [l, 0];
	return {
		update: function(l, c, u, h) {
			const d = l.morphTargetInfluences;
			if (!0 === t.isWebGL2) {
				const i = c.morphAttributes.position.length;
				let r = s.get(c);
				if (void 0 === r || r.count !== i) {
					void 0 !== r && r.texture.dispose();
					const e = void 0 !== c.morphAttributes.normal,
						n = c.morphAttributes.position,
						o = c.morphAttributes.normal || [],
						l = !0 === e ? 2 : 1;
					let u = c.attributes.position.count * l,
						h = 1;
					u > t.maxTextureSize && (h = Math.ceil(u / t.maxTextureSize), u = t.maxTextureSize);
					const d = new Float32Array(u * h * 4 * i),
						p = new jS(d, u, h, i);
					p.format = 1023, p.type = 1015;
					const f = 4 * l;
					for (let t = 0; t < i; t++) {
						const i = n[t],
							r = o[t],
							s = u * h * 4 * t;
						for (let t = 0; t < i.count; t++) {
							a.fromBufferAttribute(i, t), !0 === i.normalized && $S(a, i);
							const n = t * f;
							d[s + n + 0] = a.x, d[s + n + 1] = a.y, d[s + n + 2] = a.z, d[s + n + 3] = 0, !0 === e && (a.fromBufferAttribute(r, t), !0 === r.normalized && $S(a, r), d[s + n + 4] = a.x, d[s + n + 5] = a.y, d[s + n + 6] = a.z, d[s + n + 7] = 0)
						}
					}
					r = {
						count: i,
						texture: p,
						size: new Cx(u, h)
					}, s.set(c, r)
				}
				let o = 0;
				for (let e = 0; e < d.length; e++) o += d[e];
				const l = c.morphTargetsRelative ? 1 : 1 - o;
				h.getUniforms().setValue(e, "morphTargetBaseInfluence", l), h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", r.size)
			} else {
				const t = void 0 === d ? 0 : d.length;
				let n = i[c.id];
				if (void 0 === n || n.length !== t) {
					n = [];
					for (let e = 0; e < t; e++) n[e] = [e, 0];
					i[c.id] = n
				}
				for (let e = 0; e < t; e++) {
					const t = n[e];
					t[0] = e, t[1] = d[e]
				}
				n.sort(XS);
				for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
				o.sort(YS);
				const s = c.morphAttributes.position,
					a = c.morphAttributes.normal;
				let l = 0;
				for (let e = 0; e < 8; e++) {
					const t = o[e],
						n = t[0],
						i = t[1];
					n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]), r[e] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0)
				}
				const u = c.morphTargetsRelative ? 1 : 1 - l;
				h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", r)
			}
		}
	}
}

function KS(e, t, n, i) {
	let r = new WeakMap;

	function s(e) {
		const t = e.target;
		t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
	}
	return {
		update: function(e) {
			const a = i.render.frame,
				o = e.geometry,
				l = t.get(e, o);
			return r.get(l) !== a && (t.update(l), r.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
		},
		dispose: function() {
			r = new WeakMap
		}
	}
}
jS.prototype.isDataTexture2DArray = !0;
class JS extends Dx {
	constructor(e = null, t = 1, n = 1, i = 1) {
		super(null), this.image = {
			data: e,
			width: t,
			height: n,
			depth: i
		}, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
	}
}
JS.prototype.isDataTexture3D = !0;
const QS = new Dx,
	eM = new jS,
	tM = new JS,
	nM = new Zw,
	iM = [],
	rM = [],
	sM = new Float32Array(16),
	aM = new Float32Array(9),
	oM = new Float32Array(4);

function lM(e, t, n) {
	const i = e[0];
	if (i <= 0 || i > 0) return e;
	const r = t * n;
	let s = iM[r];
	if (void 0 === s && (s = new Float32Array(r), iM[r] = s), 0 !== t) {
		i.toArray(s, 0);
		for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(s, r)
	}
	return s
}

function cM(e, t) {
	if (e.length !== t.length) return !1;
	for (let n = 0, i = e.length; n < i; n++)
		if (e[n] !== t[n]) return !1;
	return !0
}

function uM(e, t) {
	for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
}

function hM(e, t) {
	let n = rM[t];
	void 0 === n && (n = new Int32Array(t), rM[t] = n);
	for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
	return n
}

function dM(e, t) {
	const n = this.cache;
	n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
}

function pM(e, t) {
	const n = this.cache;
	if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
	else {
		if (cM(n, t)) return;
		e.uniform2fv(this.addr, t), uM(n, t)
	}
}

function fM(e, t) {
	const n = this.cache;
	if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
	else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
	else {
		if (cM(n, t)) return;
		e.uniform3fv(this.addr, t), uM(n, t)
	}
}

function mM(e, t) {
	const n = this.cache;
	if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
	else {
		if (cM(n, t)) return;
		e.uniform4fv(this.addr, t), uM(n, t)
	}
}

function gM(e, t) {
	const n = this.cache,
		i = t.elements;
	if (void 0 === i) {
		if (cM(n, t)) return;
		e.uniformMatrix2fv(this.addr, !1, t), uM(n, t)
	} else {
		if (cM(n, i)) return;
		oM.set(i), e.uniformMatrix2fv(this.addr, !1, oM), uM(n, i)
	}
}

function vM(e, t) {
	const n = this.cache,
		i = t.elements;
	if (void 0 === i) {
		if (cM(n, t)) return;
		e.uniformMatrix3fv(this.addr, !1, t), uM(n, t)
	} else {
		if (cM(n, i)) return;
		aM.set(i), e.uniformMatrix3fv(this.addr, !1, aM), uM(n, i)
	}
}

function _M(e, t) {
	const n = this.cache,
		i = t.elements;
	if (void 0 === i) {
		if (cM(n, t)) return;
		e.uniformMatrix4fv(this.addr, !1, t), uM(n, t)
	} else {
		if (cM(n, i)) return;
		sM.set(i), e.uniformMatrix4fv(this.addr, !1, sM), uM(n, i)
	}
}

function yM(e, t) {
	const n = this.cache;
	n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
}

function xM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform2iv(this.addr, t), uM(n, t))
}

function bM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform3iv(this.addr, t), uM(n, t))
}

function wM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform4iv(this.addr, t), uM(n, t))
}

function SM(e, t) {
	const n = this.cache;
	n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
}

function MM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform2uiv(this.addr, t), uM(n, t))
}

function TM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform3uiv(this.addr, t), uM(n, t))
}

function CM(e, t) {
	const n = this.cache;
	cM(n, t) || (e.uniform4uiv(this.addr, t), uM(n, t))
}

function EM(e, t, n) {
	const i = this.cache,
		r = n.allocateTextureUnit();
	i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || QS, r)
}

function AM(e, t, n) {
	const i = this.cache,
		r = n.allocateTextureUnit();
	i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || tM, r)
}

function PM(e, t, n) {
	const i = this.cache,
		r = n.allocateTextureUnit();
	i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || nM, r)
}

function LM(e, t, n) {
	const i = this.cache,
		r = n.allocateTextureUnit();
	i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || eM, r)
}

function IM(e, t) {
	e.uniform1fv(this.addr, t)
}

function DM(e, t) {
	const n = lM(t, this.size, 2);
	e.uniform2fv(this.addr, n)
}

function RM(e, t) {
	const n = lM(t, this.size, 3);
	e.uniform3fv(this.addr, n)
}

function kM(e, t) {
	const n = lM(t, this.size, 4);
	e.uniform4fv(this.addr, n)
}

function NM(e, t) {
	const n = lM(t, this.size, 4);
	e.uniformMatrix2fv(this.addr, !1, n)
}

function OM(e, t) {
	const n = lM(t, this.size, 9);
	e.uniformMatrix3fv(this.addr, !1, n)
}

function FM(e, t) {
	const n = lM(t, this.size, 16);
	e.uniformMatrix4fv(this.addr, !1, n)
}

function zM(e, t) {
	e.uniform1iv(this.addr, t)
}

function UM(e, t) {
	e.uniform2iv(this.addr, t)
}

function BM(e, t) {
	e.uniform3iv(this.addr, t)
}

function VM(e, t) {
	e.uniform4iv(this.addr, t)
}

function HM(e, t) {
	e.uniform1uiv(this.addr, t)
}

function GM(e, t) {
	e.uniform2uiv(this.addr, t)
}

function WM(e, t) {
	e.uniform3uiv(this.addr, t)
}

function qM(e, t) {
	e.uniform4uiv(this.addr, t)
}

function jM(e, t, n) {
	const i = t.length,
		r = hM(n, i);
	e.uniform1iv(this.addr, r);
	for (let s = 0; s !== i; ++s) n.safeSetTexture2D(t[s] || QS, r[s])
}

function YM(e, t, n) {
	const i = t.length,
		r = hM(n, i);
	e.uniform1iv(this.addr, r);
	for (let s = 0; s !== i; ++s) n.safeSetTextureCube(t[s] || nM, r[s])
}

function XM(e, t, n) {
	this.id = e, this.addr = n, this.cache = [], this.setValue = function(e) {
		switch (e) {
			case 5126:
				return dM;
			case 35664:
				return pM;
			case 35665:
				return fM;
			case 35666:
				return mM;
			case 35674:
				return gM;
			case 35675:
				return vM;
			case 35676:
				return _M;
			case 5124:
			case 35670:
				return yM;
			case 35667:
			case 35671:
				return xM;
			case 35668:
			case 35672:
				return bM;
			case 35669:
			case 35673:
				return wM;
			case 5125:
				return SM;
			case 36294:
				return MM;
			case 36295:
				return TM;
			case 36296:
				return CM;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return EM;
			case 35679:
			case 36299:
			case 36307:
				return AM;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return PM;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return LM
		}
	}(t.type)
}

function $M(e, t, n) {
	this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function(e) {
		switch (e) {
			case 5126:
				return IM;
			case 35664:
				return DM;
			case 35665:
				return RM;
			case 35666:
				return kM;
			case 35674:
				return NM;
			case 35675:
				return OM;
			case 35676:
				return FM;
			case 5124:
			case 35670:
				return zM;
			case 35667:
			case 35671:
				return UM;
			case 35668:
			case 35672:
				return BM;
			case 35669:
			case 35673:
				return VM;
			case 5125:
				return HM;
			case 36294:
				return GM;
			case 36295:
				return WM;
			case 36296:
				return qM;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return jM;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return YM
		}
	}(t.type)
}

function ZM(e) {
	this.id = e, this.seq = [], this.map = {}
}
$M.prototype.updateCache = function(e) {
	const t = this.cache;
	e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), uM(t, e)
}, ZM.prototype.setValue = function(e, t, n) {
	const i = this.seq;
	for (let r = 0, s = i.length; r !== s; ++r) {
		const s = i[r];
		s.setValue(e, t[s.id], n)
	}
};
const KM = /(\w+)(\])?(\[|\.)?/g;

function JM(e, t) {
	e.seq.push(t), e.map[t.id] = t
}

function QM(e, t, n) {
	const i = e.name,
		r = i.length;
	for (KM.lastIndex = 0;;) {
		const s = KM.exec(i),
			a = KM.lastIndex;
		let o = s[1];
		const l = "]" === s[2],
			c = s[3];
		if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
			JM(n, void 0 === c ? new XM(o, e, t) : new $M(o, e, t));
			break
		} {
			let e = n.map[o];
			void 0 === e && (e = new ZM(o), JM(n, e)), n = e
		}
	}
}

function eT(e, t) {
	this.seq = [], this.map = {};
	const n = e.getProgramParameter(t, 35718);
	for (let i = 0; i < n; ++i) {
		const n = e.getActiveUniform(t, i);
		QM(n, e.getUniformLocation(t, n.name), this)
	}
}

function tT(e, t, n) {
	const i = e.createShader(t);
	return e.shaderSource(i, n), e.compileShader(i), i
}
eT.prototype.setValue = function(e, t, n, i) {
	const r = this.map[t];
	void 0 !== r && r.setValue(e, n, i)
}, eT.prototype.setOptional = function(e, t, n) {
	const i = t[n];
	void 0 !== i && this.setValue(e, n, i)
}, eT.upload = function(e, t, n, i) {
	for (let r = 0, s = t.length; r !== s; ++r) {
		const s = t[r],
			a = n[s.id];
		!1 !== a.needsUpdate && s.setValue(e, a.value, i)
	}
}, eT.seqWithValue = function(e, t) {
	const n = [];
	for (let i = 0, r = e.length; i !== r; ++i) {
		const r = e[i];
		r.id in t && n.push(r)
	}
	return n
};
let nT = 0;

function iT(e) {
	switch (e) {
		case 3e3:
		default:
			return ["Linear", "( value )"];
		case 3001:
			return ["sRGB", "( value )"];
		case 3002:
			return ["RGBE", "( value )"];
		case 3004:
			return ["RGBM", "( value, 7.0 )"];
		case 3005:
			return ["RGBM", "( value, 16.0 )"];
		case 3006:
			return ["RGBD", "( value, 256.0 )"];
		case 3007:
			return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
		case 3003:
			return ["LogLuv", "( value )"]
	}
}

function rT(e, t, n) {
	const i = e.getShaderParameter(t, 35713),
		r = e.getShaderInfoLog(t).trim();
	return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function(e) {
		const t = e.split("\n");
		for (let n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
		return t.join("\n")
	}(e.getShaderSource(t))
}

function sT(e, t) {
	const n = iT(t);
	return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
}

function aT(e, t) {
	const n = iT(t);
	return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
}

function oT(e, t) {
	let n;
	switch (t) {
		case 1:
		default:
			n = "Linear";
			break;
		case 2:
			n = "Reinhard";
			break;
		case 3:
			n = "OptimizedCineon";
			break;
		case 4:
			n = "ACESFilmic";
			break;
		case 5:
			n = "Custom"
	}
	return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}

function lT(e) {
	return "" !== e
}

function cT(e, t) {
	return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}

function uT(e, t) {
	return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}
const hT = /^[ \t]*#include +<([\w\d./]+)>/gm;

function dT(e) {
	return e.replace(hT, pT)
}

function pT(e, t) {
	const n = lS[t];
	if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
	return dT(n)
}
const fT = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
	mT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function gT(e) {
	return e.replace(mT, _T).replace(fT, vT)
}

function vT(e, t, n, i) {
	return _T(e, t, n, i)
}

function _T(e, t, n, i) {
	let r = "";
	for (let s = parseInt(t); s < parseInt(n); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
	return r
}

function yT(e) {
	let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
	return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
}

function xT(e, t, n, i) {
	const r = e.getContext(),
		s = n.defines;
	let a = n.vertexShader,
		o = n.fragmentShader;
	const l = function(e) {
			let t = "SHADOWMAP_TYPE_BASIC";
			return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
		}(n),
		c = function(e) {
			let t = "ENVMAP_TYPE_CUBE";
			if (e.envMap) switch (e.envMapMode) {
				case 301:
				case 302:
					t = "ENVMAP_TYPE_CUBE";
					break;
				case 306:
				case 307:
					t = "ENVMAP_TYPE_CUBE_UV"
			}
			return t
		}(n),
		u = function(e) {
			let t = "ENVMAP_MODE_REFLECTION";
			if (e.envMap) switch (e.envMapMode) {
				case 302:
				case 307:
					t = "ENVMAP_MODE_REFRACTION"
			}
			return t
		}(n),
		h = function(e) {
			let t = "ENVMAP_BLENDING_NONE";
			if (e.envMap) switch (e.combine) {
				case 0:
					t = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case 1:
					t = "ENVMAP_BLENDING_MIX";
					break;
				case 2:
					t = "ENVMAP_BLENDING_ADD"
			}
			return t
		}(n),
		d = e.gammaFactor > 0 ? e.gammaFactor : 1,
		p = n.isWebGL2 ? "" : function(e) {
			return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(lT).join("\n")
		}(n),
		f = function(e) {
			const t = [];
			for (const n in e) {
				const i = e[n];
				!1 !== i && t.push("#define " + n + " " + i)
			}
			return t.join("\n")
		}(s),
		m = r.createProgram();
	let g, v, _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
	n.isRawShaderMaterial ? (g = [f].filter(lT).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(lT).join("\n"), v.length > 0 && (v += "\n")) : (g = [yT(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(lT).join("\n"), v = [p, yT(n), "#define SHADER_NAME " + n.shaderName, f, "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? lS.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? oT("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", 1022 === n.format ? "#define OPAQUE" : "", lS.encodings_pars_fragment, n.map ? sT("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? sT("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? sT("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? sT("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? sT("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? sT("lightMapTexelToLinear", n.lightMapEncoding) : "", aT("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(lT).join("\n")), a = dT(a), a = cT(a, n), a = uT(a, n), o = dT(o), o = cT(o, n), o = uT(o, n), a = gT(a), o = gT(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
	const y = _ + v + o,
		x = tT(r, 35633, _ + g + a),
		b = tT(r, 35632, y);
	if (r.attachShader(m, x), r.attachShader(m, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), e.debug.checkShaderErrors) {
		const e = r.getProgramInfoLog(m).trim(),
			t = r.getShaderInfoLog(x).trim(),
			n = r.getShaderInfoLog(b).trim();
		let i = !0,
			s = !0;
		if (!1 === r.getProgramParameter(m, 35714)) {
			i = !1;
			rT(r, x, "vertex"), rT(r, b, "fragment")
		} else "" !== e || "" !== t && "" !== n || (s = !1);
		s && (this.diagnostics = {
			runnable: i,
			programLog: e,
			vertexShader: {
				log: t,
				prefix: g
			},
			fragmentShader: {
				log: n,
				prefix: v
			}
		})
	}
	let w, S;
	return r.deleteShader(x), r.deleteShader(b), this.getUniforms = function() {
		return void 0 === w && (w = new eT(r, m)), w
	}, this.getAttributes = function() {
		return void 0 === S && (S = function(e, t) {
			const n = {},
				i = e.getProgramParameter(t, 35721);
			for (let r = 0; r < i; r++) {
				const i = e.getActiveAttrib(t, r),
					s = i.name;
				let a = 1;
				35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = {
					type: i.type,
					location: e.getAttribLocation(t, s),
					locationSize: a
				}
			}
			return n
		}(r, m)), S
	}, this.destroy = function() {
		i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
	}, this.name = n.shaderName, this.id = nT++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = x, this.fragmentShader = b, this
}

function bT(e, t, n, i, r, s, a) {
	const o = [],
		l = r.isWebGL2,
		c = r.logarithmicDepthBuffer,
		u = r.floatVertexTextures,
		h = r.maxVertexUniforms,
		d = r.vertexTextures;
	let p = r.precision;
	const f = {
			MeshDepthMaterial: "depth",
			MeshDistanceMaterial: "distanceRGBA",
			MeshNormalMaterial: "normal",
			MeshBasicMaterial: "basic",
			MeshLambertMaterial: "lambert",
			MeshPhongMaterial: "phong",
			MeshToonMaterial: "toon",
			MeshStandardMaterial: "physical",
			MeshPhysicalMaterial: "physical",
			MeshMatcapMaterial: "matcap",
			LineBasicMaterial: "basic",
			LineDashedMaterial: "dashed",
			PointsMaterial: "points",
			ShadowMaterial: "shadow",
			SpriteMaterial: "sprite"
		},
		m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheen", "transmission", "transmissionMap", "thicknessMap"];

	function g(e) {
		let t;
		return t = e && e.isTexture ? e.encoding : e && e.isWebGLRenderTarget ? e.texture.encoding : 3e3, l && e && e.isTexture && 1023 === e.format && 1009 === e.type && 3001 === e.encoding && (t = 3e3), t
	}
	return {
		getParameters: function(s, o, m, v, _) {
			const y = v.fog,
				x = s.isMeshStandardMaterial ? v.environment : null,
				b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || x),
				w = f[s.type],
				S = _.isSkinnedMesh ? function(e) {
					const t = e.skeleton.bones;
					if (u) return 1024; {
						const e = h,
							n = Math.floor((e - 20) / 4),
							i = Math.min(n, t.length);
						return i < t.length ? 0 : i
					}
				}(_) : 0;
			let M, T;
			if (null !== s.precision && (p = r.getMaxPrecision(s.precision), s.precision), w) {
				const e = uS[w];
				M = e.vertexShader, T = e.fragmentShader
			} else M = s.vertexShader, T = s.fragmentShader;
			const C = e.getRenderTarget(),
				E = s.alphaTest > 0,
				A = s.clearcoat > 0;
			return {
				isWebGL2: l,
				shaderID: w,
				shaderName: s.type,
				vertexShader: M,
				fragmentShader: T,
				defines: s.defines,
				isRawShaderMaterial: !0 === s.isRawShaderMaterial,
				glslVersion: s.glslVersion,
				precision: p,
				instancing: !0 === _.isInstancedMesh,
				instancingColor: !0 === _.isInstancedMesh && null !== _.instanceColor,
				supportsVertexTextures: d,
				outputEncoding: null !== C ? g(C.texture) : e.outputEncoding,
				map: !!s.map,
				mapEncoding: g(s.map),
				matcap: !!s.matcap,
				matcapEncoding: g(s.matcap),
				envMap: !!b,
				envMapMode: b && b.mapping,
				envMapEncoding: g(b),
				envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
				lightMap: !!s.lightMap,
				lightMapEncoding: g(s.lightMap),
				aoMap: !!s.aoMap,
				emissiveMap: !!s.emissiveMap,
				emissiveMapEncoding: g(s.emissiveMap),
				bumpMap: !!s.bumpMap,
				normalMap: !!s.normalMap,
				objectSpaceNormalMap: 1 === s.normalMapType,
				tangentSpaceNormalMap: 0 === s.normalMapType,
				clearcoat: A,
				clearcoatMap: A && !!s.clearcoatMap,
				clearcoatRoughnessMap: A && !!s.clearcoatRoughnessMap,
				clearcoatNormalMap: A && !!s.clearcoatNormalMap,
				displacementMap: !!s.displacementMap,
				roughnessMap: !!s.roughnessMap,
				metalnessMap: !!s.metalnessMap,
				specularMap: !!s.specularMap,
				specularIntensityMap: !!s.specularIntensityMap,
				specularTintMap: !!s.specularTintMap,
				specularTintMapEncoding: g(s.specularTintMap),
				alphaMap: !!s.alphaMap,
				alphaTest: E,
				gradientMap: !!s.gradientMap,
				sheen: s.sheen > 0,
				transmission: s.transmission > 0,
				transmissionMap: !!s.transmissionMap,
				thicknessMap: !!s.thicknessMap,
				combine: s.combine,
				vertexTangents: !!s.normalMap && !!_.geometry && !!_.geometry.attributes.tangent,
				vertexColors: s.vertexColors,
				vertexAlphas: !0 === s.vertexColors && !!_.geometry && !!_.geometry.attributes.color && 4 === _.geometry.attributes.color.itemSize,
				vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap),
				uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap || !s.displacementMap),
				fog: !!y,
				useFog: s.fog,
				fogExp2: y && y.isFogExp2,
				flatShading: !!s.flatShading,
				sizeAttenuation: s.sizeAttenuation,
				logarithmicDepthBuffer: c,
				skinning: !0 === _.isSkinnedMesh && S > 0,
				maxBones: S,
				useVertexTexture: u,
				morphTargets: !!_.geometry && !!_.geometry.morphAttributes.position,
				morphNormals: !!_.geometry && !!_.geometry.morphAttributes.normal,
				morphTargetsCount: _.geometry && _.geometry.morphAttributes.position ? _.geometry.morphAttributes.position.length : 0,
				numDirLights: o.directional.length,
				numPointLights: o.point.length,
				numSpotLights: o.spot.length,
				numRectAreaLights: o.rectArea.length,
				numHemiLights: o.hemi.length,
				numDirLightShadows: o.directionalShadowMap.length,
				numPointLightShadows: o.pointShadowMap.length,
				numSpotLightShadows: o.spotShadowMap.length,
				numClippingPlanes: a.numPlanes,
				numClipIntersection: a.numIntersection,
				format: s.format,
				dithering: s.dithering,
				shadowMapEnabled: e.shadowMap.enabled && m.length > 0,
				shadowMapType: e.shadowMap.type,
				toneMapping: s.toneMapped ? e.toneMapping : 0,
				physicallyCorrectLights: e.physicallyCorrectLights,
				premultipliedAlpha: s.premultipliedAlpha,
				doubleSided: 2 === s.side,
				flipSided: 1 === s.side,
				depthPacking: void 0 !== s.depthPacking && s.depthPacking,
				index0AttributeName: s.index0AttributeName,
				extensionDerivatives: s.extensions && s.extensions.derivatives,
				extensionFragDepth: s.extensions && s.extensions.fragDepth,
				extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
				extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: l || i.has("EXT_frag_depth"),
				rendererExtensionDrawBuffers: l || i.has("WEBGL_draw_buffers"),
				rendererExtensionShaderTextureLod: l || i.has("EXT_shader_texture_lod"),
				customProgramCacheKey: s.customProgramCacheKey()
			}
		},
		getProgramCacheKey: function(t) {
			const n = [];
			if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
				for (const e in t.defines) n.push(e), n.push(t.defines[e]);
			if (!1 === t.isRawShaderMaterial) {
				for (let e = 0; e < m.length; e++) n.push(t[m[e]]);
				n.push(e.outputEncoding), n.push(e.gammaFactor)
			}
			return n.push(t.customProgramCacheKey), n.join()
		},
		getUniforms: function(e) {
			const t = f[e.type];
			let n;
			if (t) {
				const e = uS[t];
				n = qw.clone(e.uniforms)
			} else n = e.uniforms;
			return n
		},
		acquireProgram: function(t, n) {
			let i;
			for (let e = 0, r = o.length; e < r; e++) {
				const t = o[e];
				if (t.cacheKey === n) {
					i = t, ++i.usedTimes;
					break
				}
			}
			return void 0 === i && (i = new xT(e, n, t, s), o.push(i)), i
		},
		releaseProgram: function(e) {
			if (0 == --e.usedTimes) {
				const t = o.indexOf(e);
				o[t] = o[o.length - 1], o.pop(), e.destroy()
			}
		},
		programs: o
	}
}

function wT() {
	let e = new WeakMap;
	return {
		get: function(t) {
			let n = e.get(t);
			return void 0 === n && (n = {}, e.set(t, n)), n
		},
		remove: function(t) {
			e.delete(t)
		},
		update: function(t, n, i) {
			e.get(t)[n] = i
		},
		dispose: function() {
			e = new WeakMap
		}
	}
}

function ST(e, t) {
	return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
}

function MT(e, t) {
	return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
}

function TT(e) {
	const t = [];
	let n = 0;
	const i = [],
		r = [],
		s = [],
		a = {
			id: -1
		};

	function o(i, r, s, o, l, c) {
		let u = t[n];
		const h = e.get(s);
		return void 0 === u ? (u = {
			id: i.id,
			object: i,
			geometry: r,
			material: s,
			program: h.program || a,
			groupOrder: o,
			renderOrder: i.renderOrder,
			z: l,
			group: c
		}, t[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = s, u.program = h.program || a, u.groupOrder = o, u.renderOrder = i.renderOrder, u.z = l, u.group = c), n++, u
	}
	return {
		opaque: i,
		transmissive: r,
		transparent: s,
		init: function() {
			n = 0, i.length = 0, r.length = 0, s.length = 0
		},
		push: function(e, t, n, a, l, c) {
			const u = o(e, t, n, a, l, c);
			n.transmission > 0 ? r.push(u) : !0 === n.transparent ? s.push(u) : i.push(u)
		},
		unshift: function(e, t, n, a, l, c) {
			const u = o(e, t, n, a, l, c);
			n.transmission > 0 ? r.unshift(u) : !0 === n.transparent ? s.unshift(u) : i.unshift(u)
		},
		finish: function() {
			for (let e = n, i = t.length; e < i; e++) {
				const n = t[e];
				if (null === n.id) break;
				n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
			}
		},
		sort: function(e, t) {
			i.length > 1 && i.sort(e || ST), r.length > 1 && r.sort(t || MT), s.length > 1 && s.sort(t || MT)
		}
	}
}

function CT(e) {
	let t = new WeakMap;
	return {
		get: function(n, i) {
			let r;
			return !1 === t.has(n) ? (r = new TT(e), t.set(n, [r])) : i >= t.get(n).length ? (r = new TT(e), t.get(n).push(r)) : r = t.get(n)[i], r
		},
		dispose: function() {
			t = new WeakMap
		}
	}
}

function ET() {
	const e = {};
	return {
		get: function(t) {
			if (void 0 !== e[t.id]) return e[t.id];
			let n;
			switch (t.type) {
				case "DirectionalLight":
					n = {
						direction: new zx,
						color: new aw
					};
					break;
				case "SpotLight":
					n = {
						position: new zx,
						direction: new zx,
						color: new aw,
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case "PointLight":
					n = {
						position: new zx,
						color: new aw,
						distance: 0,
						decay: 0
					};
					break;
				case "HemisphereLight":
					n = {
						direction: new zx,
						skyColor: new aw,
						groundColor: new aw
					};
					break;
				case "RectAreaLight":
					n = {
						color: new aw,
						position: new zx,
						halfWidth: new zx,
						halfHeight: new zx
					}
			}
			return e[t.id] = n, n
		}
	}
}
let AT = 0;

function PT(e, t) {
	return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
}

function LT(e, t) {
	const n = new ET,
		i = function() {
			const e = {};
			return {
				get: function(t) {
					if (void 0 !== e[t.id]) return e[t.id];
					let n;
					switch (t.type) {
						case "DirectionalLight":
						case "SpotLight":
							n = {
								shadowBias: 0,
								shadowNormalBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Cx
							};
							break;
						case "PointLight":
							n = {
								shadowBias: 0,
								shadowNormalBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Cx,
								shadowCameraNear: 1,
								shadowCameraFar: 1e3
							}
					}
					return e[t.id] = n, n
				}
			}
		}(),
		r = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};
	for (let l = 0; l < 9; l++) r.probe.push(new zx);
	const s = new zx,
		a = new mb,
		o = new mb;
	return {
		setup: function(s, a) {
			let o = 0,
				l = 0,
				c = 0;
			for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
			let u = 0,
				h = 0,
				d = 0,
				p = 0,
				f = 0,
				m = 0,
				g = 0,
				v = 0;
			s.sort(PT);
			const _ = !0 !== a ? Math.PI : 1;
			for (let e = 0, t = s.length; e < t; e++) {
				const t = s[e],
					a = t.color,
					y = t.intensity,
					x = t.distance,
					b = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
				if (t.isAmbientLight) o += a.r * y * _, l += a.g * y * _, c += a.b * y * _;
				else if (t.isLightProbe)
					for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], y);
				else if (t.isDirectionalLight) {
					const e = n.get(t);
					if (e.color.copy(t.color).multiplyScalar(t.intensity * _), t.castShadow) {
						const e = t.shadow,
							n = i.get(t);
						n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = b, r.directionalShadowMatrix[u] = t.shadow.matrix, m++
					}
					r.directional[u] = e, u++
				} else if (t.isSpotLight) {
					const e = n.get(t);
					if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(y * _), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
						const e = t.shadow,
							n = i.get(t);
						n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = b, r.spotShadowMatrix[d] = t.shadow.matrix, v++
					}
					r.spot[d] = e, d++
				} else if (t.isRectAreaLight) {
					const e = n.get(t);
					e.color.copy(a).multiplyScalar(y), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
				} else if (t.isPointLight) {
					const e = n.get(t);
					if (e.color.copy(t.color).multiplyScalar(t.intensity * _), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
						const e = t.shadow,
							n = i.get(t);
						n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = b, r.pointShadowMatrix[h] = t.shadow.matrix, g++
					}
					r.point[h] = e, h++
				} else if (t.isHemisphereLight) {
					const e = n.get(t);
					e.skyColor.copy(t.color).multiplyScalar(y * _), e.groundColor.copy(t.groundColor).multiplyScalar(y * _), r.hemi[f] = e, f++
				}
			}
			p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = cS.LTC_FLOAT_1, r.rectAreaLTC2 = cS.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") && (r.rectAreaLTC1 = cS.LTC_HALF_1, r.rectAreaLTC2 = cS.LTC_HALF_2)), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
			const y = r.hash;
			y.directionalLength === u && y.pointLength === h && y.spotLength === d && y.rectAreaLength === p && y.hemiLength === f && y.numDirectionalShadows === m && y.numPointShadows === g && y.numSpotShadows === v || (r.directional.length = u, r.spot.length = d, r.rectArea.length = p, r.point.length = h, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, y.directionalLength = u, y.pointLength = h, y.spotLength = d, y.rectAreaLength = p, y.hemiLength = f, y.numDirectionalShadows = m, y.numPointShadows = g, y.numSpotShadows = v, r.version = AT++)
		},
		setupView: function(e, t) {
			let n = 0,
				i = 0,
				l = 0,
				c = 0,
				u = 0;
			const h = t.matrixWorldInverse;
			for (let d = 0, p = e.length; d < p; d++) {
				const t = e[d];
				if (t.isDirectionalLight) {
					const e = r.directional[n];
					e.direction.setFromMatrixPosition(t.matrixWorld), s.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), n++
				} else if (t.isSpotLight) {
					const e = r.spot[l];
					e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(t.matrixWorld), s.setFromMatrixPosition(t.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), l++
				} else if (t.isRectAreaLight) {
					const e = r.rectArea[c];
					e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), o.identity(), a.copy(t.matrixWorld), a.premultiply(h), o.extractRotation(a), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
				} else if (t.isPointLight) {
					const e = r.point[i];
					e.position.setFromMatrixPosition(t.matrixWorld), e.position.applyMatrix4(h), i++
				} else if (t.isHemisphereLight) {
					const e = r.hemi[u];
					e.direction.setFromMatrixPosition(t.matrixWorld), e.direction.transformDirection(h), e.direction.normalize(), u++
				}
			}
		},
		state: r
	}
}

function IT(e, t) {
	const n = new LT(e, t),
		i = [],
		r = [];
	return {
		init: function() {
			i.length = 0, r.length = 0
		},
		state: {
			lightsArray: i,
			shadowsArray: r,
			lights: n
		},
		setupLights: function(e) {
			n.setup(i, e)
		},
		setupLightsView: function(e) {
			n.setupView(i, e)
		},
		pushLight: function(e) {
			i.push(e)
		},
		pushShadow: function(e) {
			r.push(e)
		}
	}
}

function DT(e, t) {
	let n = new WeakMap;
	return {
		get: function(i, r = 0) {
			let s;
			return !1 === n.has(i) ? (s = new IT(e, t), n.set(i, [s])) : r >= n.get(i).length ? (s = new IT(e, t), n.get(i).push(s)) : s = n.get(i)[r], s
		},
		dispose: function() {
			n = new WeakMap
		}
	}
}
class RT extends Qb {
	constructor(e) {
		super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
	}
}
RT.prototype.isMeshDepthMaterial = !0;
class kT extends Qb {
	constructor(e) {
		super(), this.type = "MeshDistanceMaterial", this.referencePosition = new zx, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
	}
}
kT.prototype.isMeshDistanceMaterial = !0;

function NT(e, t, n) {
	let i = new rS;
	const r = new Cx,
		s = new Cx,
		a = new kx,
		o = new RT({
			depthPacking: 3201
		}),
		l = new kT,
		c = {},
		u = n.maxTextureSize,
		h = {
			0: 1,
			1: 0,
			2: 2
		},
		d = new jw({
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Cx
				},
				radius: {
					value: 4
				},
				samples: {
					value: 8
				}
			},
			vertexShader: "void main(){gl_Position=vec4(position,1.0);}",
			fragmentShader: "uniform sampler2D shadow_pass;uniform vec2 resolution;uniform float radius;uniform float samples;\n#include <packing>\nvoid main(){float mean=0.0;float squared_mean=0.0;float uvStride=samples<=1.0?0.0:2.0/(samples-1.0);float uvStart=samples<=1.0?0.0:-1.0;for(float i=0.0;i<samples;i++){float uvOffset=uvStart+i*uvStride;\n#ifdef HORIZONTAL_PASS\nvec2 distribution=unpackRGBATo2Half(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(uvOffset,0.0)*radius)/resolution));mean+=distribution.x;squared_mean+=distribution.y*distribution.y+distribution.x*distribution.x;\n#else\nfloat depth=unpackRGBAToDepth(texture2D(shadow_pass,(gl_FragCoord.xy+vec2(0.0,uvOffset)*radius)/resolution));mean+=depth;squared_mean+=depth*depth;\n#endif\n}mean=mean/samples;squared_mean=squared_mean/samples;float std_dev=sqrt(squared_mean-mean*mean);gl_FragColor=pack2HalfToRGBA(vec2(mean,std_dev));}"
		}),
		p = d.clone();
	p.defines.HORIZONTAL_PASS = 1;
	const f = new ww;
	f.setAttribute("position", new uw(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
	const m = new Bw(f, d),
		g = this;

	function v(n, i) {
		const r = t.update(m);
		d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, d.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, p.uniforms.samples.value = n.blurSamples, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, p, m, null)
	}

	function _(t, n, i, r, s, a, u) {
		let d = null;
		const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
		if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
			const e = d.uuid,
				t = i.uuid;
			let n = c[e];
			void 0 === n && (n = {}, c[e] = n);
			let r = n[t];
			void 0 === r && (r = d.clone(), n[t] = r), d = r
		}
		return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === u ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = s, d.farDistance = a), d
	}

	function y(n, r, s, a, o) {
		if (!1 === n.visible) return;
		if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
			n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
			const i = t.update(n),
				r = n.material;
			if (Array.isArray(r)) {
				const t = i.groups;
				for (let l = 0, c = t.length; l < c; l++) {
					const c = t[l],
						u = r[c.materialIndex];
					if (u && u.visible) {
						const t = _(n, 0, u, a, s.near, s.far, o);
						e.renderBufferDirect(s, null, i, t, n, c)
					}
				}
			} else if (r.visible) {
				const t = _(n, 0, r, a, s.near, s.far, o);
				e.renderBufferDirect(s, null, i, t, n, null)
			}
		}
		const l = n.children;
		for (let e = 0, t = l.length; e < t; e++) y(l[e], r, s, a, o)
	}
	this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, n, o) {
		if (!1 === g.enabled) return;
		if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
		if (0 === t.length) return;
		const l = e.getRenderTarget(),
			c = e.getActiveCubeFace(),
			h = e.getActiveMipmapLevel(),
			d = e.state;
		d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
		for (let p = 0, f = t.length; p < f; p++) {
			const l = t[p],
				c = l.shadow;
			if (void 0 === c) continue;
			if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
			r.copy(c.mapSize);
			const h = c.getFrameExtents();
			if (r.multiply(h), s.copy(c.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / h.x), r.x = s.x * h.x, c.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / h.y), r.y = s.y * h.y, c.mapSize.y = s.y)), null === c.map && !c.isPointLightShadow && 3 === this.type) {
				const e = {
					minFilter: 1006,
					magFilter: 1006,
					format: 1023
				};
				c.map = new Nx(r.x, r.y, e), c.map.texture.name = l.name + ".shadowMap", c.mapPass = new Nx(r.x, r.y, e), c.camera.updateProjectionMatrix()
			}
			if (null === c.map) {
				const e = {
					minFilter: 1003,
					magFilter: 1003,
					format: 1023
				};
				c.map = new Nx(r.x, r.y, e), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
			}
			e.setRenderTarget(c.map), e.clear();
			const f = c.getViewportCount();
			for (let e = 0; e < f; e++) {
				const t = c.getViewport(e);
				a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), c.updateMatrices(l, e), i = c.getFrustum(), y(n, o, c.camera, l, this.type)
			}
			c.isPointLightShadow || 3 !== this.type || v(c, o), c.needsUpdate = !1
		}
		g.needsUpdate = !1, e.setRenderTarget(l, c, h)
	}
}

function OT(e, t, n) {
	const i = n.isWebGL2;
	const r = new function() {
			let t = !1;
			const n = new kx;
			let i = null;
			const r = new kx(0, 0, 0, 0);
			return {
				setMask: function(n) {
					i === n || t || (e.colorMask(n, n, n, n), i = n)
				},
				setLocked: function(e) {
					t = e
				},
				setClear: function(t, i, s, a, o) {
					!0 === o && (t *= a, i *= a, s *= a), n.set(t, i, s, a), !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n))
				},
				reset: function() {
					t = !1, i = null, r.set(-1, 0, 0, 0)
				}
			}
		},
		s = new function() {
			let t = !1,
				n = null,
				i = null,
				r = null;
			return {
				setTest: function(e) {
					e ? F(2929) : z(2929)
				},
				setMask: function(i) {
					n === i || t || (e.depthMask(i), n = i)
				},
				setFunc: function(t) {
					if (i !== t) {
						if (t) switch (t) {
							case 0:
								e.depthFunc(512);
								break;
							case 1:
								e.depthFunc(519);
								break;
							case 2:
								e.depthFunc(513);
								break;
							case 3:
							default:
								e.depthFunc(515);
								break;
							case 4:
								e.depthFunc(514);
								break;
							case 5:
								e.depthFunc(518);
								break;
							case 6:
								e.depthFunc(516);
								break;
							case 7:
								e.depthFunc(517)
						} else e.depthFunc(515);
						i = t
					}
				},
				setLocked: function(e) {
					t = e
				},
				setClear: function(t) {
					r !== t && (e.clearDepth(t), r = t)
				},
				reset: function() {
					t = !1, n = null, i = null, r = null
				}
			}
		},
		a = new function() {
			let t = !1,
				n = null,
				i = null,
				r = null,
				s = null,
				a = null,
				o = null,
				l = null,
				c = null;
			return {
				setTest: function(e) {
					t || (e ? F(2960) : z(2960))
				},
				setMask: function(i) {
					n === i || t || (e.stencilMask(i), n = i)
				},
				setFunc: function(t, n, a) {
					i === t && r === n && s === a || (e.stencilFunc(t, n, a), i = t, r = n, s = a)
				},
				setOp: function(t, n, i) {
					a === t && o === n && l === i || (e.stencilOp(t, n, i), a = t, o = n, l = i)
				},
				setLocked: function(e) {
					t = e
				},
				setClear: function(t) {
					c !== t && (e.clearStencil(t), c = t)
				},
				reset: function() {
					t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
				}
			}
		};
	let o = {},
		l = null,
		c = {},
		u = null,
		h = !1,
		d = null,
		p = null,
		f = null,
		m = null,
		g = null,
		v = null,
		_ = null,
		y = !1,
		x = null,
		b = null,
		w = null,
		S = null,
		M = null;
	const T = e.getParameter(35661);
	let C = !1,
		E = 0;
	const A = e.getParameter(7938); - 1 !== A.indexOf("WebGL") ? (E = parseFloat(/^WebGL (\d)/.exec(A)[1]), C = E >= 1) : -1 !== A.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), C = E >= 2);
	let P = null,
		L = {};
	const I = e.getParameter(3088),
		D = e.getParameter(2978),
		R = (new kx).fromArray(I),
		k = (new kx).fromArray(D);

	function N(t, n, i) {
		const r = new Uint8Array(4),
			s = e.createTexture();
		e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
		for (let a = 0; a < i; a++) e.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
		return s
	}
	const O = {};

	function F(t) {
		!0 !== o[t] && (e.enable(t), o[t] = !0)
	}

	function z(t) {
		!1 !== o[t] && (e.disable(t), o[t] = !1)
	}
	O[3553] = N(3553, 3553, 1), O[34067] = N(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), F(2929), s.setFunc(3), H(!1), G(1), F(2884), V(0);
	const U = {
		100: 32774,
		101: 32778,
		102: 32779
	};
	if (i) U[103] = 32775, U[104] = 32776;
	else {
		const e = t.get("EXT_blend_minmax");
		null !== e && (U[103] = e.MIN_EXT, U[104] = e.MAX_EXT)
	}
	const B = {
		200: 0,
		201: 1,
		202: 768,
		204: 770,
		210: 776,
		208: 774,
		206: 772,
		203: 769,
		205: 771,
		209: 775,
		207: 773
	};

	function V(t, n, i, r, s, a, o, l) {
		if (0 !== t) {
			if (!1 === h && (F(3042), h = !0), 5 === t) s = s || n, a = a || i, o = o || r, n === p && s === g || (e.blendEquationSeparate(U[n], U[s]), p = n, g = s), i === f && r === m && a === v && o === _ || (e.blendFuncSeparate(B[i], B[r], B[a], B[o]), f = i, m = r, v = a, _ = o), d = t, y = null;
			else if (t !== d || l !== y) {
				if (100 === p && 100 === g || (e.blendEquation(32774), p = 100, g = 100), l) switch (t) {
					case 1:
						e.blendFuncSeparate(1, 771, 1, 771);
						break;
					case 2:
						e.blendFunc(1, 1);
						break;
					case 3:
						e.blendFuncSeparate(0, 0, 769, 771);
						break;
					case 4:
						e.blendFuncSeparate(0, 768, 0, 770)
				} else switch (t) {
					case 1:
						e.blendFuncSeparate(770, 771, 1, 771);
						break;
					case 2:
						e.blendFunc(770, 1);
						break;
					case 3:
						e.blendFunc(0, 769);
						break;
					case 4:
						e.blendFunc(0, 768)
				}
				f = null, m = null, v = null, _ = null, d = t, y = l
			}
		} else !0 === h && (z(3042), h = !1)
	}

	function H(t) {
		x !== t && (t ? e.frontFace(2304) : e.frontFace(2305), x = t)
	}

	function G(t) {
		0 !== t ? (F(2884), t !== b && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : z(2884), b = t
	}

	function W(t, n, i) {
		t ? (F(32823), S === n && M === i || (e.polygonOffset(n, i), S = n, M = i)) : z(32823)
	}

	function q(t) {
		void 0 === t && (t = 33984 + T - 1), P !== t && (e.activeTexture(t), P = t)
	}
	return {
		buffers: {
			color: r,
			depth: s,
			stencil: a
		},
		enable: F,
		disable: z,
		bindFramebuffer: function(t, n) {
			return null === n && null !== l && (n = l), c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, i && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), !0)
		},
		bindXRFramebuffer: function(t) {
			t !== l && (e.bindFramebuffer(36160, t), l = t)
		},
		useProgram: function(t) {
			return u !== t && (e.useProgram(t), u = t, !0)
		},
		setBlending: V,
		setMaterial: function(e, t) {
			2 === e.side ? z(2884) : F(2884);
			let n = 1 === e.side;
			t && (n = !n), H(n), 1 === e.blending && !1 === e.transparent ? V(0) : V(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite);
			const i = e.stencilWrite;
			a.setTest(i), i && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? F(32926) : z(32926)
		},
		setFlipSided: H,
		setCullFace: G,
		setLineWidth: function(t) {
			t !== w && (C && e.lineWidth(t), w = t)
		},
		setPolygonOffset: W,
		setScissorTest: function(e) {
			e ? F(3089) : z(3089)
		},
		activeTexture: q,
		bindTexture: function(t, n) {
			null === P && q();
			let i = L[P];
			void 0 === i && (i = {
				type: void 0,
				texture: void 0
			}, L[P] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || O[t]), i.type = t, i.texture = n)
		},
		unbindTexture: function() {
			const t = L[P];
			void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
		},
		compressedTexImage2D: function() {
			try {
				e.compressedTexImage2D.apply(e, arguments)
			} catch (t) {}
		},
		texImage2D: function() {
			try {
				e.texImage2D.apply(e, arguments)
			} catch (t) {}
		},
		texImage3D: function() {
			try {
				e.texImage3D.apply(e, arguments)
			} catch (t) {}
		},
		scissor: function(t) {
			!1 === R.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), R.copy(t))
		},
		viewport: function(t) {
			!1 === k.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), k.copy(t))
		},
		reset: function() {
			e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === i && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), o = {}, P = null, L = {}, l = null, c = {}, u = null, h = !1, d = null, p = null, f = null, m = null, g = null, v = null, _ = null, y = !1, x = null, b = null, w = null, S = null, M = null, R.set(0, 0, e.canvas.width, e.canvas.height), k.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), s.reset(), a.reset()
		}
	}
}

function FT(e, t, n, i, r, s, a) {
	const o = r.isWebGL2,
		l = (r.maxTextures, r.maxCubemapSize),
		c = r.maxTextureSize,
		u = r.maxSamples,
		h = new WeakMap;
	let d, p = !1;
	try {
		p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
	} catch (F) {}

	function f(e, t) {
		return p ? new OffscreenCanvas(e, t) : Px("canvas")
	}

	function m(e, t, n, i) {
		let r = 1;
		if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
			if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
				const i = t ? Tx : Math.floor,
					s = i(r * e.width),
					a = i(r * e.height);
				void 0 === d && (d = f(s, a));
				const o = n ? f(s, a) : d;
				o.width = s, o.height = a;
				return o.getContext("2d").drawImage(e, 0, 0, s, a), o
			}
			return e
		}
		return e
	}

	function g(e) {
		return Mx(e.width) && Mx(e.height)
	}

	function v(e, t) {
		return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
	}

	function _(t, n, r, s, a = 1) {
		e.generateMipmap(t);
		i.get(n).__maxMipLevel = Math.log2(Math.max(r, s, a))
	}

	function y(n, i, r, s) {
		if (!1 === o) return i;
		if (null !== n && void 0 !== e[n]) return e[n];
		let a = i;
		return 6403 === i && (5126 === r && (a = 33326), 5131 === r && (a = 33325), 5121 === r && (a = 33321)), 6407 === i && (5126 === r && (a = 34837), 5131 === r && (a = 34843), 5121 === r && (a = 32849)), 6408 === i && (5126 === r && (a = 34836), 5131 === r && (a = 34842), 5121 === r && (a = 3001 === s ? 35907 : 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a
	}

	function x(e) {
		return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
	}

	function b(t) {
		const n = t.target;
		n.removeEventListener("dispose", b),
			function(t) {
				const n = i.get(t);
				if (void 0 === n.__webglInit) return;
				e.deleteTexture(n.__webglTexture), i.remove(t)
			}(n), n.isVideoTexture && h.delete(n), a.memory.textures--
	}

	function w(t) {
		const n = t.target;
		n.removeEventListener("dispose", w),
			function(t) {
				const n = t.texture,
					r = i.get(t),
					s = i.get(n);
				if (!t) return;
				void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--);
				t.depthTexture && t.depthTexture.dispose();
				if (t.isWebGLCubeRenderTarget)
					for (let i = 0; i < 6; i++) e.deleteFramebuffer(r.__webglFramebuffer[i]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[i]);
				else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
				if (t.isWebGLMultipleRenderTargets)
					for (let o = 0, l = n.length; o < l; o++) {
						const t = i.get(n[o]);
						t.__webglTexture && (e.deleteTexture(t.__webglTexture), a.memory.textures--), i.remove(n[o])
					}
				i.remove(n), i.remove(t)
			}(n)
	}
	let S = 0;

	function M(e, t) {
		const r = i.get(e);
		if (e.isVideoTexture && function(e) {
				const t = a.render.frame;
				h.get(e) !== t && (h.set(e, t), e.update())
			}(e), e.version > 0 && r.__version !== e.version) {
			const n = e.image;
			if (void 0 === n);
			else if (!1 !== n.complete) return void L(r, e, t)
		}
		n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
	}

	function T(t, r) {
		const a = i.get(t);
		t.version > 0 && a.__version !== t.version ? function(t, i, r) {
			if (6 !== i.image.length) return;
			P(t, i), n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
			const a = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
				c = i.image[0] && i.image[0].isDataTexture,
				u = [];
			for (let e = 0; e < 6; e++) u[e] = a || c ? c ? i.image[e].image : i.image[e] : m(i.image[e], !1, !0, l);
			const h = u[0],
				d = g(h) || o,
				p = s.convert(i.format),
				f = s.convert(i.type),
				x = y(i.internalFormat, p, f, i.encoding);
			let b;
			if (A(34067, i, d), a) {
				for (let e = 0; e < 6; e++) {
					b = u[e].mipmaps;
					for (let t = 0; t < b.length; t++) {
						const r = b[t];
						1023 !== i.format && 1022 !== i.format ? null !== p && n.compressedTexImage2D(34069 + e, t, x, r.width, r.height, 0, r.data) : n.texImage2D(34069 + e, t, x, r.width, r.height, 0, p, f, r.data)
					}
				}
				t.__maxMipLevel = b.length - 1
			} else {
				b = i.mipmaps;
				for (let e = 0; e < 6; e++)
					if (c) {
						n.texImage2D(34069 + e, 0, x, u[e].width, u[e].height, 0, p, f, u[e].data);
						for (let t = 0; t < b.length; t++) {
							const i = b[t].image[e].image;
							n.texImage2D(34069 + e, t + 1, x, i.width, i.height, 0, p, f, i.data)
						}
					} else {
						n.texImage2D(34069 + e, 0, x, p, f, u[e]);
						for (let t = 0; t < b.length; t++) {
							const i = b[t];
							n.texImage2D(34069 + e, t + 1, x, p, f, i.image[e])
						}
					} t.__maxMipLevel = b.length
			}
			v(i, d) && _(34067, i, h.width, h.height);
			t.__version = i.version, i.onUpdate && i.onUpdate(i)
		}(a, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture))
	}
	const C = {
			1e3: 10497,
			1001: 33071,
			1002: 33648
		},
		E = {
			1003: 9728,
			1004: 9984,
			1005: 9986,
			1006: 9729,
			1007: 9985,
			1008: 9987
		};

	function A(n, s, a) {
		if (a ? (e.texParameteri(n, 10242, C[s.wrapS]), e.texParameteri(n, 10243, C[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, C[s.wrapR]), e.texParameteri(n, 10240, E[s.magFilter]), e.texParameteri(n, 10241, E[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), 1001 !== s.wrapS || s.wrapT, e.texParameteri(n, 10240, x(s.magFilter)), e.texParameteri(n, 10241, x(s.minFilter)), 1003 !== s.minFilter && s.minFilter), !0 === t.has("EXT_texture_filter_anisotropic")) {
			const a = t.get("EXT_texture_filter_anisotropic");
			if (1015 === s.type && !1 === t.has("OES_texture_float_linear")) return;
			if (!1 === o && 1016 === s.type && !1 === t.has("OES_texture_half_float_linear")) return;
			(s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
		}
	}

	function P(t, n) {
		void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", b), t.__webglTexture = e.createTexture(), a.memory.textures++)
	}

	function L(t, i, r) {
		let a = 3553;
		i.isDataTexture2DArray && (a = 35866), i.isDataTexture3D && (a = 32879), P(t, i), n.activeTexture(33984 + r), n.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
		const l = function(e) {
				return !o && (1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter)
			}(i) && !1 === g(i.image),
			u = m(i.image, l, !1, c),
			h = g(u) || o,
			d = s.convert(i.format);
		let p, f = s.convert(i.type),
			x = y(i.internalFormat, d, f, i.encoding);
		A(a, i, h);
		const b = i.mipmaps;
		if (i.isDepthTexture) x = 6402, o ? x = 1015 === i.type ? 36012 : 1014 === i.type ? 33190 : 1020 === i.type ? 35056 : 33189 : i.type, 1026 === i.format && 6402 === x && 1012 !== i.type && 1014 !== i.type && (i.type = 1012, f = s.convert(i.type)), 1027 === i.format && 6402 === x && (x = 34041, 1020 !== i.type && (i.type = 1020, f = s.convert(i.type))), n.texImage2D(3553, 0, x, u.width, u.height, 0, d, f, null);
		else if (i.isDataTexture)
			if (b.length > 0 && h) {
				for (let e = 0, t = b.length; e < t; e++) p = b[e], n.texImage2D(3553, e, x, p.width, p.height, 0, d, f, p.data);
				i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
			} else n.texImage2D(3553, 0, x, u.width, u.height, 0, d, f, u.data), t.__maxMipLevel = 0;
		else if (i.isCompressedTexture) {
			for (let e = 0, t = b.length; e < t; e++) p = b[e], 1023 !== i.format && 1022 !== i.format ? null !== d && n.compressedTexImage2D(3553, e, x, p.width, p.height, 0, p.data) : n.texImage2D(3553, e, x, p.width, p.height, 0, d, f, p.data);
			t.__maxMipLevel = b.length - 1
		} else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, x, u.width, u.height, u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
		else if (i.isDataTexture3D) n.texImage3D(32879, 0, x, u.width, u.height, u.depth, 0, d, f, u.data), t.__maxMipLevel = 0;
		else if (b.length > 0 && h) {
			for (let e = 0, t = b.length; e < t; e++) p = b[e], n.texImage2D(3553, e, x, d, f, p);
			i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1
		} else n.texImage2D(3553, 0, x, d, f, u), t.__maxMipLevel = 0;
		v(i, h) && _(a, i, u.width, u.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
	}

	function I(t, r, a, o, l) {
		const c = s.convert(a.format),
			u = s.convert(a.type),
			h = y(a.internalFormat, c, u, a.encoding);
		32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null), n.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null)
	}

	function D(t, n, i) {
		if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
			let r = 33189;
			if (i) {
				const t = n.depthTexture;
				t && t.isDepthTexture && (1015 === t.type ? r = 36012 : 1014 === t.type && (r = 33190));
				const i = k(n);
				e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
			} else e.renderbufferStorage(36161, r, n.width, n.height);
			e.framebufferRenderbuffer(36160, 36096, 36161, t)
		} else if (n.depthBuffer && n.stencilBuffer) {
			if (i) {
				const t = k(n);
				e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height)
			} else e.renderbufferStorage(36161, 34041, n.width, n.height);
			e.framebufferRenderbuffer(36160, 33306, 36161, t)
		} else {
			const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
				r = s.convert(t.format),
				a = s.convert(t.type),
				o = y(t.internalFormat, r, a, t.encoding);
			if (i) {
				const t = k(n);
				e.renderbufferStorageMultisample(36161, t, o, n.width, n.height)
			} else e.renderbufferStorage(36161, o, n.width, n.height)
		}
		e.bindRenderbuffer(36161, null)
	}

	function R(t) {
		const r = i.get(t),
			s = !0 === t.isWebGLCubeRenderTarget;
		if (t.depthTexture) {
			if (s) throw new Error("target.depthTexture not supported in Cube render targets");
			! function(t, r) {
				if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
				if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
				i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), M(r.depthTexture, 0);
				const s = i.get(r.depthTexture).__webglTexture;
				if (1026 === r.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, s, 0);
				else {
					if (1027 !== r.depthTexture.format) throw new Error("Unknown depthTexture format");
					e.framebufferTexture2D(36160, 33306, 3553, s, 0)
				}
			}(r.__webglFramebuffer, t)
		} else if (s) {
			r.__webglDepthbuffer = [];
			for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), D(r.__webglDepthbuffer[i], t, !1)
		} else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), D(r.__webglDepthbuffer, t, !1);
		n.bindFramebuffer(36160, null)
	}

	function k(e) {
		return o && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0
	}
	let N = !1,
		O = !1;
	this.allocateTextureUnit = function() {
		const e = S;
		return S += 1, e
	}, this.resetTextureUnits = function() {
		S = 0
	}, this.setTexture2D = M, this.setTexture2DArray = function(e, t) {
		const r = i.get(e);
		e.version > 0 && r.__version !== e.version ? L(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
	}, this.setTexture3D = function(e, t) {
		const r = i.get(e);
		e.version > 0 && r.__version !== e.version ? L(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
	}, this.setTextureCube = T, this.setupRenderTarget = function(t) {
		const l = t.texture,
			c = i.get(t),
			u = i.get(l);
		t.addEventListener("dispose", w), !0 !== t.isWebGLMultipleRenderTargets && (u.__webglTexture = e.createTexture(), u.__version = l.version, a.memory.textures++);
		const h = !0 === t.isWebGLCubeRenderTarget,
			d = !0 === t.isWebGLMultipleRenderTargets,
			p = !0 === t.isWebGLMultisampleRenderTarget,
			f = l.isDataTexture3D || l.isDataTexture2DArray,
			m = g(t) || o;
		if (!o || 1022 !== l.format || 1015 !== l.type && 1016 !== l.type || (l.format = 1023), h) {
			c.__webglFramebuffer = [];
			for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
		} else if (c.__webglFramebuffer = e.createFramebuffer(), d) {
			if (r.drawBuffers) {
				const n = t.texture;
				for (let t = 0, r = n.length; t < r; t++) {
					const r = i.get(n[t]);
					void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), a.memory.textures++)
				}
			}
		} else if (p && o) {
			c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
			const i = s.convert(l.format),
				r = s.convert(l.type),
				a = y(l.internalFormat, i, r, l.encoding),
				o = k(t);
			e.renderbufferStorageMultisample(36161, o, a, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), D(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null)
		}
		if (h) {
			n.bindTexture(34067, u.__webglTexture), A(34067, l, m);
			for (let e = 0; e < 6; e++) I(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
			v(l, m) && _(34067, l, t.width, t.height), n.unbindTexture()
		} else if (d) {
			const e = t.texture;
			for (let r = 0, s = e.length; r < s; r++) {
				const s = e[r],
					a = i.get(s);
				n.bindTexture(3553, a.__webglTexture), A(3553, s, m), I(c.__webglFramebuffer, t, s, 36064 + r, 3553), v(s, m) && _(3553, s, t.width, t.height)
			}
			n.unbindTexture()
		} else {
			let e = 3553;
			if (f && o) {
				e = l.isDataTexture3D ? 32879 : 35866
			}
			n.bindTexture(e, u.__webglTexture), A(e, l, m), I(c.__webglFramebuffer, t, l, 36064, e), v(l, m) && _(e, l, t.width, t.height, t.depth), n.unbindTexture()
		}
		t.depthBuffer && R(t)
	}, this.updateRenderTargetMipmap = function(e) {
		const t = g(e) || o,
			r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
		for (let s = 0, a = r.length; s < a; s++) {
			const a = r[s];
			if (v(a, t)) {
				const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
					r = i.get(a).__webglTexture;
				n.bindTexture(t, r), _(t, a, e.width, e.height), n.unbindTexture()
			}
		}
	}, this.updateMultisampleRenderTarget = function(t) {
		if (t.isWebGLMultisampleRenderTarget && o) {
			const r = t.width,
				s = t.height;
			let a = 16384;
			t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024);
			const o = i.get(t);
			n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, o.__webglFramebuffer), e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer)
		}
	}, this.safeSetTexture2D = function(e, t) {
		e && e.isWebGLRenderTarget && (!1 === N && (N = !0), e = e.texture), M(e, t)
	}, this.safeSetTextureCube = function(e, t) {
		e && e.isWebGLCubeRenderTarget && (!1 === O && (O = !0), e = e.texture), T(e, t)
	}
}

function zT(e, t, n) {
	const i = n.isWebGL2;
	return {
		convert: function(e) {
			let n;
			if (1009 === e) return 5121;
			if (1017 === e) return 32819;
			if (1018 === e) return 32820;
			if (1019 === e) return 33635;
			if (1010 === e) return 5120;
			if (1011 === e) return 5122;
			if (1012 === e) return 5123;
			if (1013 === e) return 5124;
			if (1014 === e) return 5125;
			if (1015 === e) return 5126;
			if (1016 === e) return i ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
			if (1021 === e) return 6406;
			if (1022 === e) return 6407;
			if (1023 === e) return 6408;
			if (1024 === e) return 6409;
			if (1025 === e) return 6410;
			if (1026 === e) return 6402;
			if (1027 === e) return 34041;
			if (1028 === e) return 6403;
			if (1029 === e) return 36244;
			if (1030 === e) return 33319;
			if (1031 === e) return 33320;
			if (1032 === e) return 36248;
			if (1033 === e) return 36249;
			if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
				if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
				if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
			}
			if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
				if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
				if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
			}
			if (36196 === e) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
			if ((37492 === e || 37496 === e) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) {
				if (37492 === e) return n.COMPRESSED_RGB8_ETC2;
				if (37496 === e) return n.COMPRESSED_RGBA8_ETC2_EAC
			}
			return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : 36492 === e ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : 1020 === e ? i ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
		}
	}
}
class UT extends Xw {
	constructor(e = []) {
		super(), this.cameras = e
	}
}
UT.prototype.isArrayCamera = !0;
class BT extends Bb {
	constructor() {
		super(), this.type = "Group"
	}
}
BT.prototype.isGroup = !0;
const VT = {
	type: "move"
};
class HT {
	constructor() {
		this._targetRay = null, this._grip = null, this._hand = null
	}
	getHandSpace() {
		return null === this._hand && (this._hand = new BT, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
			pinching: !1
		}), this._hand
	}
	getTargetRaySpace() {
		return null === this._targetRay && (this._targetRay = new BT, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new zx, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new zx), this._targetRay
	}
	getGripSpace() {
		return null === this._grip && (this._grip = new BT, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new zx, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new zx), this._grip
	}
	dispatchEvent(e) {
		return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
	}
	disconnect(e) {
		return this.dispatchEvent({
			type: "disconnected",
			data: e
		}), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
	}
	update(e, t, n) {
		let i = null,
			r = null,
			s = null;
		const a = this._targetRay,
			o = this._grip,
			l = this._hand;
		if (e && "visible-blurred" !== t.session.visibilityState)
			if (null !== a && (i = t.getPose(e.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(VT))), l && e.hand) {
				s = !0;
				for (const s of e.hand.values()) {
					const e = t.getJointPose(s, n);
					if (void 0 === l.joints[s.jointName]) {
						const e = new BT;
						e.matrixAutoUpdate = !1, e.visible = !1, l.joints[s.jointName] = e, l.add(e)
					}
					const i = l.joints[s.jointName];
					null !== e && (i.matrix.fromArray(e.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = e.radius), i.visible = null !== e
				}
				const i = l.joints["index-finger-tip"],
					r = l.joints["thumb-tip"],
					a = i.position.distanceTo(r.position),
					o = .02,
					c = .005;
				l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
					type: "pinchend",
					handedness: e.handedness,
					target: this
				})) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
					type: "pinchstart",
					handedness: e.handedness,
					target: this
				}))
			} else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
		return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
	}
}
class GT extends gx {
	constructor(e, t) {
		super();
		const n = this,
			i = e.state;
		let r = null,
			s = 1,
			a = null,
			o = "local-floor",
			l = null,
			c = null,
			u = null,
			h = null,
			d = null,
			p = !1,
			f = null,
			m = null,
			g = null,
			v = null,
			_ = null,
			y = null;
		const x = e.extensions.has("EXT_multisampled_render_to_texture");
		let b = null;
		const w = [],
			S = new Map,
			M = new Xw;
		M.layers.enable(1), M.viewport = new kx;
		const T = new Xw;
		T.layers.enable(2), T.viewport = new kx;
		const C = [M, T],
			E = new UT;
		E.layers.enable(1), E.layers.enable(2);
		let A = null,
			P = null;

		function L(e) {
			const t = S.get(e.inputSource);
			t && t.dispatchEvent({
				type: e.type,
				data: e.inputSource
			})
		}

		function I() {
			S.forEach((function(e, t) {
				e.disconnect(t)
			})), S.clear(), A = null, P = null, i.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), u && t.deleteFramebuffer(u), f && t.deleteFramebuffer(f), m && t.deleteRenderbuffer(m), g && t.deleteRenderbuffer(g), u = null, f = null, m = null, g = null, d = null, h = null, c = null, r = null, F.stop(), n.isPresenting = !1, n.dispatchEvent({
				type: "sessionend"
			})
		}

		function D(e) {
			const t = r.inputSources;
			for (let n = 0; n < w.length; n++) S.set(t[n], w[n]);
			for (let n = 0; n < e.removed.length; n++) {
				const t = e.removed[n],
					i = S.get(t);
				i && (i.dispatchEvent({
					type: "disconnected",
					data: t
				}), S.delete(t))
			}
			for (let n = 0; n < e.added.length; n++) {
				const t = e.added[n],
					i = S.get(t);
				i && i.dispatchEvent({
					type: "connected",
					data: t
				})
			}
		}
		this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
			let t = w[e];
			return void 0 === t && (t = new HT, w[e] = t), t.getTargetRaySpace()
		}, this.getControllerGrip = function(e) {
			let t = w[e];
			return void 0 === t && (t = new HT, w[e] = t), t.getGripSpace()
		}, this.getHand = function(e) {
			let t = w[e];
			return void 0 === t && (t = new HT, w[e] = t), t.getHandSpace()
		}, this.setFramebufferScaleFactor = function(e) {
			s = e, n.isPresenting
		}, this.setReferenceSpaceType = function(e) {
			o = e, n.isPresenting
		}, this.getReferenceSpace = function() {
			return a
		}, this.getBaseLayer = function() {
			return null !== h ? h : d
		}, this.getBinding = function() {
			return c
		}, this.getFrame = function() {
			return v
		}, this.getSession = function() {
			return r
		}, this.setSession = async function(l) {
			if (r = l, null !== r) {
				r.addEventListener("select", L), r.addEventListener("selectstart", L), r.addEventListener("selectend", L), r.addEventListener("squeeze", L), r.addEventListener("squeezestart", L), r.addEventListener("squeezeend", L), r.addEventListener("end", I), r.addEventListener("inputsourceschange", D);
				const l = t.getContextAttributes();
				if (!0 !== l.xrCompatible && await t.makeXRCompatible(), void 0 === r.renderState.layers) {
					const e = {
						antialias: l.antialias,
						alpha: l.alpha,
						depth: l.depth,
						stencil: l.stencil,
						framebufferScaleFactor: s
					};
					d = new XRWebGLLayer(r, t, e), r.updateRenderState({
						baseLayer: d
					})
				} else if (t instanceof WebGLRenderingContext) {
					const e = {
						antialias: !0,
						alpha: l.alpha,
						depth: l.depth,
						stencil: l.stencil,
						framebufferScaleFactor: s
					};
					d = new XRWebGLLayer(r, t, e), r.updateRenderState({
						layers: [d]
					})
				} else {
					p = l.antialias;
					let n = null;
					l.depth && (y = 256, l.stencil && (y |= 1024), _ = l.stencil ? 33306 : 36096, n = l.stencil ? 35056 : 33190);
					const a = {
						colorFormat: l.alpha ? 32856 : 32849,
						depthFormat: n,
						scaleFactor: s
					};
					c = new XRWebGLBinding(r, t), h = c.createProjectionLayer(a), u = t.createFramebuffer(), r.updateRenderState({
						layers: [h]
					}), p && x ? b = e.extensions.get("EXT_multisampled_render_to_texture") : p && (f = t.createFramebuffer(), m = t.createRenderbuffer(), t.bindRenderbuffer(36161, m), t.renderbufferStorageMultisample(36161, 4, 32856, h.textureWidth, h.textureHeight), i.bindFramebuffer(36160, f), t.framebufferRenderbuffer(36160, 36064, 36161, m), t.bindRenderbuffer(36161, null), null !== n && (g = t.createRenderbuffer(), t.bindRenderbuffer(36161, g), t.renderbufferStorageMultisample(36161, 4, n, h.textureWidth, h.textureHeight), t.framebufferRenderbuffer(36160, _, 36161, g), t.bindRenderbuffer(36161, null)), i.bindFramebuffer(36160, null))
				}
				a = await r.requestReferenceSpace(o), F.setContext(r), F.start(), n.isPresenting = !0, n.dispatchEvent({
					type: "sessionstart"
				})
			}
		};
		const R = new zx,
			k = new zx;

		function N(e, t) {
			null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
		}
		this.updateCamera = function(e) {
			if (null === r) return;
			E.near = T.near = M.near = e.near, E.far = T.far = M.far = e.far, A === E.near && P === E.far || (r.updateRenderState({
				depthNear: E.near,
				depthFar: E.far
			}), A = E.near, P = E.far);
			const t = e.parent,
				n = E.cameras;
			N(E, t);
			for (let r = 0; r < n.length; r++) N(n[r], t);
			E.matrixWorld.decompose(E.position, E.quaternion, E.scale), e.position.copy(E.position), e.quaternion.copy(E.quaternion), e.scale.copy(E.scale), e.matrix.copy(E.matrix), e.matrixWorld.copy(E.matrixWorld);
			const i = e.children;
			for (let r = 0, s = i.length; r < s; r++) i[r].updateMatrixWorld(!0);
			2 === n.length ? function(e, t, n) {
				R.setFromMatrixPosition(t.matrixWorld), k.setFromMatrixPosition(n.matrixWorld);
				const i = R.distanceTo(k),
					r = t.projectionMatrix.elements,
					s = n.projectionMatrix.elements,
					a = r[14] / (r[10] - 1),
					o = r[14] / (r[10] + 1),
					l = (r[9] + 1) / r[5],
					c = (r[9] - 1) / r[5],
					u = (r[8] - 1) / r[0],
					h = (s[8] + 1) / s[0],
					d = a * u,
					p = a * h,
					f = i / (-u + h),
					m = f * -u;
				t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
				const g = a + f,
					v = o + f,
					_ = d - m,
					y = p + (i - m),
					x = l * o / v * g,
					b = c * o / v * g;
				e.projectionMatrix.makePerspective(_, y, x, b, g, v)
			}(E, M, T) : E.projectionMatrix.copy(M.projectionMatrix)
		}, this.getCamera = function() {
			return E
		}, this.getFoveation = function() {
			return null !== h ? h.fixedFoveation : null !== d ? d.fixedFoveation : void 0
		}, this.setFoveation = function(e) {
			null !== h && (h.fixedFoveation = e), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
		};
		let O = null;
		const F = new sS;
		F.setAnimationLoop((function(e, n) {
			if (l = n.getViewerPose(a), v = n, null !== l) {
				const e = l.views;
				null !== d && i.bindXRFramebuffer(d.framebuffer);
				let n = !1;
				e.length !== E.cameras.length && (E.cameras.length = 0, n = !0);
				for (let r = 0; r < e.length; r++) {
					const s = e[r];
					let a = null;
					if (null !== d) a = d.getViewport(s);
					else {
						const e = c.getViewSubImage(h, s);
						i.bindXRFramebuffer(u), p && x ? (void 0 !== e.depthStencilTexture && b.framebufferTexture2DMultisampleEXT(36160, _, 3553, e.depthStencilTexture, 0, 4), b.framebufferTexture2DMultisampleEXT(36160, 36064, 3553, e.colorTexture, 0, 4)) : (void 0 !== e.depthStencilTexture && t.framebufferTexture2D(36160, _, 3553, e.depthStencilTexture, 0), t.framebufferTexture2D(36160, 36064, 3553, e.colorTexture, 0)), a = e.viewport
					}
					const o = C[r];
					o.matrix.fromArray(s.transform.matrix), o.projectionMatrix.fromArray(s.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === r && E.matrix.copy(o.matrix), !0 === n && E.cameras.push(o)
				}
				p && !x && (i.bindXRFramebuffer(f), null !== y && t.clear(y))
			}
			const s = r.inputSources;
			for (let t = 0; t < w.length; t++) {
				const e = w[t],
					i = s[t];
				e.update(i, n, a)
			}
			if (O && O(e, n), p && !x) {
				const e = h.textureWidth,
					n = h.textureHeight;
				i.bindFramebuffer(36008, f), i.bindFramebuffer(36009, u), t.invalidateFramebuffer(36008, [_]), t.invalidateFramebuffer(36009, [_]), t.blitFramebuffer(0, 0, e, n, 0, 0, e, n, 16384, 9728), t.invalidateFramebuffer(36008, [36064]), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, null), i.bindFramebuffer(36160, f)
			}
			v = null
		})), this.setAnimationLoop = function(e) {
			O = e
		}, this.dispose = function() {}
	}
}

function WT(e) {
	function t(t, n) {
		t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
		const i = e.get(n).envMap;
		if (i) {
			t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio;
			const r = e.get(i).__maxMipLevel;
			void 0 !== r && (t.maxMipLevel.value = r)
		}
		let r, s;
		n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularTintMap ? r = n.specularTintMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap && (r = n.thicknessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix))
	}

	function n(t, n) {
		t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias);
		e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
	}
	return {
		refreshFogUniforms: function(e, t) {
			e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
		},
		refreshMaterialUniforms: function(e, i, r, s, a) {
			i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function(e, t) {
				t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
			}(e, i)) : i.isMeshToonMaterial ? (t(e, i), function(e, t) {
				t.gradientMap && (e.gradientMap.value = t.gradientMap);
				t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
				t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
				t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
			}(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function(e, t) {
				e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
				t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
				t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
			}(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function(e, t, i) {
				n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenTint.value.copy(t.sheenTint).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness);
				t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate()));
				t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationTint.value.copy(t.attenuationTint));
				e.specularIntensity.value = t.specularIntensity, e.specularTint.value.copy(t.specularTint), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
				t.specularTintMap && (e.specularTintMap.value = t.specularTintMap)
			}(e, i, a) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function(e, t) {
				t.matcap && (e.matcap.value = t.matcap);
				t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
				t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
			}(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function(e, t) {
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
			}(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function(e, t) {
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
				e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
			}(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function(e, t) {
				t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1));
				t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate());
				t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
			}(e, i)) : i.isLineBasicMaterial ? (function(e, t) {
				e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
			}(e, i), i.isLineDashedMaterial && function(e, t) {
				e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
			}(e, i)) : i.isPointsMaterial ? function(e, t, n, i) {
				e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map);
				t.alphaMap && (e.alphaMap.value = t.alphaMap);
				t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
				let r;
				t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
				void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
			}(e, i, r, s) : i.isSpriteMaterial ? function(e, t) {
				e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map);
				t.alphaMap && (e.alphaMap.value = t.alphaMap);
				t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
				let n;
				t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
				void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
			}(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
		}
	}
}

function qT(e = {}) {
	const t = void 0 !== e.canvas ? e.canvas : function() {
			const e = Px("canvas");
			return e.style.display = "block", e
		}(),
		n = void 0 !== e.context ? e.context : null,
		i = void 0 !== e.alpha && e.alpha,
		r = void 0 === e.depth || e.depth,
		s = void 0 === e.stencil || e.stencil,
		a = void 0 !== e.antialias && e.antialias,
		o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
		l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
		c = void 0 !== e.powerPreference ? e.powerPreference : "default",
		u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
	let h = null,
		d = null;
	const p = [],
		f = [];
	this.domElement = t, this.debug = {
		checkShaderErrors: !0
	}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
	const m = this;
	let g = !1,
		v = 0,
		_ = 0,
		y = null,
		x = -1,
		b = null;
	const w = new kx,
		S = new kx;
	let M = null,
		T = t.width,
		C = t.height,
		E = 1,
		A = null,
		P = null;
	const L = new kx(0, 0, T, C),
		I = new kx(0, 0, T, C);
	let D = !1;
	const R = [],
		k = new rS;
	let N = !1,
		O = !1,
		F = null;
	const z = new mb,
		U = new zx,
		B = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: !0
		};

	function V() {
		return null === y ? E : 1
	}
	let H, G, W, q, j, Y, X, $, Z, K, J, Q, ee, te, ne, ie, re, se, ae, oe, le, ce, ue, he = n;

	function de(e, n) {
		for (let i = 0; i < e.length; i++) {
			const r = e[i],
				s = t.getContext(r, n);
			if (null !== s) return s
		}
		return null
	}
	try {
		const e = {
			alpha: i,
			depth: r,
			stencil: s,
			antialias: a,
			premultipliedAlpha: o,
			preserveDrawingBuffer: l,
			powerPreference: c,
			failIfMajorPerformanceCaveat: u
		};
		if (t.addEventListener("webglcontextlost", me, !1), t.addEventListener("webglcontextrestored", ge, !1), null === he) {
			const t = ["webgl2", "webgl", "experimental-webgl"];
			if (!0 === m.isWebGL1Renderer && t.shift(), he = de(t, e), null === he) throw de(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
		}
		void 0 === he.getShaderPrecisionFormat && (he.getShaderPrecisionFormat = function() {
			return {
				rangeMin: 1,
				rangeMax: 1,
				precision: 1
			}
		})
	} catch (Pe) {
		throw Pe
	}

	function pe() {
		H = new HS(he), G = new fS(he, H, e), H.init(G), ce = new zT(he, H, G), W = new OT(he, H, G), R[0] = 1029, q = new qS(he), j = new wT, Y = new FT(he, H, W, j, G, ce, q), X = new gS(m), $ = new VS(m), Z = new aS(he, G), ue = new dS(he, H, Z, G), K = new GS(he, Z, q, ue), J = new KS(he, K, Z, q), ae = new ZS(he, G, Y), ie = new mS(j), Q = new bT(m, X, $, H, G, ue, ie), ee = new WT(j), te = new CT(j), ne = new DT(H, G), se = new hS(m, X, W, J, o), re = new NT(m, J, G), oe = new pS(he, H, q, G), le = new WS(he, H, q, G), q.programs = Q.programs, m.capabilities = G, m.extensions = H, m.properties = j, m.renderLists = te, m.shadowMap = re, m.state = W, m.info = q
	}
	pe();
	const fe = new GT(m, he);

	function me(e) {
		e.preventDefault(), g = !0
	}

	function ge() {
		g = !1;
		const e = q.autoReset,
			t = re.enabled,
			n = re.autoUpdate,
			i = re.needsUpdate,
			r = re.type;
		pe(), q.autoReset = e, re.enabled = t, re.autoUpdate = n, re.needsUpdate = i, re.type = r
	}

	function ve(e) {
		const t = e.target;
		t.removeEventListener("dispose", ve),
			function(e) {
				(function(e) {
					const t = j.get(e).programs;
					void 0 !== t && t.forEach((function(e) {
						Q.releaseProgram(e)
					}))
				})(e), j.remove(e)
			}(t)
	}
	this.xr = fe, this.getContext = function() {
		return he
	}, this.getContextAttributes = function() {
		return he.getContextAttributes()
	}, this.forceContextLoss = function() {
		const e = H.get("WEBGL_lose_context");
		e && e.loseContext()
	}, this.forceContextRestore = function() {
		const e = H.get("WEBGL_lose_context");
		e && e.restoreContext()
	}, this.getPixelRatio = function() {
		return E
	}, this.setPixelRatio = function(e) {
		void 0 !== e && (E = e, this.setSize(T, C, !1))
	}, this.getSize = function(e) {
		return e.set(T, C)
	}, this.setSize = function(e, n, i) {
		fe.isPresenting || (T = e, C = n, t.width = Math.floor(e * E), t.height = Math.floor(n * E), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
	}, this.getDrawingBufferSize = function(e) {
		return e.set(T * E, C * E).floor()
	}, this.setDrawingBufferSize = function(e, n, i) {
		T = e, C = n, E = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
	}, this.getCurrentViewport = function(e) {
		return e.copy(w)
	}, this.getViewport = function(e) {
		return e.copy(L)
	}, this.setViewport = function(e, t, n, i) {
		e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, i), W.viewport(w.copy(L).multiplyScalar(E).floor())
	}, this.getScissor = function(e) {
		return e.copy(I)
	}, this.setScissor = function(e, t, n, i) {
		e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, n, i), W.scissor(S.copy(I).multiplyScalar(E).floor())
	}, this.getScissorTest = function() {
		return D
	}, this.setScissorTest = function(e) {
		W.setScissorTest(D = e)
	}, this.setOpaqueSort = function(e) {
		A = e
	}, this.setTransparentSort = function(e) {
		P = e
	}, this.getClearColor = function(e) {
		return e.copy(se.getClearColor())
	}, this.setClearColor = function() {
		se.setClearColor.apply(se, arguments)
	}, this.getClearAlpha = function() {
		return se.getClearAlpha()
	}, this.setClearAlpha = function() {
		se.setClearAlpha.apply(se, arguments)
	}, this.clear = function(e, t, n) {
		let i = 0;
		(void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), he.clear(i)
	}, this.clearColor = function() {
		this.clear(!0, !1, !1)
	}, this.clearDepth = function() {
		this.clear(!1, !0, !1)
	}, this.clearStencil = function() {
		this.clear(!1, !1, !0)
	}, this.dispose = function() {
		t.removeEventListener("webglcontextlost", me, !1), t.removeEventListener("webglcontextrestored", ge, !1), te.dispose(), ne.dispose(), j.dispose(), X.dispose(), $.dispose(), J.dispose(), ue.dispose(), fe.dispose(), fe.removeEventListener("sessionstart", ye), fe.removeEventListener("sessionend", xe), F && (F.dispose(), F = null), be.stop()
	}, this.renderBufferImmediate = function(e, t) {
		ue.initAttributes();
		const n = j.get(e);
		e.hasPositions && !n.position && (n.position = he.createBuffer()), e.hasNormals && !n.normal && (n.normal = he.createBuffer()), e.hasUvs && !n.uv && (n.uv = he.createBuffer()), e.hasColors && !n.color && (n.color = he.createBuffer());
		const i = t.getAttributes();
		e.hasPositions && (he.bindBuffer(34962, n.position), he.bufferData(34962, e.positionArray, 35048), ue.enableAttribute(i.position.location), he.vertexAttribPointer(i.position.location, 3, 5126, !1, 0, 0)), e.hasNormals && (he.bindBuffer(34962, n.normal), he.bufferData(34962, e.normalArray, 35048), ue.enableAttribute(i.normal.location), he.vertexAttribPointer(i.normal.location, 3, 5126, !1, 0, 0)), e.hasUvs && (he.bindBuffer(34962, n.uv), he.bufferData(34962, e.uvArray, 35048), ue.enableAttribute(i.uv.location), he.vertexAttribPointer(i.uv.location, 2, 5126, !1, 0, 0)), e.hasColors && (he.bindBuffer(34962, n.color), he.bufferData(34962, e.colorArray, 35048), ue.enableAttribute(i.color.location), he.vertexAttribPointer(i.color.location, 3, 5126, !1, 0, 0)), ue.disableUnusedAttributes(), he.drawArrays(4, 0, e.count), e.count = 0
	}, this.renderBufferDirect = function(e, t, n, i, r, s) {
		null === t && (t = B);
		const a = r.isMesh && r.matrixWorld.determinant() < 0,
			o = Ae(e, t, i, r);
		W.setMaterial(i, a);
		let l = n.index;
		const c = n.attributes.position;
		if (null === l) {
			if (void 0 === c || 0 === c.count) return
		} else if (0 === l.count) return;
		let u, h = 1;
		!0 === i.wireframe && (l = K.getWireframeAttribute(n), h = 2), void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || ae.update(r, n, i, o), ue.setup(r, i, o, n, l);
		let d = oe;
		null !== l && (u = Z.get(l), d = le, d.setIndex(u));
		const p = null !== l ? l.count : c.count,
			f = n.drawRange.start * h,
			m = n.drawRange.count * h,
			g = null !== s ? s.start * h : 0,
			v = null !== s ? s.count * h : Infinity,
			_ = Math.max(f, g),
			y = Math.min(p, f + m, g + v) - 1,
			x = Math.max(0, y - _ + 1);
		if (0 !== x) {
			if (r.isMesh) !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * V()), d.setMode(1)) : d.setMode(4);
			else if (r.isLine) {
				let e = i.linewidth;
				void 0 === e && (e = 1), W.setLineWidth(e * V()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
			} else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
			if (r.isInstancedMesh) d.renderInstances(_, x, r.count);
			else if (n.isInstancedBufferGeometry) {
				const e = Math.min(n.instanceCount, n._maxInstanceCount);
				d.renderInstances(_, x, e)
			} else d.render(_, x)
		}
	}, this.compile = function(e, t) {
		d = ne.get(e), d.init(), f.push(d), e.traverseVisible((function(e) {
			e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e))
		})), d.setupLights(m.physicallyCorrectLights), e.traverse((function(t) {
			const n = t.material;
			if (n)
				if (Array.isArray(n))
					for (let i = 0; i < n.length; i++) {
						Ce(n[i], e, t)
					} else Ce(n, e, t)
		})), f.pop(), d = null
	};
	let _e = null;

	function ye() {
		be.stop()
	}

	function xe() {
		be.start()
	}
	const be = new sS;

	function we(e, t, n, i) {
		if (!1 === e.visible) return;
		if (e.layers.test(t.layers))
			if (e.isGroup) n = e.renderOrder;
			else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
		else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e);
		else if (e.isSprite) {
			if (!e.frustumCulled || k.intersectsSprite(e)) {
				i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
				const t = J.update(e),
					r = e.material;
				r.visible && h.push(e, t, r, n, U.z, null)
			}
		} else if (e.isImmediateRenderObject) i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z), h.push(e, null, e.material, n, U.z, null);
		else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== q.render.frame && (e.skeleton.update(), e.skeleton.frame = q.render.frame), !e.frustumCulled || k.intersectsObject(e))) {
			i && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
			const t = J.update(e),
				r = e.material;
			if (Array.isArray(r)) {
				const i = t.groups;
				for (let s = 0, a = i.length; s < a; s++) {
					const a = i[s],
						o = r[a.materialIndex];
					o && o.visible && h.push(e, t, o, n, U.z, a)
				}
			} else r.visible && h.push(e, t, r, n, U.z, null)
		}
		const r = e.children;
		for (let s = 0, a = r.length; s < a; s++) we(r[s], t, n, i)
	}

	function Se(e, t, n, i) {
		const r = e.opaque,
			s = e.transmissive,
			o = e.transparent;
		d.setupLightsView(n), s.length > 0 && function(e, t, n) {
			if (null === F) {
				const e = !0 === a && !0 === G.isWebGL2;
				F = new(e ? Ox : Nx)(1024, 1024, {
					generateMipmaps: !0,
					type: null !== ce.convert(1016) ? 1016 : 1009,
					minFilter: 1008,
					magFilter: 1003,
					wrapS: 1001,
					wrapT: 1001
				})
			}
			const i = m.getRenderTarget();
			m.setRenderTarget(F), m.clear();
			const r = m.toneMapping;
			m.toneMapping = 0, Me(e, t, n), m.toneMapping = r, Y.updateMultisampleRenderTarget(F), Y.updateRenderTargetMipmap(F), m.setRenderTarget(i)
		}(r, t, n), i && W.viewport(w.copy(i)), r.length > 0 && Me(r, t, n), s.length > 0 && Me(s, t, n), o.length > 0 && Me(o, t, n)
	}

	function Me(e, t, n) {
		const i = !0 === t.isScene ? t.overrideMaterial : null;
		for (let r = 0, s = e.length; r < s; r++) {
			const s = e[r],
				a = s.object,
				o = s.geometry,
				l = null === i ? s.material : i,
				c = s.group;
			a.layers.test(n.layers) && Te(a, t, n, o, l, c)
		}
	}

	function Te(e, t, n, i, r, s) {
		if (e.onBeforeRender(m, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(m, t, n, i, e, s), e.isImmediateRenderObject) {
			const i = Ae(n, t, r, e);
			W.setMaterial(r), ue.reset(),
				function(e, t) {
					e.render((function(e) {
						m.renderBufferImmediate(e, t)
					}))
				}(e, i)
		} else !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : m.renderBufferDirect(n, t, i, r, e, s);
		e.onAfterRender(m, t, n, i, r, s)
	}

	function Ce(e, t, n) {
		!0 !== t.isScene && (t = B);
		const i = j.get(e),
			r = d.state.lights,
			s = d.state.shadowsArray,
			a = r.state.version,
			o = Q.getParameters(e, r.state, s, t, n),
			l = Q.getProgramCacheKey(o);
		let c = i.programs;
		i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? $ : X).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", ve), c = new Map, i.programs = c);
		let u = c.get(l);
		if (void 0 !== u) {
			if (i.currentProgram === u && i.lightsStateVersion === a) return Ee(e, o), u
		} else o.uniforms = Q.getUniforms(e), e.onBuild(o, m), e.onBeforeCompile(o, m), u = Q.acquireProgram(o, l), c.set(l, u), i.uniforms = o.uniforms;
		const h = i.uniforms;
		(e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = ie.uniform), Ee(e, o), i.needsLights = function(e) {
			return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
		}(e), i.lightsStateVersion = a, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
		const p = u.getUniforms(),
			f = eT.seqWithValue(p.seq, h);
		return i.currentProgram = u, i.uniformsList = f, u
	}

	function Ee(e, t) {
		const n = j.get(e);
		n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents
	}

	function Ae(e, t, n, i) {
		!0 !== t.isScene && (t = B), Y.resetTextureUnits();
		const r = t.fog,
			s = n.isMeshStandardMaterial ? t.environment : null,
			a = null === y ? m.outputEncoding : y.texture.encoding,
			o = (n.isMeshStandardMaterial ? $ : X).get(n.envMap || s),
			l = !0 === n.vertexColors && !!i.geometry && !!i.geometry.attributes.color && 4 === i.geometry.attributes.color.itemSize,
			c = !!n.normalMap && !!i.geometry && !!i.geometry.attributes.tangent,
			u = !!i.geometry && !!i.geometry.morphAttributes.position,
			h = !!i.geometry && !!i.geometry.morphAttributes.normal,
			p = i.geometry && i.geometry.morphAttributes.position ? i.geometry.morphAttributes.position.length : 0,
			f = j.get(n),
			g = d.state.lights;
		if (!0 === N && (!0 === O || e !== b)) {
			const t = e === b && n.id === x;
			ie.setState(n, e, t)
		}
		let v = !1;
		n.version === f.__version ? f.needsLights && f.lightsStateVersion !== g.state.version || f.outputEncoding !== a || i.isInstancedMesh && !1 === f.instancing ? v = !0 : i.isInstancedMesh || !0 !== f.instancing ? i.isSkinnedMesh && !1 === f.skinning ? v = !0 : i.isSkinnedMesh || !0 !== f.skinning ? f.envMap !== o || n.fog && f.fog !== r ? v = !0 : void 0 === f.numClippingPlanes || f.numClippingPlanes === ie.numPlanes && f.numIntersection === ie.numIntersection ? (f.vertexAlphas !== l || f.vertexTangents !== c || f.morphTargets !== u || f.morphNormals !== h || !0 === G.isWebGL2 && f.morphTargetsCount !== p) && (v = !0) : v = !0 : v = !0 : v = !0 : (v = !0, f.__version = n.version);
		let _ = f.currentProgram;
		!0 === v && (_ = Ce(n, t, i));
		let w = !1,
			S = !1,
			M = !1;
		const T = _.getUniforms(),
			A = f.uniforms;
		if (W.useProgram(_.program) && (w = !0, S = !0, M = !0), n.id !== x && (x = n.id, S = !0), w || b !== e) {
			if (T.setValue(he, "projectionMatrix", e.projectionMatrix), G.logarithmicDepthBuffer && T.setValue(he, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), b !== e && (b = e, S = !0, M = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
				const t = T.map.cameraPosition;
				void 0 !== t && t.setValue(he, U.setFromMatrixPosition(e.matrixWorld))
			}(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && T.setValue(he, "isOrthographic", !0 === e.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || i.isSkinnedMesh) && T.setValue(he, "viewMatrix", e.matrixWorldInverse)
		}
		if (i.isSkinnedMesh) {
			T.setOptional(he, i, "bindMatrix"), T.setOptional(he, i, "bindMatrixInverse");
			const e = i.skeleton;
			e && (G.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), T.setValue(he, "boneTexture", e.boneTexture, Y), T.setValue(he, "boneTextureSize", e.boneTextureSize)) : T.setOptional(he, e, "boneMatrices"))
		}
		var P, L;
		return (S || f.receiveShadow !== i.receiveShadow) && (f.receiveShadow = i.receiveShadow, T.setValue(he, "receiveShadow", i.receiveShadow)), S && (T.setValue(he, "toneMappingExposure", m.toneMappingExposure), f.needsLights && (L = M, (P = A).ambientLightColor.needsUpdate = L, P.lightProbe.needsUpdate = L, P.directionalLights.needsUpdate = L, P.directionalLightShadows.needsUpdate = L, P.pointLights.needsUpdate = L, P.pointLightShadows.needsUpdate = L, P.spotLights.needsUpdate = L, P.spotLightShadows.needsUpdate = L, P.rectAreaLights.needsUpdate = L, P.hemisphereLights.needsUpdate = L), r && n.fog && ee.refreshFogUniforms(A, r), ee.refreshMaterialUniforms(A, n, E, C, F), eT.upload(he, f.uniformsList, A, Y)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (eT.upload(he, f.uniformsList, A, Y), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && T.setValue(he, "center", i.center), T.setValue(he, "modelViewMatrix", i.modelViewMatrix), T.setValue(he, "normalMatrix", i.normalMatrix), T.setValue(he, "modelMatrix", i.matrixWorld), _
	}
	be.setAnimationLoop((function(e) {
		_e && _e(e)
	})), "undefined" != typeof window && be.setContext(window), this.setAnimationLoop = function(e) {
		_e = e, fe.setAnimationLoop(e), null === e ? be.stop() : be.start()
	}, fe.addEventListener("sessionstart", ye), fe.addEventListener("sessionend", xe), this.render = function(e, t) {
		if (void 0 !== t && !0 !== t.isCamera) return;
		if (!0 === g) return;
		!0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === fe.enabled && !0 === fe.isPresenting && (!0 === fe.cameraAutoUpdate && fe.updateCamera(t), t = fe.getCamera()), !0 === e.isScene && e.onBeforeRender(m, e, t, y), d = ne.get(e, f.length), d.init(), f.push(d), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), k.setFromProjectionMatrix(z), O = this.localClippingEnabled, N = ie.init(this.clippingPlanes, O, t), h = te.get(e, p.length), h.init(), p.push(h), we(e, t, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(A, P), !0 === N && ie.beginShadows();
		const n = d.state.shadowsArray;
		if (re.render(n, e, t), !0 === N && ie.endShadows(), !0 === this.info.autoReset && this.info.reset(), se.render(h, e), d.setupLights(m.physicallyCorrectLights), t.isArrayCamera) {
			const n = t.cameras;
			for (let t = 0, i = n.length; t < i; t++) {
				const i = n[t];
				Se(h, e, i, i.viewport)
			}
		} else Se(h, e, t);
		null !== y && (Y.updateMultisampleRenderTarget(y), Y.updateRenderTargetMipmap(y)), !0 === e.isScene && e.onAfterRender(m, e, t), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1), ue.resetDefaultState(), x = -1, b = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null
	}, this.getActiveCubeFace = function() {
		return v
	}, this.getActiveMipmapLevel = function() {
		return _
	}, this.getRenderTarget = function() {
		return y
	}, this.setRenderTarget = function(e, t = 0, n = 0) {
		y = e, v = t, _ = n, e && void 0 === j.get(e).__webglFramebuffer && Y.setupRenderTarget(e);
		let i = null,
			r = !1,
			s = !1;
		if (e) {
			const n = e.texture;
			(n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
			const a = j.get(e).__webglFramebuffer;
			e.isWebGLCubeRenderTarget ? (i = a[t], r = !0) : i = e.isWebGLMultisampleRenderTarget ? j.get(e).__webglMultisampledFramebuffer : a, w.copy(e.viewport), S.copy(e.scissor), M = e.scissorTest
		} else w.copy(L).multiplyScalar(E).floor(), S.copy(I).multiplyScalar(E).floor(), M = D;
		if (W.bindFramebuffer(36160, i) && G.drawBuffers) {
			let t = !1;
			if (e)
				if (e.isWebGLMultipleRenderTargets) {
					const n = e.texture;
					if (R.length !== n.length || 36064 !== R[0]) {
						for (let e = 0, t = n.length; e < t; e++) R[e] = 36064 + e;
						R.length = n.length, t = !0
					}
				} else 1 === R.length && 36064 === R[0] || (R[0] = 36064, R.length = 1, t = !0);
			else 1 === R.length && 1029 === R[0] || (R[0] = 1029, R.length = 1, t = !0);
			t && (G.isWebGL2 ? he.drawBuffers(R) : H.get("WEBGL_draw_buffers").drawBuffersWEBGL(R))
		}
		if (W.viewport(w), W.scissor(S), W.setScissorTest(M), r) {
			const i = j.get(e.texture);
			he.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
		} else if (s) {
			const i = j.get(e.texture),
				r = t || 0;
			he.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
		}
		x = -1
	}, this.readRenderTargetPixels = function(e, t, n, i, r, s, a) {
		if (!e || !e.isWebGLRenderTarget) return;
		let o = j.get(e).__webglFramebuffer;
		if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
			W.bindFramebuffer(36160, o);
			try {
				const a = e.texture,
					o = a.format,
					l = a.type;
				if (1023 !== o && ce.convert(o) !== he.getParameter(35739)) return;
				const c = 1016 === l && (H.has("EXT_color_buffer_half_float") || G.isWebGL2 && H.has("EXT_color_buffer_float"));
				if (!(1009 === l || ce.convert(l) === he.getParameter(35738) || 1015 === l && (G.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || c)) return;
				36053 === he.checkFramebufferStatus(36160) && t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && he.readPixels(t, n, i, r, ce.convert(o), ce.convert(l), s)
			} finally {
				const e = null !== y ? j.get(y).__webglFramebuffer : null;
				W.bindFramebuffer(36160, e)
			}
		}
	}, this.copyFramebufferToTexture = function(e, t, n = 0) {
		const i = Math.pow(2, -n),
			r = Math.floor(t.image.width * i),
			s = Math.floor(t.image.height * i);
		let a = ce.convert(t.format);
		G.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)), Y.setTexture2D(t, 0), he.copyTexImage2D(3553, n, a, e.x, e.y, r, s, 0), W.unbindTexture()
	}, this.copyTextureToTexture = function(e, t, n, i = 0) {
		const r = t.image.width,
			s = t.image.height,
			a = ce.convert(n.format),
			o = ce.convert(n.type);
		Y.setTexture2D(n, 0), he.pixelStorei(37440, n.flipY), he.pixelStorei(37441, n.premultiplyAlpha), he.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? he.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? he.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : he.texSubImage2D(3553, i, e.x, e.y, a, o, t.image), 0 === i && n.generateMipmaps && he.generateMipmap(3553), W.unbindTexture()
	}, this.copyTextureToTexture3D = function(e, t, n, i, r = 0) {
		if (m.isWebGL1Renderer) return;
		const s = e.max.x - e.min.x + 1,
			a = e.max.y - e.min.y + 1,
			o = e.max.z - e.min.z + 1,
			l = ce.convert(i.format),
			c = ce.convert(i.type);
		let u;
		if (i.isDataTexture3D) Y.setTexture3D(i, 0), u = 32879;
		else {
			if (!i.isDataTexture2DArray) return;
			Y.setTexture2DArray(i, 0), u = 35866
		}
		he.pixelStorei(37440, i.flipY), he.pixelStorei(37441, i.premultiplyAlpha), he.pixelStorei(3317, i.unpackAlignment);
		const h = he.getParameter(3314),
			d = he.getParameter(32878),
			p = he.getParameter(3316),
			f = he.getParameter(3315),
			g = he.getParameter(32877),
			v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
		he.pixelStorei(3314, v.width), he.pixelStorei(32878, v.height), he.pixelStorei(3316, e.min.x), he.pixelStorei(3315, e.min.y), he.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v.data) : n.isCompressedTexture ? he.compressedTexSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, v.data) : he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v), he.pixelStorei(3314, h), he.pixelStorei(32878, d), he.pixelStorei(3316, p), he.pixelStorei(3315, f), he.pixelStorei(32877, g), 0 === r && i.generateMipmaps && he.generateMipmap(u), W.unbindTexture()
	}, this.initTexture = function(e) {
		Y.setTexture2D(e, 0), W.unbindTexture()
	}, this.resetState = function() {
		v = 0, _ = 0, y = null, W.reset(), ue.reset()
	}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
		detail: this
	}))
}
class jT {
	constructor(e, t = 1, n = 1e3) {
		this.name = "", this.color = new aw(e), this.near = t, this.far = n
	}
	clone() {
		return new jT(this.color, this.near, this.far)
	}
	toJSON() {
		return {
			type: "Fog",
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		}
	}
}
jT.prototype.isFog = !0;
class YT extends Bb {
	constructor() {
		super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	copy(e, t) {
		return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
	}
}
YT.prototype.isScene = !0;
class XT {
	constructor(e, t) {
		this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = 35044, this.updateRange = {
			offset: 0,
			count: -1
		}, this.version = 0, this.uuid = bx()
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		!0 === e && this.version++
	}
	setUsage(e) {
		return this.usage = e, this
	}
	copy(e) {
		return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
	}
	copyAt(e, t, n) {
		e *= this.stride, n *= t.stride;
		for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
		return this
	}
	set(e, t = 0) {
		return this.array.set(e, t), this
	}
	clone(e) {
		void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = bx()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
		const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
			n = new this.constructor(t, this.stride);
		return n.setUsage(this.usage), n
	}
	onUpload(e) {
		return this.onUploadCallback = e, this
	}
	toJSON(e) {
		return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = bx()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		}
	}
}
XT.prototype.isInterleavedBuffer = !0;
const $T = new zx;
class ZT {
	constructor(e, t, n, i = !1) {
		this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
	}
	get count() {
		return this.data.count
	}
	get array() {
		return this.data.array
	}
	set needsUpdate(e) {
		this.data.needsUpdate = e
	}
	applyMatrix4(e) {
		for (let t = 0, n = this.data.count; t < n; t++) $T.x = this.getX(t), $T.y = this.getY(t), $T.z = this.getZ(t), $T.applyMatrix4(e), this.setXYZ(t, $T.x, $T.y, $T.z);
		return this
	}
	applyNormalMatrix(e) {
		for (let t = 0, n = this.count; t < n; t++) $T.x = this.getX(t), $T.y = this.getY(t), $T.z = this.getZ(t), $T.applyNormalMatrix(e), this.setXYZ(t, $T.x, $T.y, $T.z);
		return this
	}
	transformDirection(e) {
		for (let t = 0, n = this.count; t < n; t++) $T.x = this.getX(t), $T.y = this.getY(t), $T.z = this.getZ(t), $T.transformDirection(e), this.setXYZ(t, $T.x, $T.y, $T.z);
		return this
	}
	setX(e, t) {
		return this.data.array[e * this.data.stride + this.offset] = t, this
	}
	setY(e, t) {
		return this.data.array[e * this.data.stride + this.offset + 1] = t, this
	}
	setZ(e, t) {
		return this.data.array[e * this.data.stride + this.offset + 2] = t, this
	}
	setW(e, t) {
		return this.data.array[e * this.data.stride + this.offset + 3] = t, this
	}
	getX(e) {
		return this.data.array[e * this.data.stride + this.offset]
	}
	getY(e) {
		return this.data.array[e * this.data.stride + this.offset + 1]
	}
	getZ(e) {
		return this.data.array[e * this.data.stride + this.offset + 2]
	}
	getW(e) {
		return this.data.array[e * this.data.stride + this.offset + 3]
	}
	setXY(e, t, n) {
		return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
	}
	setXYZ(e, t, n, i) {
		return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
	}
	setXYZW(e, t, n, i, r) {
		return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
	}
	clone(e) {
		if (void 0 === e) {
			const e = [];
			for (let t = 0; t < this.count; t++) {
				const n = t * this.data.stride + this.offset;
				for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
			}
			return new uw(new this.array.constructor(e), this.itemSize, this.normalized)
		}
		return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ZT(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
	}
	toJSON(e) {
		if (void 0 === e) {
			const e = [];
			for (let t = 0; t < this.count; t++) {
				const n = t * this.data.stride + this.offset;
				for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: e,
				normalized: this.normalized
			}
		}
		return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
			isInterleavedBufferAttribute: !0,
			itemSize: this.itemSize,
			data: this.data.uuid,
			offset: this.offset,
			normalized: this.normalized
		}
	}
}
ZT.prototype.isInterleavedBufferAttribute = !0;
const KT = new zx,
	JT = new kx,
	QT = new kx,
	eC = new zx,
	tC = new mb;
class nC extends Bw {
	constructor(e, t) {
		super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new mb, this.bindMatrixInverse = new mb
	}
	copy(e) {
		return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
	}
	bind(e, t) {
		this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
	}
	pose() {
		this.skeleton.pose()
	}
	normalizeSkinWeights() {
		const e = new kx,
			t = this.geometry.attributes.skinWeight;
		for (let n = 0, i = t.count; n < i; n++) {
			e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
			const i = 1 / e.manhattanLength();
			Infinity !== i ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
		}
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert()
	}
	boneTransform(e, t) {
		const n = this.skeleton,
			i = this.geometry;
		JT.fromBufferAttribute(i.attributes.skinIndex, e), QT.fromBufferAttribute(i.attributes.skinWeight, e), KT.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
		for (let r = 0; r < 4; r++) {
			const e = QT.getComponent(r);
			if (0 !== e) {
				const i = JT.getComponent(r);
				tC.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), t.addScaledVector(eC.copy(KT).applyMatrix4(tC), e)
			}
		}
		return t.applyMatrix4(this.bindMatrixInverse)
	}
}
nC.prototype.isSkinnedMesh = !0;
class iC extends Bb {
	constructor() {
		super(), this.type = "Bone"
	}
}
iC.prototype.isBone = !0;
class rC extends Dx {
	constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, u, h) {
		super(null, s, a, o, l, c, i, r, u, h), this.image = {
			data: e,
			width: t,
			height: n
		}, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
	}
}
rC.prototype.isDataTexture = !0;
const sC = new mb,
	aC = new mb;
class oC {
	constructor(e = [], t = []) {
		this.uuid = bx(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
	}
	init() {
		const e = this.bones,
			t = this.boneInverses;
		if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
		else if (e.length !== t.length) {
			this.boneInverses = [];
			for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new mb)
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const t = new mb;
			this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
		}
	}
	pose() {
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const t = this.bones[e];
			t && t.matrixWorld.copy(this.boneInverses[e]).invert()
		}
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const t = this.bones[e];
			t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
		}
	}
	update() {
		const e = this.bones,
			t = this.boneInverses,
			n = this.boneMatrices,
			i = this.boneTexture;
		for (let r = 0, s = e.length; r < s; r++) {
			const i = e[r] ? e[r].matrixWorld : aC;
			sC.multiplyMatrices(i, t[r]), sC.toArray(n, 16 * r)
		}
		null !== i && (i.needsUpdate = !0)
	}
	clone() {
		return new oC(this.bones, this.boneInverses)
	}
	computeBoneTexture() {
		let e = Math.sqrt(4 * this.bones.length);
		var t;
		t = e, e = Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)), e = Math.max(e, 4);
		const n = new Float32Array(e * e * 4);
		n.set(this.boneMatrices);
		const i = new rC(n, e, e, 1023, 1015);
		return this.boneMatrices = n, this.boneTexture = i, this.boneTextureSize = e, this
	}
	getBoneByName(e) {
		for (let t = 0, n = this.bones.length; t < n; t++) {
			const n = this.bones[t];
			if (n.name === e) return n
		}
	}
	dispose() {
		null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
	}
	fromJSON(e, t) {
		this.uuid = e.uuid;
		for (let n = 0, i = e.bones.length; n < i; n++) {
			let i = t[e.bones[n]];
			void 0 === i && (i = new iC), this.bones.push(i), this.boneInverses.push((new mb).fromArray(e.boneInverses[n]))
		}
		return this.init(), this
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.5,
				type: "Skeleton",
				generator: "Skeleton.toJSON"
			},
			bones: [],
			boneInverses: []
		};
		e.uuid = this.uuid;
		const t = this.bones,
			n = this.boneInverses;
		for (let i = 0, r = t.length; i < r; i++) {
			const r = t[i];
			e.bones.push(r.uuid);
			const s = n[i];
			e.boneInverses.push(s.toArray())
		}
		return e
	}
}
class lC extends uw {
	constructor(e, t, n, i = 1) {
		"number" == typeof n && (i = n, n = !1), super(e, t, n), this.meshPerAttribute = i
	}
	copy(e) {
		return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
	}
	toJSON() {
		const e = super.toJSON();
		return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
	}
}
lC.prototype.isInstancedBufferAttribute = !0;
const cC = new mb,
	uC = new mb,
	hC = [],
	dC = new Bw;
class pC extends Bw {
	constructor(e, t, n) {
		super(e, t), this.instanceMatrix = new lC(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
	}
	copy(e) {
		return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
	}
	getColorAt(e, t) {
		t.fromArray(this.instanceColor.array, 3 * e)
	}
	getMatrixAt(e, t) {
		t.fromArray(this.instanceMatrix.array, 16 * e)
	}
	raycast(e, t) {
		const n = this.matrixWorld,
			i = this.count;
		if (dC.geometry = this.geometry, dC.material = this.material, void 0 !== dC.material)
			for (let r = 0; r < i; r++) {
				this.getMatrixAt(r, cC), uC.multiplyMatrices(n, cC), dC.matrixWorld = uC, dC.raycast(e, hC);
				for (let e = 0, n = hC.length; e < n; e++) {
					const n = hC[e];
					n.instanceId = r, n.object = this, t.push(n)
				}
				hC.length = 0
			}
	}
	setColorAt(e, t) {
		null === this.instanceColor && (this.instanceColor = new lC(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
	}
	setMatrixAt(e, t) {
		t.toArray(this.instanceMatrix.array, 16 * e)
	}
	updateMorphTargets() {}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
pC.prototype.isInstancedMesh = !0;
class fC extends Qb {
	constructor(e) {
		super(), this.type = "LineBasicMaterial", this.color = new aw(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
	}
}
fC.prototype.isLineBasicMaterial = !0;
const mC = new zx,
	gC = new zx,
	vC = new mb,
	_C = new fb,
	yC = new ab;
class xC extends Bb {
	constructor(e = new ww, t = new fC) {
		super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e) {
		return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			if (null === e.index) {
				const t = e.attributes.position,
					n = [0];
				for (let e = 1, i = t.count; e < i; e++) mC.fromBufferAttribute(t, e - 1), gC.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += mC.distanceTo(gC);
				e.setAttribute("lineDistance", new fw(n, 1))
			}
		} else e.isGeometry;
		return this
	}
	raycast(e, t) {
		const n = this.geometry,
			i = this.matrixWorld,
			r = e.params.Line.threshold,
			s = n.drawRange;
		if (null === n.boundingSphere && n.computeBoundingSphere(), yC.copy(n.boundingSphere), yC.applyMatrix4(i), yC.radius += r, !1 === e.ray.intersectsSphere(yC)) return;
		vC.copy(i).invert(), _C.copy(e.ray).applyMatrix4(vC);
		const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			o = a * a,
			l = new zx,
			c = new zx,
			u = new zx,
			h = new zx,
			d = this.isLineSegments ? 2 : 1;
		if (n.isBufferGeometry) {
			const i = n.index,
				r = n.attributes.position;
			if (null !== i) {
				for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) {
					const s = i.getX(n),
						a = i.getX(n + 1);
					l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);
					if (_C.distanceSqToSegment(l, c, h, u) > o) continue;
					h.applyMatrix4(this.matrixWorld);
					const d = e.ray.origin.distanceTo(h);
					d < e.near || d > e.far || t.push({
						distance: d,
						point: u.clone().applyMatrix4(this.matrixWorld),
						index: n,
						face: null,
						faceIndex: null,
						object: this
					})
				}
			} else {
				for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) {
					l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
					if (_C.distanceSqToSegment(l, c, h, u) > o) continue;
					h.applyMatrix4(this.matrixWorld);
					const i = e.ray.origin.distanceTo(h);
					i < e.near || i > e.far || t.push({
						distance: i,
						point: u.clone().applyMatrix4(this.matrixWorld),
						index: n,
						face: null,
						faceIndex: null,
						object: this
					})
				}
			}
		} else n.isGeometry
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				n = Object.keys(t);
			if (n.length > 0) {
				const e = t[n[0]];
				if (void 0 !== e) {
					this.morphTargetInfluences = [], this.morphTargetDictionary = {};
					for (let t = 0, n = e.length; t < n; t++) {
						const n = e[t].name || String(t);
						this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
					}
				}
			}
		} else {
			const t = e.morphTargets;
			void 0 !== t && t.length
		}
	}
}
xC.prototype.isLine = !0;
const bC = new zx,
	wC = new zx;
class SC extends xC {
	constructor(e, t) {
		super(e, t), this.type = "LineSegments"
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			if (null === e.index) {
				const t = e.attributes.position,
					n = [];
				for (let e = 0, i = t.count; e < i; e += 2) bC.fromBufferAttribute(t, e), wC.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + bC.distanceTo(wC);
				e.setAttribute("lineDistance", new fw(n, 1))
			}
		} else e.isGeometry;
		return this
	}
}
SC.prototype.isLineSegments = !0;
class MC extends xC {
	constructor(e, t) {
		super(e, t), this.type = "LineLoop"
	}
}
MC.prototype.isLineLoop = !0;
class TC extends Qb {
	constructor(e) {
		super(), this.type = "PointsMaterial", this.color = new aw(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
	}
}
TC.prototype.isPointsMaterial = !0;
const CC = new mb,
	EC = new fb,
	AC = new ab,
	PC = new zx;
class LC extends Bb {
	constructor(e = new ww, t = new TC) {
		super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
	}
	copy(e) {
		return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
	}
	raycast(e, t) {
		const n = this.geometry,
			i = this.matrixWorld,
			r = e.params.Points.threshold,
			s = n.drawRange;
		if (null === n.boundingSphere && n.computeBoundingSphere(), AC.copy(n.boundingSphere), AC.applyMatrix4(i), AC.radius += r, !1 === e.ray.intersectsSphere(AC)) return;
		CC.copy(i).invert(), EC.copy(e.ray).applyMatrix4(CC);
		const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			o = a * a;
		if (n.isBufferGeometry) {
			const r = n.index,
				a = n.attributes.position;
			if (null !== r) {
				for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) {
					const s = r.getX(n);
					PC.fromBufferAttribute(a, s), IC(PC, s, o, i, e, t, this)
				}
			} else {
				for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++) PC.fromBufferAttribute(a, n), IC(PC, n, o, i, e, t, this)
			}
		}
	}
	updateMorphTargets() {
		const e = this.geometry;
		if (e.isBufferGeometry) {
			const t = e.morphAttributes,
				n = Object.keys(t);
			if (n.length > 0) {
				const e = t[n[0]];
				if (void 0 !== e) {
					this.morphTargetInfluences = [], this.morphTargetDictionary = {};
					for (let t = 0, n = e.length; t < n; t++) {
						const n = e[t].name || String(t);
						this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
					}
				}
			}
		} else {
			const t = e.morphTargets;
			void 0 !== t && t.length
		}
	}
}

function IC(e, t, n, i, r, s, a) {
	const o = EC.distanceSqToPoint(e);
	if (o < n) {
		const n = new zx;
		EC.closestPointToPoint(e, n), n.applyMatrix4(i);
		const l = r.ray.origin.distanceTo(n);
		if (l < r.near || l > r.far) return;
		s.push({
			distance: l,
			distanceToRay: Math.sqrt(o),
			point: n,
			index: t,
			face: null,
			object: a
		})
	}
}
LC.prototype.isPoints = !0;
class DC {
	constructor() {
		this.type = "Curve", this.arcLengthDivisions = 200
	}
	getPoint() {
		return null
	}
	getPointAt(e, t) {
		const n = this.getUtoTmapping(e);
		return this.getPoint(n, t)
	}
	getPoints(e = 5) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
		return t
	}
	getSpacedPoints(e = 5) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
		return t
	}
	getLength() {
		const e = this.getLengths();
		return e[e.length - 1]
	}
	getLengths(e = this.arcLengthDivisions) {
		if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
		this.needsUpdate = !1;
		const t = [];
		let n, i = this.getPoint(0),
			r = 0;
		t.push(0);
		for (let s = 1; s <= e; s++) n = this.getPoint(s / e), r += n.distanceTo(i), t.push(r), i = n;
		return this.cacheArcLengths = t, t
	}
	updateArcLengths() {
		this.needsUpdate = !0, this.getLengths()
	}
	getUtoTmapping(e, t) {
		const n = this.getLengths();
		let i = 0;
		const r = n.length;
		let s;
		s = t || e * n[r - 1];
		let a, o = 0,
			l = r - 1;
		for (; o <= l;)
			if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1;
			else {
				if (!(a > 0)) {
					l = i;
					break
				}
				l = i - 1
			} if (i = l, n[i] === s) return i / (r - 1);
		const c = n[i];
		return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
	}
	getTangent(e, t) {
		const n = 1e-4;
		let i = e - n,
			r = e + n;
		i < 0 && (i = 0), r > 1 && (r = 1);
		const s = this.getPoint(i),
			a = this.getPoint(r),
			o = t || (s.isVector2 ? new Cx : new zx);
		return o.copy(a).sub(s).normalize(), o
	}
	getTangentAt(e, t) {
		const n = this.getUtoTmapping(e);
		return this.getTangent(n, t)
	}
	computeFrenetFrames(e, t) {
		const n = new zx,
			i = [],
			r = [],
			s = [],
			a = new zx,
			o = new mb;
		for (let d = 0; d <= e; d++) {
			const t = d / e;
			i[d] = this.getTangentAt(t, new zx)
		}
		r[0] = new zx, s[0] = new zx;
		let l = Number.MAX_VALUE;
		const c = Math.abs(i[0].x),
			u = Math.abs(i[0].y),
			h = Math.abs(i[0].z);
		c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
		for (let d = 1; d <= e; d++) {
			if (r[d] = r[d - 1].clone(), s[d] = s[d - 1].clone(), a.crossVectors(i[d - 1], i[d]), a.length() > Number.EPSILON) {
				a.normalize();
				const e = Math.acos(wx(i[d - 1].dot(i[d]), -1, 1));
				r[d].applyMatrix4(o.makeRotationAxis(a, e))
			}
			s[d].crossVectors(i[d], r[d])
		}
		if (!0 === t) {
			let t = Math.acos(wx(r[0].dot(r[e]), -1, 1));
			t /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
			for (let n = 1; n <= e; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)), s[n].crossVectors(i[n], r[n])
		}
		return {
			tangents: i,
			normals: r,
			binormals: s
		}
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	copy(e) {
		return this.arcLengthDivisions = e.arcLengthDivisions, this
	}
	toJSON() {
		const e = {
			metadata: {
				version: 4.5,
				type: "Curve",
				generator: "Curve.toJSON"
			}
		};
		return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
	}
	fromJSON(e) {
		return this.arcLengthDivisions = e.arcLengthDivisions, this
	}
}
class RC extends DC {
	constructor(e = 0, t = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
		super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
	}
	getPoint(e, t) {
		const n = t || new Cx,
			i = 2 * Math.PI;
		let r = this.aEndAngle - this.aStartAngle;
		const s = Math.abs(r) < Number.EPSILON;
		for (; r < 0;) r += i;
		for (; r > i;) r -= i;
		r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
		const a = this.aStartAngle + e * r;
		let o = this.aX + this.xRadius * Math.cos(a),
			l = this.aY + this.yRadius * Math.sin(a);
		if (0 !== this.aRotation) {
			const e = Math.cos(this.aRotation),
				t = Math.sin(this.aRotation),
				n = o - this.aX,
				i = l - this.aY;
			o = n * e - i * t + this.aX, l = n * t + i * e + this.aY
		}
		return n.set(o, l)
	}
	copy(e) {
		return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
	}
	toJSON() {
		const e = super.toJSON();
		return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
	}
}
RC.prototype.isEllipseCurve = !0;
class kC extends RC {
	constructor(e, t, n, i, r, s) {
		super(e, t, n, n, i, r, s), this.type = "ArcCurve"
	}
}

function NC() {
	let e = 0,
		t = 0,
		n = 0,
		i = 0;

	function r(r, s, a, o) {
		e = r, t = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
	}
	return {
		initCatmullRom: function(e, t, n, i, s) {
			r(t, n, s * (n - e), s * (i - t))
		},
		initNonuniformCatmullRom: function(e, t, n, i, s, a, o) {
			let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a,
				c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
			l *= a, c *= a, r(t, n, l, c)
		},
		calc: function(r) {
			const s = r * r;
			return e + t * r + n * s + i * (s * r)
		}
	}
}
kC.prototype.isArcCurve = !0;
const OC = new zx,
	FC = new NC,
	zC = new NC,
	UC = new NC;
class BC extends DC {
	constructor(e = [], t = !1, n = "centripetal", i = .5) {
		super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
	}
	getPoint(e, t = new zx) {
		const n = t,
			i = this.points,
			r = i.length,
			s = (r - (this.closed ? 0 : 1)) * e;
		let a, o, l = Math.floor(s),
			c = s - l;
		this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (OC.subVectors(i[0], i[1]).add(i[0]), a = OC);
		const u = i[l % r],
			h = i[(l + 1) % r];
		if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (OC.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = OC), "centripetal" === this.curveType || "chordal" === this.curveType) {
			const e = "chordal" === this.curveType ? .5 : .25;
			let t = Math.pow(a.distanceToSquared(u), e),
				n = Math.pow(u.distanceToSquared(h), e),
				i = Math.pow(h.distanceToSquared(o), e);
			n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), FC.initNonuniformCatmullRom(a.x, u.x, h.x, o.x, t, n, i), zC.initNonuniformCatmullRom(a.y, u.y, h.y, o.y, t, n, i), UC.initNonuniformCatmullRom(a.z, u.z, h.z, o.z, t, n, i)
		} else "catmullrom" === this.curveType && (FC.initCatmullRom(a.x, u.x, h.x, o.x, this.tension), zC.initCatmullRom(a.y, u.y, h.y, o.y, this.tension), UC.initCatmullRom(a.z, u.z, h.z, o.z, this.tension));
		return n.set(FC.calc(c), zC.calc(c), UC.calc(c)), n
	}
	copy(e) {
		super.copy(e), this.points = [];
		for (let t = 0, n = e.points.length; t < n; t++) {
			const n = e.points[t];
			this.points.push(n.clone())
		}
		return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, n = this.points.length; t < n; t++) {
			const n = this.points[t];
			e.points.push(n.toArray())
		}
		return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
	}
	fromJSON(e) {
		super.fromJSON(e), this.points = [];
		for (let t = 0, n = e.points.length; t < n; t++) {
			const n = e.points[t];
			this.points.push((new zx).fromArray(n))
		}
		return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
	}
}

function VC(e, t, n, i, r) {
	const s = .5 * (i - t),
		a = .5 * (r - n),
		o = e * e;
	return (2 * n - 2 * i + s + a) * (e * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * e + n
}

function HC(e, t, n, i) {
	return function(e, t) {
		const n = 1 - e;
		return n * n * t
	}(e, t) + function(e, t) {
		return 2 * (1 - e) * e * t
	}(e, n) + function(e, t) {
		return e * e * t
	}(e, i)
}

function GC(e, t, n, i, r) {
	return function(e, t) {
		const n = 1 - e;
		return n * n * n * t
	}(e, t) + function(e, t) {
		const n = 1 - e;
		return 3 * n * n * e * t
	}(e, n) + function(e, t) {
		return 3 * (1 - e) * e * e * t
	}(e, i) + function(e, t) {
		return e * e * e * t
	}(e, r)
}
BC.prototype.isCatmullRomCurve3 = !0;
class WC extends DC {
	constructor(e = new Cx, t = new Cx, n = new Cx, i = new Cx) {
		super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
	}
	getPoint(e, t = new Cx) {
		const n = t,
			i = this.v0,
			r = this.v1,
			s = this.v2,
			a = this.v3;
		return n.set(GC(e, i.x, r.x, s.x, a.x), GC(e, i.y, r.y, s.y, a.y)), n
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
	}
	toJSON() {
		const e = super.toJSON();
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
	}
}
WC.prototype.isCubicBezierCurve = !0;
class qC extends DC {
	constructor(e = new zx, t = new zx, n = new zx, i = new zx) {
		super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
	}
	getPoint(e, t = new zx) {
		const n = t,
			i = this.v0,
			r = this.v1,
			s = this.v2,
			a = this.v3;
		return n.set(GC(e, i.x, r.x, s.x, a.x), GC(e, i.y, r.y, s.y, a.y), GC(e, i.z, r.z, s.z, a.z)), n
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
	}
	toJSON() {
		const e = super.toJSON();
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
	}
}
qC.prototype.isCubicBezierCurve3 = !0;
class jC extends DC {
	constructor(e = new Cx, t = new Cx) {
		super(), this.type = "LineCurve", this.v1 = e, this.v2 = t
	}
	getPoint(e, t = new Cx) {
		const n = t;
		return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
	}
	getPointAt(e, t) {
		return this.getPoint(e, t)
	}
	getTangent(e, t) {
		const n = t || new Cx;
		return n.copy(this.v2).sub(this.v1).normalize(), n
	}
	copy(e) {
		return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}
	toJSON() {
		const e = super.toJSON();
		return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}
}
jC.prototype.isLineCurve = !0;
class YC extends DC {
	constructor(e = new Cx, t = new Cx, n = new Cx) {
		super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
	}
	getPoint(e, t = new Cx) {
		const n = t,
			i = this.v0,
			r = this.v1,
			s = this.v2;
		return n.set(HC(e, i.x, r.x, s.x), HC(e, i.y, r.y, s.y)), n
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}
	toJSON() {
		const e = super.toJSON();
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}
}
YC.prototype.isQuadraticBezierCurve = !0;
class XC extends DC {
	constructor(e = new zx, t = new zx, n = new zx) {
		super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
	}
	getPoint(e, t = new zx) {
		const n = t,
			i = this.v0,
			r = this.v1,
			s = this.v2;
		return n.set(HC(e, i.x, r.x, s.x), HC(e, i.y, r.y, s.y), HC(e, i.z, r.z, s.z)), n
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}
	toJSON() {
		const e = super.toJSON();
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}
}
XC.prototype.isQuadraticBezierCurve3 = !0;
class $C extends DC {
	constructor(e = []) {
		super(), this.type = "SplineCurve", this.points = e
	}
	getPoint(e, t = new Cx) {
		const n = t,
			i = this.points,
			r = (i.length - 1) * e,
			s = Math.floor(r),
			a = r - s,
			o = i[0 === s ? s : s - 1],
			l = i[s],
			c = i[s > i.length - 2 ? i.length - 1 : s + 1],
			u = i[s > i.length - 3 ? i.length - 1 : s + 2];
		return n.set(VC(a, o.x, l.x, c.x, u.x), VC(a, o.y, l.y, c.y, u.y)), n
	}
	copy(e) {
		super.copy(e), this.points = [];
		for (let t = 0, n = e.points.length; t < n; t++) {
			const n = e.points[t];
			this.points.push(n.clone())
		}
		return this
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, n = this.points.length; t < n; t++) {
			const n = this.points[t];
			e.points.push(n.toArray())
		}
		return e
	}
	fromJSON(e) {
		super.fromJSON(e), this.points = [];
		for (let t = 0, n = e.points.length; t < n; t++) {
			const n = e.points[t];
			this.points.push((new Cx).fromArray(n))
		}
		return this
	}
}
$C.prototype.isSplineCurve = !0;
var ZC = Object.freeze({
	__proto__: null,
	[Symbol.toStringTag]: "Module",
	ArcCurve: kC,
	CatmullRomCurve3: BC,
	CubicBezierCurve: WC,
	CubicBezierCurve3: qC,
	EllipseCurve: RC,
	LineCurve: jC,
	LineCurve3: class extends DC {
		constructor(e = new zx, t = new zx) {
			super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t
		}
		getPoint(e, t = new zx) {
			const n = t;
			return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
		}
		getPointAt(e, t) {
			return this.getPoint(e, t)
		}
		copy(e) {
			return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
		}
		toJSON() {
			const e = super.toJSON();
			return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
		}
		fromJSON(e) {
			return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
		}
	},
	QuadraticBezierCurve: YC,
	QuadraticBezierCurve3: XC,
	SplineCurve: $C
});
class KC extends DC {
	constructor() {
		super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
	}
	add(e) {
		this.curves.push(e)
	}
	closePath() {
		const e = this.curves[0].getPoint(0),
			t = this.curves[this.curves.length - 1].getPoint(1);
		e.equals(t) || this.curves.push(new jC(t, e))
	}
	getPoint(e, t) {
		const n = e * this.getLength(),
			i = this.getCurveLengths();
		let r = 0;
		for (; r < i.length;) {
			if (i[r] >= n) {
				const e = i[r] - n,
					s = this.curves[r],
					a = s.getLength(),
					o = 0 === a ? 0 : 1 - e / a;
				return s.getPointAt(o, t)
			}
			r++
		}
		return null
	}
	getLength() {
		const e = this.getCurveLengths();
		return e[e.length - 1]
	}
	updateArcLengths() {
		this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
	}
	getCurveLengths() {
		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
		const e = [];
		let t = 0;
		for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
		return this.cacheLengths = e, e
	}
	getSpacedPoints(e = 40) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
		return this.autoClose && t.push(t[0]), t
	}
	getPoints(e = 12) {
		const t = [];
		let n;
		for (let i = 0, r = this.curves; i < r.length; i++) {
			const s = r[i],
				a = s && s.isEllipseCurve ? 2 * e : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? e * s.points.length : e,
				o = s.getPoints(a);
			for (let e = 0; e < o.length; e++) {
				const i = o[e];
				n && n.equals(i) || (t.push(i), n = i)
			}
		}
		return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
	}
	copy(e) {
		super.copy(e), this.curves = [];
		for (let t = 0, n = e.curves.length; t < n; t++) {
			const n = e.curves[t];
			this.curves.push(n.clone())
		}
		return this.autoClose = e.autoClose, this
	}
	toJSON() {
		const e = super.toJSON();
		e.autoClose = this.autoClose, e.curves = [];
		for (let t = 0, n = this.curves.length; t < n; t++) {
			const n = this.curves[t];
			e.curves.push(n.toJSON())
		}
		return e
	}
	fromJSON(e) {
		super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
		for (let t = 0, n = e.curves.length; t < n; t++) {
			const n = e.curves[t];
			this.curves.push((new ZC[n.type]).fromJSON(n))
		}
		return this
	}
}
class JC extends Qb {
	constructor(e) {
		super(), this.defines = {
			STANDARD: ""
		}, this.type = "MeshStandardMaterial", this.color = new aw(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new aw(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Cx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.defines = {
			STANDARD: ""
		}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
	}
}
JC.prototype.isMeshStandardMaterial = !0;
class QC extends JC {
	constructor(e) {
		super(), this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Cx(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
			get: function() {
				return wx(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
			},
			set: function(e) {
				this.ior = (1 + .4 * e) / (1 - .4 * e)
			}
		}), this.sheenTint = new aw(0), this.sheenRoughness = 1, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new aw(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new aw(1, 1, 1), this.specularTintMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
	}
	get sheen() {
		return this._sheen
	}
	set sheen(e) {
		this._sheen > 0 != e > 0 && this.version++, this._sheen = e
	}
	get clearcoat() {
		return this._clearcoat
	}
	set clearcoat(e) {
		this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
	}
	get transmission() {
		return this._transmission
	}
	set transmission(e) {
		this._transmission > 0 != e > 0 && this.version++, this._transmission = e
	}
	copy(e) {
		return super.copy(e), this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenTint.copy(e.sheenTint), this.sheenRoughness = e.sheenRoughness, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this
	}
}
QC.prototype.isMeshPhysicalMaterial = !0;
class eE extends Qb {
	constructor(e) {
		super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Cx(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
	}
}
eE.prototype.isMeshNormalMaterial = !0;
const tE = {
	arraySlice: function(e, t, n) {
		return tE.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
	},
	convertArray: function(e, t, n) {
		return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
	},
	isTypedArray: function(e) {
		return ArrayBuffer.isView(e) && !(e instanceof DataView)
	},
	getKeyframeOrder: function(e) {
		const t = e.length,
			n = new Array(t);
		for (let i = 0; i !== t; ++i) n[i] = i;
		return n.sort((function(t, n) {
			return e[t] - e[n]
		})), n
	},
	sortedArray: function(e, t, n) {
		const i = e.length,
			r = new e.constructor(i);
		for (let s = 0, a = 0; a !== i; ++s) {
			const i = n[s] * t;
			for (let n = 0; n !== t; ++n) r[a++] = e[i + n]
		}
		return r
	},
	flattenJSON: function(e, t, n, i) {
		let r = 1,
			s = e[0];
		for (; void 0 !== s && void 0 === s[i];) s = e[r++];
		if (void 0 === s) return;
		let a = s[i];
		if (void 0 !== a)
			if (Array.isArray(a))
				do {
					a = s[i], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[r++]
				} while (void 0 !== s);
			else if (void 0 !== a.toArray)
			do {
				a = s[i], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[r++]
			} while (void 0 !== s);
		else
			do {
				a = s[i], void 0 !== a && (t.push(s.time), n.push(a)), s = e[r++]
			} while (void 0 !== s)
	},
	subclip: function(e, t, n, i, r = 30) {
		const s = e.clone();
		s.name = t;
		const a = [];
		for (let l = 0; l < s.tracks.length; ++l) {
			const e = s.tracks[l],
				t = e.getValueSize(),
				o = [],
				c = [];
			for (let s = 0; s < e.times.length; ++s) {
				const a = e.times[s] * r;
				if (!(a < n || a >= i)) {
					o.push(e.times[s]);
					for (let n = 0; n < t; ++n) c.push(e.values[s * t + n])
				}
			}
			0 !== o.length && (e.times = tE.convertArray(o, e.times.constructor), e.values = tE.convertArray(c, e.values.constructor), a.push(e))
		}
		s.tracks = a;
		let o = Infinity;
		for (let l = 0; l < s.tracks.length; ++l) o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
		for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
		return s.resetDuration(), s
	},
	makeClipAdditive: function(e, t = 0, n = e, i = 30) {
		i <= 0 && (i = 30);
		const r = n.tracks.length,
			s = t / i;
		for (let a = 0; a < r; ++a) {
			const t = n.tracks[a],
				i = t.ValueTypeName;
			if ("bool" === i || "string" === i) continue;
			const r = e.tracks.find((function(e) {
				return e.name === t.name && e.ValueTypeName === i
			}));
			if (void 0 === r) continue;
			let o = 0;
			const l = t.getValueSize();
			t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
			let c = 0;
			const u = r.getValueSize();
			r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
			const h = t.times.length - 1;
			let d;
			if (s <= t.times[0]) {
				const e = o,
					n = l - o;
				d = tE.arraySlice(t.values, e, n)
			} else if (s >= t.times[h]) {
				const e = h * l + o,
					n = e + l - o;
				d = tE.arraySlice(t.values, e, n)
			} else {
				const e = t.createInterpolant(),
					n = o,
					i = l - o;
				e.evaluate(s), d = tE.arraySlice(e.resultBuffer, n, i)
			}
			if ("quaternion" === i) {
				(new Fx).fromArray(d).normalize().conjugate().toArray(d)
			}
			const p = r.times.length;
			for (let e = 0; e < p; ++e) {
				const t = e * u + c;
				if ("quaternion" === i) Fx.multiplyQuaternionsFlat(r.values, t, d, 0, r.values, t);
				else {
					const e = u - 2 * c;
					for (let n = 0; n < e; ++n) r.values[t + n] -= d[n]
				}
			}
		}
		return e.blendMode = 2501, e
	}
};
class nE {
	constructor(e, t, n, i) {
		this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
	}
	evaluate(e) {
		const t = this.parameterPositions;
		let n = this._cachedIndex,
			i = t[n],
			r = t[n - 1];
		e: {
			t: {
				let s;n: {
					i: if (!(e < i)) {
						for (let s = n + 2;;) {
							if (void 0 === i) {
								if (e < r) break i;
								return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
							}
							if (n === s) break;
							if (r = i, i = t[++n], e < i) break t
						}
						s = t.length;
						break n
					}if (e >= r) break e; {
						const a = t[1];
						e < a && (n = 2, r = a);
						for (let s = n - 2;;) {
							if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
							if (n === s) break;
							if (i = r, r = t[--n - 1], e >= r) break t
						}
						s = n, n = 0
					}
				}
				for (; n < s;) {
					const i = n + s >>> 1;
					e < t[i] ? s = i : n = i + 1
				}
				if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
				this.beforeStart_(0, e, i);
				if (void 0 === i) return n = t.length,
				this._cachedIndex = n,
				this.afterEnd_(n - 1, r, e)
			}
			this._cachedIndex = n,
			this.intervalChanged_(n, r, i)
		}
		return this.interpolate_(n, r, e, i)
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			n = this.sampleValues,
			i = this.valueSize,
			r = e * i;
		for (let s = 0; s !== i; ++s) t[s] = n[r + s];
		return t
	}
	interpolate_() {
		throw new Error("call to abstract method")
	}
	intervalChanged_() {}
}
nE.prototype.beforeStart_ = nE.prototype.copySampleValue_, nE.prototype.afterEnd_ = nE.prototype.copySampleValue_;
class iE extends nE {
	constructor(e, t, n, i) {
		super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
			endingStart: 2400,
			endingEnd: 2400
		}
	}
	intervalChanged_(e, t, n) {
		const i = this.parameterPositions;
		let r = e - 2,
			s = e + 1,
			a = i[r],
			o = i[s];
		if (void 0 === a) switch (this.getSettings_().endingStart) {
			case 2401:
				r = e, a = 2 * t - n;
				break;
			case 2402:
				r = i.length - 2, a = t + i[r] - i[r + 1];
				break;
			default:
				r = e, a = n
		}
		if (void 0 === o) switch (this.getSettings_().endingEnd) {
			case 2401:
				s = e, o = 2 * n - t;
				break;
			case 2402:
				s = 1, o = n + i[1] - i[0];
				break;
			default:
				s = e - 1, o = t
		}
		const l = .5 * (n - t),
			c = this.valueSize;
		this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c
	}
	interpolate_(e, t, n, i) {
		const r = this.resultBuffer,
			s = this.sampleValues,
			a = this.valueSize,
			o = e * a,
			l = o - a,
			c = this._offsetPrev,
			u = this._offsetNext,
			h = this._weightPrev,
			d = this._weightNext,
			p = (n - t) / (i - t),
			f = p * p,
			m = f * p,
			g = -h * m + 2 * h * f - h * p,
			v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
			_ = (-1 - d) * m + (1.5 + d) * f + .5 * p,
			y = d * m - d * f;
		for (let x = 0; x !== a; ++x) r[x] = g * s[c + x] + v * s[l + x] + _ * s[o + x] + y * s[u + x];
		return r
	}
}
class rE extends nE {
	constructor(e, t, n, i) {
		super(e, t, n, i)
	}
	interpolate_(e, t, n, i) {
		const r = this.resultBuffer,
			s = this.sampleValues,
			a = this.valueSize,
			o = e * a,
			l = o - a,
			c = (n - t) / (i - t),
			u = 1 - c;
		for (let h = 0; h !== a; ++h) r[h] = s[l + h] * u + s[o + h] * c;
		return r
	}
}
class sE extends nE {
	constructor(e, t, n, i) {
		super(e, t, n, i)
	}
	interpolate_(e) {
		return this.copySampleValue_(e - 1)
	}
}
class aE {
	constructor(e, t, n, i) {
		if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
		if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
		this.name = e, this.times = tE.convertArray(t, this.TimeBufferType), this.values = tE.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
	}
	static toJSON(e) {
		const t = e.constructor;
		let n;
		if (t.toJSON !== this.toJSON) n = t.toJSON(e);
		else {
			n = {
				name: e.name,
				times: tE.convertArray(e.times, Array),
				values: tE.convertArray(e.values, Array)
			};
			const t = e.getInterpolation();
			t !== e.DefaultInterpolation && (n.interpolation = t)
		}
		return n.type = e.ValueTypeName, n
	}
	InterpolantFactoryMethodDiscrete(e) {
		return new sE(this.times, this.values, this.getValueSize(), e)
	}
	InterpolantFactoryMethodLinear(e) {
		return new rE(this.times, this.values, this.getValueSize(), e)
	}
	InterpolantFactoryMethodSmooth(e) {
		return new iE(this.times, this.values, this.getValueSize(), e)
	}
	setInterpolation(e) {
		let t;
		switch (e) {
			case 2300:
				t = this.InterpolantFactoryMethodDiscrete;
				break;
			case 2301:
				t = this.InterpolantFactoryMethodLinear;
				break;
			case 2302:
				t = this.InterpolantFactoryMethodSmooth
		}
		if (void 0 === t) {
			const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (void 0 === this.createInterpolant) {
				if (e === this.DefaultInterpolation) throw new Error(t);
				this.setInterpolation(this.DefaultInterpolation)
			}
			return this
		}
		return this.createInterpolant = t, this
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return 2300;
			case this.InterpolantFactoryMethodLinear:
				return 2301;
			case this.InterpolantFactoryMethodSmooth:
				return 2302
		}
	}
	getValueSize() {
		return this.values.length / this.times.length
	}
	shift(e) {
		if (0 !== e) {
			const t = this.times;
			for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
		}
		return this
	}
	scale(e) {
		if (1 !== e) {
			const t = this.times;
			for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
		}
		return this
	}
	trim(e, t) {
		const n = this.times,
			i = n.length;
		let r = 0,
			s = i - 1;
		for (; r !== i && n[r] < e;) ++r;
		for (; - 1 !== s && n[s] > t;) --s;
		if (++s, 0 !== r || s !== i) {
			r >= s && (s = Math.max(s, 1), r = s - 1);
			const e = this.getValueSize();
			this.times = tE.arraySlice(n, r, s), this.values = tE.arraySlice(this.values, r * e, s * e)
		}
		return this
	}
	validate() {
		let e = !0;
		const t = this.getValueSize();
		t - Math.floor(t) != 0 && (e = !1);
		const n = this.times,
			i = this.values,
			r = n.length;
		0 === r && (e = !1);
		let s = null;
		for (let a = 0; a !== r; a++) {
			const t = n[a];
			if ("number" == typeof t && isNaN(t)) {
				e = !1;
				break
			}
			if (null !== s && s > t) {
				e = !1;
				break
			}
			s = t
		}
		if (void 0 !== i && tE.isTypedArray(i))
			for (let a = 0, o = i.length; a !== o; ++a) {
				const t = i[a];
				if (isNaN(t)) {
					e = !1;
					break
				}
			}
		return e
	}
	optimize() {
		const e = tE.arraySlice(this.times),
			t = tE.arraySlice(this.values),
			n = this.getValueSize(),
			i = 2302 === this.getInterpolation(),
			r = e.length - 1;
		let s = 1;
		for (let a = 1; a < r; ++a) {
			let r = !1;
			const o = e[a];
			if (o !== e[a + 1] && (1 !== a || o !== e[0]))
				if (i) r = !0;
				else {
					const e = a * n,
						i = e - n,
						s = e + n;
					for (let a = 0; a !== n; ++a) {
						const n = t[e + a];
						if (n !== t[i + a] || n !== t[s + a]) {
							r = !0;
							break
						}
					}
				} if (r) {
				if (a !== s) {
					e[s] = e[a];
					const i = a * n,
						r = s * n;
					for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
				}++s
			}
		}
		if (r > 0) {
			e[s] = e[r];
			for (let e = r * n, i = s * n, a = 0; a !== n; ++a) t[i + a] = t[e + a];
			++s
		}
		return s !== e.length ? (this.times = tE.arraySlice(e, 0, s), this.values = tE.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this
	}
	clone() {
		const e = tE.arraySlice(this.times, 0),
			t = tE.arraySlice(this.values, 0),
			n = new(0, this.constructor)(this.name, e, t);
		return n.createInterpolant = this.createInterpolant, n
	}
}
aE.prototype.TimeBufferType = Float32Array, aE.prototype.ValueBufferType = Float32Array, aE.prototype.DefaultInterpolation = 2301;
class oE extends aE {}
oE.prototype.ValueTypeName = "bool", oE.prototype.ValueBufferType = Array, oE.prototype.DefaultInterpolation = 2300, oE.prototype.InterpolantFactoryMethodLinear = void 0, oE.prototype.InterpolantFactoryMethodSmooth = void 0;
class lE extends aE {}
lE.prototype.ValueTypeName = "color";
class cE extends aE {}
cE.prototype.ValueTypeName = "number";
class uE extends nE {
	constructor(e, t, n, i) {
		super(e, t, n, i)
	}
	interpolate_(e, t, n, i) {
		const r = this.resultBuffer,
			s = this.sampleValues,
			a = this.valueSize,
			o = (n - t) / (i - t);
		let l = e * a;
		for (let c = l + a; l !== c; l += 4) Fx.slerpFlat(r, 0, s, l - a, s, l, o);
		return r
	}
}
class hE extends aE {
	InterpolantFactoryMethodLinear(e) {
		return new uE(this.times, this.values, this.getValueSize(), e)
	}
}
hE.prototype.ValueTypeName = "quaternion", hE.prototype.DefaultInterpolation = 2301, hE.prototype.InterpolantFactoryMethodSmooth = void 0;
class dE extends aE {}
dE.prototype.ValueTypeName = "string", dE.prototype.ValueBufferType = Array, dE.prototype.DefaultInterpolation = 2300, dE.prototype.InterpolantFactoryMethodLinear = void 0, dE.prototype.InterpolantFactoryMethodSmooth = void 0;
class pE extends aE {}
pE.prototype.ValueTypeName = "vector";
class fE {
	constructor(e, t = -1, n, i = 2500) {
		this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = bx(), this.duration < 0 && this.resetDuration()
	}
	static parse(e) {
		const t = [],
			n = e.tracks,
			i = 1 / (e.fps || 1);
		for (let s = 0, a = n.length; s !== a; ++s) t.push(mE(n[s]).scale(i));
		const r = new this(e.name, e.duration, t, e.blendMode);
		return r.uuid = e.uuid, r
	}
	static toJSON(e) {
		const t = [],
			n = e.tracks,
			i = {
				name: e.name,
				duration: e.duration,
				tracks: t,
				uuid: e.uuid,
				blendMode: e.blendMode
			};
		for (let r = 0, s = n.length; r !== s; ++r) t.push(aE.toJSON(n[r]));
		return i
	}
	static CreateFromMorphTargetSequence(e, t, n, i) {
		const r = t.length,
			s = [];
		for (let a = 0; a < r; a++) {
			let e = [],
				o = [];
			e.push((a + r - 1) % r, a, (a + 1) % r), o.push(0, 1, 0);
			const l = tE.getKeyframeOrder(e);
			e = tE.sortedArray(e, 1, l), o = tE.sortedArray(o, 1, l), i || 0 !== e[0] || (e.push(r), o.push(o[0])), s.push(new cE(".morphTargetInfluences[" + t[a].name + "]", e, o).scale(1 / n))
		}
		return new this(e, -1, s)
	}
	static findByName(e, t) {
		let n = e;
		if (!Array.isArray(e)) {
			const t = e;
			n = t.geometry && t.geometry.animations || t.animations
		}
		for (let i = 0; i < n.length; i++)
			if (n[i].name === t) return n[i];
		return null
	}
	static CreateClipsFromMorphTargetSequences(e, t, n) {
		const i = {},
			r = /^([\w-]*?)([\d]+)$/;
		for (let a = 0, o = e.length; a < o; a++) {
			const t = e[a],
				n = t.name.match(r);
			if (n && n.length > 1) {
				const e = n[1];
				let r = i[e];
				r || (i[e] = r = []), r.push(t)
			}
		}
		const s = [];
		for (const a in i) s.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
		return s
	}
	static parseAnimation(e, t) {
		if (!e) return null;
		const n = function(e, t, n, i, r) {
				if (0 !== n.length) {
					const s = [],
						a = [];
					tE.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a))
				}
			},
			i = [],
			r = e.name || "default",
			s = e.fps || 30,
			a = e.blendMode;
		let o = e.length || -1;
		const l = e.hierarchy || [];
		for (let c = 0; c < l.length; c++) {
			const e = l[c].keys;
			if (e && 0 !== e.length)
				if (e[0].morphTargets) {
					const t = {};
					let n;
					for (n = 0; n < e.length; n++)
						if (e[n].morphTargets)
							for (let i = 0; i < e[n].morphTargets.length; i++) t[e[n].morphTargets[i]] = -1;
					for (const r in t) {
						const t = [],
							s = [];
						for (let i = 0; i !== e[n].morphTargets.length; ++i) {
							const i = e[n];
							t.push(i.time), s.push(i.morphTarget === r ? 1 : 0)
						}
						i.push(new cE(".morphTargetInfluence[" + r + "]", t, s))
					}
					o = t.length * (s || 1)
				} else {
					const r = ".bones[" + t[c].name + "]";
					n(pE, r + ".position", e, "pos", i), n(hE, r + ".quaternion", e, "rot", i), n(pE, r + ".scale", e, "scl", i)
				}
		}
		if (0 === i.length) return null;
		return new this(r, o, i, a)
	}
	resetDuration() {
		let e = 0;
		for (let t = 0, n = this.tracks.length; t !== n; ++t) {
			const n = this.tracks[t];
			e = Math.max(e, n.times[n.times.length - 1])
		}
		return this.duration = e, this
	}
	trim() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
		return this
	}
	validate() {
		let e = !0;
		for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
		return e
	}
	optimize() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
		return this
	}
	clone() {
		const e = [];
		for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
		return new this.constructor(this.name, this.duration, e, this.blendMode)
	}
	toJSON() {
		return this.constructor.toJSON(this)
	}
}

function mE(e) {
	if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
	const t = function(e) {
		switch (e.toLowerCase()) {
			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":
				return cE;
			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":
				return pE;
			case "color":
				return lE;
			case "quaternion":
				return hE;
			case "bool":
			case "boolean":
				return oE;
			case "string":
				return dE
		}
		throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
	}(e.type);
	if (void 0 === e.times) {
		const t = [],
			n = [];
		tE.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
	}
	return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
}
const gE = {
	enabled: !1,
	files: {},
	add: function(e, t) {
		!1 !== this.enabled && (this.files[e] = t)
	},
	get: function(e) {
		if (!1 !== this.enabled) return this.files[e]
	},
	remove: function(e) {
		delete this.files[e]
	},
	clear: function() {
		this.files = {}
	}
};
const vE = new class {
	constructor(e, t, n) {
		const i = this;
		let r, s = !1,
			a = 0,
			o = 0;
		const l = [];
		this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
			o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0
		}, this.itemEnd = function(e) {
			a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad())
		}, this.itemError = function(e) {
			void 0 !== i.onError && i.onError(e)
		}, this.resolveURL = function(e) {
			return r ? r(e) : e
		}, this.setURLModifier = function(e) {
			return r = e, this
		}, this.addHandler = function(e, t) {
			return l.push(e, t), this
		}, this.removeHandler = function(e) {
			const t = l.indexOf(e);
			return -1 !== t && l.splice(t, 2), this
		}, this.getHandler = function(e) {
			for (let t = 0, n = l.length; t < n; t += 2) {
				const n = l[t],
					i = l[t + 1];
				if (n.global && (n.lastIndex = 0), n.test(e)) return i
			}
			return null
		}
	}
};
class _E {
	constructor(e) {
		this.manager = void 0 !== e ? e : vE, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
	}
	load() {}
	loadAsync(e, t) {
		const n = this;
		return new Promise((function(i, r) {
			n.load(e, i, t, r)
		}))
	}
	parse() {}
	setCrossOrigin(e) {
		return this.crossOrigin = e, this
	}
	setWithCredentials(e) {
		return this.withCredentials = e, this
	}
	setPath(e) {
		return this.path = e, this
	}
	setResourcePath(e) {
		return this.resourcePath = e, this
	}
	setRequestHeader(e) {
		return this.requestHeader = e, this
	}
}
const yE = {};
class xE extends _E {
	constructor(e) {
		super(e)
	}
	load(e, t, n, i) {
		void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
		const r = this,
			s = gE.get(e);
		if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
			t && t(s), r.manager.itemEnd(e)
		}), 0), s;
		if (void 0 !== yE[e]) return void yE[e].push({
			onLoad: t,
			onProgress: n,
			onError: i
		});
		const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
		let o;
		if (a) {
			const n = a[1],
				s = !!a[2];
			let o = a[3];
			o = decodeURIComponent(o), s && (o = atob(o));
			try {
				let i;
				const s = (this.responseType || "").toLowerCase();
				switch (s) {
					case "arraybuffer":
					case "blob":
						const e = new Uint8Array(o.length);
						for (let n = 0; n < o.length; n++) e[n] = o.charCodeAt(n);
						i = "blob" === s ? new Blob([e.buffer], {
							type: n
						}) : e.buffer;
						break;
					case "document":
						const t = new DOMParser;
						i = t.parseFromString(o, n);
						break;
					case "json":
						i = JSON.parse(o);
						break;
					default:
						i = o
				}
				setTimeout((function() {
					t && t(i), r.manager.itemEnd(e)
				}), 0)
			} catch (l) {
				setTimeout((function() {
					i && i(l), r.manager.itemError(e), r.manager.itemEnd(e)
				}), 0)
			}
		} else {
			yE[e] = [], yE[e].push({
				onLoad: t,
				onProgress: n,
				onError: i
			}), o = new XMLHttpRequest, o.open("GET", e, !0), o.addEventListener("load", (function(t) {
				const n = this.response,
					i = yE[e];
				if (delete yE[e], 200 === this.status || 0 === this.status) {
					this.status, gE.add(e, n);
					for (let e = 0, t = i.length; e < t; e++) {
						const t = i[e];
						t.onLoad && t.onLoad(n)
					}
					r.manager.itemEnd(e)
				} else {
					for (let e = 0, n = i.length; e < n; e++) {
						const n = i[e];
						n.onError && n.onError(t)
					}
					r.manager.itemError(e), r.manager.itemEnd(e)
				}
			}), !1), o.addEventListener("progress", (function(t) {
				const n = yE[e];
				for (let e = 0, i = n.length; e < i; e++) {
					const i = n[e];
					i.onProgress && i.onProgress(t)
				}
			}), !1), o.addEventListener("error", (function(t) {
				const n = yE[e];
				delete yE[e];
				for (let e = 0, i = n.length; e < i; e++) {
					const i = n[e];
					i.onError && i.onError(t)
				}
				r.manager.itemError(e), r.manager.itemEnd(e)
			}), !1), o.addEventListener("abort", (function(t) {
				const n = yE[e];
				delete yE[e];
				for (let e = 0, i = n.length; e < i; e++) {
					const i = n[e];
					i.onError && i.onError(t)
				}
				r.manager.itemError(e), r.manager.itemEnd(e)
			}), !1), void 0 !== this.responseType && (o.responseType = this.responseType), void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials), o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
			for (const e in this.requestHeader) o.setRequestHeader(e, this.requestHeader[e]);
			o.send(null)
		}
		return r.manager.itemStart(e), o
	}
	setResponseType(e) {
		return this.responseType = e, this
	}
	setMimeType(e) {
		return this.mimeType = e, this
	}
}
class bE extends _E {
	constructor(e) {
		super(e)
	}
	load(e, t, n, i) {
		void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
		const r = this,
			s = gE.get(e);
		if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
			t && t(s), r.manager.itemEnd(e)
		}), 0), s;
		const a = Px("img");

		function o() {
			a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), gE.add(e, this), t && t(this), r.manager.itemEnd(e)
		}

		function l(t) {
			a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
		}
		return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a
	}
}
class wE extends _E {
	constructor(e) {
		super(e)
	}
	load(e, t, n, i) {
		const r = new Dx,
			s = new bE(this.manager);
		return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function(e) {
			r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
		}), n, i), r
	}
}
class SE extends Bb {
	constructor(e, t = 1) {
		super(), this.type = "Light", this.color = new aw(e), this.intensity = t
	}
	dispose() {}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
	}
}
SE.prototype.isLight = !0;
const ME = new mb,
	TE = new zx,
	CE = new zx;
class EE {
	constructor(e) {
		this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Cx(512, 512), this.map = null, this.mapPass = null, this.matrix = new mb, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new rS, this._frameExtents = new Cx(1, 1), this._viewportCount = 1, this._viewports = [new kx(0, 0, 1, 1)]
	}
	getViewportCount() {
		return this._viewportCount
	}
	getFrustum() {
		return this._frustum
	}
	updateMatrices(e) {
		const t = this.camera,
			n = this.matrix;
		TE.setFromMatrixPosition(e.matrixWorld), t.position.copy(TE), CE.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(CE), t.updateMatrixWorld(), ME.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ME), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
	}
	getViewport(e) {
		return this._viewports[e]
	}
	getFrameExtents() {
		return this._frameExtents
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
	}
	copy(e) {
		return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	toJSON() {
		const e = {};
		return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
	}
}
class AE extends EE {
	constructor() {
		super(new Xw(50, 1, .5, 500)), this.focus = 1
	}
	updateMatrices(e) {
		const t = this.camera,
			n = 2 * _x * e.angle * this.focus,
			i = this.mapSize.width / this.mapSize.height,
			r = e.distance || t.far;
		n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
	}
	copy(e) {
		return super.copy(e), this.focus = e.focus, this
	}
}
AE.prototype.isSpotLightShadow = !0;
class PE extends SE {
	constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) {
		super(e, t), this.type = "SpotLight", this.position.copy(Bb.DefaultUp), this.updateMatrix(), this.target = new Bb, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new AE
	}
	get power() {
		return this.intensity * Math.PI
	}
	set power(e) {
		this.intensity = e / Math.PI
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e) {
		return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
	}
}
PE.prototype.isSpotLight = !0;
const LE = new mb,
	IE = new zx,
	DE = new zx;
class RE extends EE {
	constructor() {
		super(new Xw(90, 1, .5, 500)), this._frameExtents = new Cx(4, 2), this._viewportCount = 6, this._viewports = [new kx(2, 1, 1, 1), new kx(0, 1, 1, 1), new kx(3, 1, 1, 1), new kx(1, 1, 1, 1), new kx(3, 0, 1, 1), new kx(1, 0, 1, 1)], this._cubeDirections = [new zx(1, 0, 0), new zx(-1, 0, 0), new zx(0, 0, 1), new zx(0, 0, -1), new zx(0, 1, 0), new zx(0, -1, 0)], this._cubeUps = [new zx(0, 1, 0), new zx(0, 1, 0), new zx(0, 1, 0), new zx(0, 1, 0), new zx(0, 0, 1), new zx(0, 0, -1)]
	}
	updateMatrices(e, t = 0) {
		const n = this.camera,
			i = this.matrix,
			r = e.distance || n.far;
		r !== n.far && (n.far = r, n.updateProjectionMatrix()), IE.setFromMatrixPosition(e.matrixWorld), n.position.copy(IE), DE.copy(n.position), DE.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(DE), n.updateMatrixWorld(), i.makeTranslation(-IE.x, -IE.y, -IE.z), LE.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(LE)
	}
}
RE.prototype.isPointLightShadow = !0;
class kE extends SE {
	constructor(e, t, n = 0, i = 1) {
		super(e, t), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new RE
	}
	get power() {
		return 4 * this.intensity * Math.PI
	}
	set power(e) {
		this.intensity = e / (4 * Math.PI)
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e) {
		return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
	}
}
kE.prototype.isPointLight = !0;
class NE extends EE {
	constructor() {
		super(new vS(-5, 5, 5, -5, .5, 500))
	}
}
NE.prototype.isDirectionalLightShadow = !0;
class OE extends SE {
	constructor(e, t) {
		super(e, t), this.type = "DirectionalLight", this.position.copy(Bb.DefaultUp), this.updateMatrix(), this.target = new Bb, this.shadow = new NE
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(e) {
		return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
	}
}
OE.prototype.isDirectionalLight = !0;
class FE extends SE {
	constructor(e, t) {
		super(e, t), this.type = "AmbientLight"
	}
}
FE.prototype.isAmbientLight = !0;
class zE {
	static decodeText(e) {
		if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
		let t = "";
		for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
		try {
			return decodeURIComponent(escape(t))
		} catch (n) {
			return t
		}
	}
	static extractUrlBase(e) {
		const t = e.lastIndexOf("/");
		return -1 === t ? "./" : e.substr(0, t + 1)
	}
}
class UE extends ww {
	constructor() {
		super(), this.type = "InstancedBufferGeometry", this.instanceCount = Infinity
	}
	copy(e) {
		return super.copy(e), this.instanceCount = e.instanceCount, this
	}
	clone() {
		return (new this.constructor).copy(this)
	}
	toJSON() {
		const e = super.toJSON(this);
		return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
	}
}
UE.prototype.isInstancedBufferGeometry = !0;
class BE extends _E {
	constructor(e) {
		super(e), this.options = {
			premultiplyAlpha: "none"
		}
	}
	setOptions(e) {
		return this.options = e, this
	}
	load(e, t, n, i) {
		void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
		const r = this,
			s = gE.get(e);
		if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function() {
			t && t(s), r.manager.itemEnd(e)
		}), 0), s;
		const a = {};
		a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function(e) {
			return e.blob()
		})).then((function(e) {
			return createImageBitmap(e, Object.assign(r.options, {
				colorSpaceConversion: "none"
			}))
		})).then((function(n) {
			gE.add(e, n), t && t(n), r.manager.itemEnd(e)
		})).catch((function(t) {
			i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
		})), r.manager.itemStart(e)
	}
}
BE.prototype.isImageBitmapLoader = !0;
const VE = new RegExp("[\\[\\]\\.:\\/]", "g"),
	HE = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
	GE = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
	WE = /(WCOD+)?/.source.replace("WCOD", HE),
	qE = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
	jE = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
	YE = new RegExp("^" + GE + WE + qE + jE + "$"),
	XE = ["material", "materials", "bones"];
class $E {
	constructor(e, t, n) {
		this.path = t, this.parsedPath = n || $E.parseTrackName(t), this.node = $E.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
	static create(e, t, n) {
		return e && e.isAnimationObjectGroup ? new $E.Composite(e, t, n) : new $E(e, t, n)
	}
	static sanitizeNodeName(e) {
		return e.replace(/\s/g, "_").replace(VE, "")
	}
	static parseTrackName(e) {
		const t = YE.exec(e);
		if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
		const n = {
				nodeName: t[2],
				objectName: t[3],
				objectIndex: t[4],
				propertyName: t[5],
				propertyIndex: t[6]
			},
			i = n.nodeName && n.nodeName.lastIndexOf(".");
		if (void 0 !== i && -1 !== i) {
			const e = n.nodeName.substring(i + 1); - 1 !== XE.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
		}
		if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
		return n
	}
	static findNode(e, t) {
		if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
		if (e.skeleton) {
			const n = e.skeleton.getBoneByName(t);
			if (void 0 !== n) return n
		}
		if (e.children) {
			const n = function(e) {
					for (let i = 0; i < e.length; i++) {
						const r = e[i];
						if (r.name === t || r.uuid === t) return r;
						const s = n(r.children);
						if (s) return s
					}
					return null
				},
				i = n(e.children);
			if (i) return i
		}
		return null
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(e, t) {
		e[t] = this.targetObject[this.propertyName]
	}
	_getValue_array(e, t) {
		const n = this.resolvedProperty;
		for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
	}
	_getValue_arrayElement(e, t) {
		e[t] = this.resolvedProperty[this.propertyIndex]
	}
	_getValue_toArray(e, t) {
		this.resolvedProperty.toArray(e, t)
	}
	_setValue_direct(e, t) {
		this.targetObject[this.propertyName] = e[t]
	}
	_setValue_direct_setNeedsUpdate(e, t) {
		this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
		this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_array(e, t) {
		const n = this.resolvedProperty;
		for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
	}
	_setValue_array_setNeedsUpdate(e, t) {
		const n = this.resolvedProperty;
		for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
		this.targetObject.needsUpdate = !0
	}
	_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
		const n = this.resolvedProperty;
		for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
		this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_arrayElement(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t]
	}
	_setValue_arrayElement_setNeedsUpdate(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_fromArray(e, t) {
		this.resolvedProperty.fromArray(e, t)
	}
	_setValue_fromArray_setNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_getValue_unbound(e, t) {
		this.bind(), this.getValue(e, t)
	}
	_setValue_unbound(e, t) {
		this.bind(), this.setValue(e, t)
	}
	bind() {
		let e = this.node;
		const t = this.parsedPath,
			n = t.objectName,
			i = t.propertyName;
		let r = t.propertyIndex;
		if (e || (e = $E.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return;
		if (n) {
			let i = t.objectIndex;
			switch (n) {
				case "materials":
					if (!e.material) return;
					if (!e.material.materials) return;
					e = e.material.materials;
					break;
				case "bones":
					if (!e.skeleton) return;
					e = e.skeleton.bones;
					for (let t = 0; t < e.length; t++)
						if (e[t].name === i) {
							i = t;
							break
						} break;
				default:
					if (void 0 === e[n]) return;
					e = e[n]
			}
			if (void 0 !== i) {
				if (void 0 === e[i]) return;
				e = e[i]
			}
		}
		const s = e[i];
		if (void 0 === s) {
			t.nodeName;
			return
		}
		let a = this.Versioning.None;
		this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
		let o = this.BindingType.Direct;
		if (void 0 !== r) {
			if ("morphTargetInfluences" === i) {
				if (!e.geometry) return;
				if (!e.geometry.isBufferGeometry) return;
				if (!e.geometry.morphAttributes) return;
				void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
			}
			o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
		} else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
		this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
	}
	unbind() {
		this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
}
$E.Composite = class {
	constructor(e, t, n) {
		const i = n || $E.parseTrackName(t);
		this._targetGroup = e, this._bindings = e.subscribe_(t, i)
	}
	getValue(e, t) {
		this.bind();
		const n = this._targetGroup.nCachedObjects_,
			i = this._bindings[n];
		void 0 !== i && i.getValue(e, t)
	}
	setValue(e, t) {
		const n = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
	}
	bind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
	}
	unbind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
	}
}, $E.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
}, $E.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
}, $E.prototype.GetterByBindingType = [$E.prototype._getValue_direct, $E.prototype._getValue_array, $E.prototype._getValue_arrayElement, $E.prototype._getValue_toArray], $E.prototype.SetterByBindingTypeAndVersioning = [
	[$E.prototype._setValue_direct, $E.prototype._setValue_direct_setNeedsUpdate, $E.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
	[$E.prototype._setValue_array, $E.prototype._setValue_array_setNeedsUpdate, $E.prototype._setValue_array_setMatrixWorldNeedsUpdate],
	[$E.prototype._setValue_arrayElement, $E.prototype._setValue_arrayElement_setNeedsUpdate, $E.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
	[$E.prototype._setValue_fromArray, $E.prototype._setValue_fromArray_setNeedsUpdate, $E.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class ZE extends XT {
	constructor(e, t, n = 1) {
		super(e, t), this.meshPerAttribute = n
	}
	copy(e) {
		return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
	}
	clone(e) {
		const t = super.clone(e);
		return t.meshPerAttribute = this.meshPerAttribute, t
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
	}
}
ZE.prototype.isInstancedInterleavedBuffer = !0;
const KE = new zx,
	JE = new zx;
class QE {
	constructor(e = new zx, t = new zx) {
		this.start = e, this.end = t
	}
	set(e, t) {
		return this.start.copy(e), this.end.copy(t), this
	}
	copy(e) {
		return this.start.copy(e.start), this.end.copy(e.end), this
	}
	getCenter(e) {
		return e.addVectors(this.start, this.end).multiplyScalar(.5)
	}
	delta(e) {
		return e.subVectors(this.end, this.start)
	}
	distanceSq() {
		return this.start.distanceToSquared(this.end)
	}
	distance() {
		return this.start.distanceTo(this.end)
	}
	at(e, t) {
		return this.delta(t).multiplyScalar(e).add(this.start)
	}
	closestPointToPointParameter(e, t) {
		KE.subVectors(e, this.start), JE.subVectors(this.end, this.start);
		const n = JE.dot(JE);
		let i = JE.dot(KE) / n;
		return t && (i = wx(i, 0, 1)), i
	}
	closestPointToPoint(e, t, n) {
		const i = this.closestPointToPointParameter(e, t);
		return this.delta(n).multiplyScalar(i).add(this.start)
	}
	applyMatrix4(e) {
		return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
	}
	equals(e) {
		return e.start.equals(this.start) && e.end.equals(this.end)
	}
	clone() {
		return (new this.constructor).copy(this)
	}
}
class eA extends xC {
	constructor(e, t = 1, n = 16776960) {
		const i = n,
			r = new ww;
		r.setAttribute("position", new fw([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new fC({
			color: i,
			toneMapped: !1
		})), this.type = "PlaneHelper", this.plane = e, this.size = t;
		const s = new ww;
		s.setAttribute("position", new fw([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new Bw(s, new ow({
			color: i,
			opacity: .2,
			transparent: !0,
			depthWrite: !1,
			toneMapped: !1
		})))
	}
	updateMatrixWorld(e) {
		let t = -this.plane.constant;
		Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(e)
	}
}

function tA(e) {
	let t;
	const n = new aw(16711680),
		i = ef(new Cx),
		r = ef(1);
	let s = 1,
		a = 2;
	const o = {
			antialias: !1,
			alpha: !1,
			depth: !0,
			stencil: !1,
			preserveDrawingBuffer: !1,
			powerPreference: "high-performance",
			premultipliedAlpha: !1
		},
		l = {
			beforeInit: jp(),
			afterInit: jp()
		};
	e.renderer = {
		init: function() {
			o.canvas = e.options.canvas, l.beforeInit.emit(), t = new qT(o), e.renderer.instance = t, e.threeRenderer = t, t.getDrawingBufferSize(i.value), h(), t.setClearColor(n), t.autoClear = !0, t.shadowMap.enabled = !1, t.shadowMap.type = 0, t.info.autoReset = !1, e.hooks.beforeFrame.watch((() => t.info.reset())), l.afterInit.emit(), e.viewport.changed.watch(h)
		},
		options: o,
		hooks: l,
		clearColor: n,
		resize: h,
		setMinPixelRatio: function(e) {
			if (s === e) return;
			s = e, u()
		},
		setMaxPixelRatio: function(e) {
			if (a === e) return;
			a = e, u()
		},
		drawingBufferSize: i,
		pixelRatio: r
	};
	let c = !1;

	function u() {
		c || (c = !0, e.hooks.beforeFrame.watchOnce(h))
	}

	function h() {
		c = !1;
		const n = ky(e.viewport.pixelRatio.value, s, a),
			o = e.viewport.size.value,
			l = Cx.get();
		t.getSize(l), t.getPixelRatio() !== n && t.setPixelRatio(n), l.equals(o) || t.setSize(o.x, o.y),
			function() {
				const e = i.value,
					n = Cx.get();
				t.getDrawingBufferSize(n), nf(), n.equals(e) || i.set(e.copy(n), !0);
				r.set(t.getPixelRatio()), n.release(), rf()
			}(), l.release()
	}
}
const nA = Number.MAX_SAFE_INTEGER;

function iA(e) {
	let t = 16.67,
		n = !1,
		i = performance.now(),
		r = 16.6667,
		s = 0,
		a = 0,
		o = 0;
	let l = 0,
		c = 0;
	e.hooks.afterInit.watchOnce((() => {
		e.viewport && e.viewport.visible.watch((() => n = !0))
	})), e.hooks.afterFrame.watchOnce((() => {
		n = !0
	}));
	const u = e.time = {
		clampedDt: 0,
		stableDt: 16.6667,
		dt: 0,
		elapsed: 0,
		frameNum: 0,
		paused: !0,
		init: function() {
			Kc.add(h), u.paused = !1
		},
		start: function() {
			u.paused = !1
		},
		pause: function() {
			u.paused = !0
		},
		clampTo60Fps: !0
	};

	function h(h) {
		const d = i;
		if (i = performance.now(), 0 === (h = i - d) && (h = 16.6667), n && (h = 16.6667, o = !0, a = 0, s = 0, n = !1, l = 0, c = 0), u.clampTo60Fps) {
			if (l += h, c++, l < 13) return;
			c > 1 && (h = 16.666667), l = 0, c = 0
		}
		a += h, a >= 1e3 ? (o = !1, r = 1 / s * 1e3, a = 0, s = 0) : s++, t = ky(o ? h : r, 4, 130), t > 30.303030303030305 && t < 37.03703703703704 ? t = 33.3333334 : t > 15.873015873015872 && t < 17.543859649122805 ? t = 16.6666667 : t > 8 && t < 9.09090909090909 && (t = 8.3333334), u.stableDt = zy(u.stableDt, t, n ? 1 : .08), u.clampedDt = ky(void 0 === h ? 16.6667 : h, 1, 130), u.dt = h, u.paused || (u.elapsed += h, u.frameNum = (u.frameNum + 1) % nA, e.frame())
	}
}

function rA(e) {
	const t = Gi() ? Yt("viewport") : cx,
		n = ef(new Cx(t.width.value, t.height.value)),
		i = ef(n.value.x / n.value.y),
		r = ef(t.pixelRatio.value),
		s = ef(t.visible.value),
		a = jp();
	e.viewport = {
		size: n,
		visible: s,
		pixelRatio: r,
		changed: a
	};
	let o = 0,
		l = 0,
		c = 0;
	const u = wu((() => (o = t.width.value, l = t.height.value, void(c = t.pixelRatio.value))), 150);
	Sr([t.width, t.height, t.pixelRatio], (() => {
		e.options.canvas.style.width = t.width.value + "px", e.options.canvas.style.height = t.height.value + "px", u()
	}), {
		immediate: !0
	}), Mr((() => {
		s.set(t.visible.value)
	}), null, {
		flush: "sync"
	}), e.hooks.beforeFrame.watch((() => {
		const e = n.value,
			t = e.x !== o || e.y !== l,
			s = r.value !== c;
		(t || s) && (nf(), t && (e.set(o, l), n.set(e, !0), i.set(e.x / e.y)), s && r.set(c), a.emit(), rf())
	}))
}

function sA(e) {
	const t = "webgl_quality",
		n = 300;
	let i = 58,
		r = 52,
		s = 30,
		a = n,
		o = n,
		l = 0,
		c = 0,
		u = !1,
		h = !1,
		d = 0,
		p = 10;
	const f = new Float64Array(3);
	let m = 0;
	const g = ef(0),
		v = ef(60),
		_ = ef(60),
		y = ef(1),
		x = jp();
	e.hooks.afterInit.watchOnce((function() {
		const n = Al().$device,
			i = (n && n.gpu ? n.gpu.qualityIndex : 2) + 1,
			r = function() {
				const e = localStorage.getItem(t);
				return null == e || isNaN(e) ? null : 0 | e
			}(),
			s = null !== r ? r : i;
		y.watch((e => {
			n && n.updateQuality(e),
				function(e) {
					localStorage.setItem(t, e)
				}(e)
		})), y.set(s, !0), d = s, e.hooks.beforeFrame.watch(w)
	})), e.hooks.beforeStart.watchOnce((async function() {
		e.viewport.visible.watch((() => b())), e.viewport.changed.watch((() => b(!0, n, !0))), x.watch((() => b(!0, 300)))
	}));
	return e.quality = {
		pingPong: g,
		fps: v,
		fpsAverage: _,
		quality: y,
		reset: x,
		current: y,
		setThresholds: function(e = {}) {
			e.high && (i = e.high);
			e.low && (r = e.low);
			e.critical && (s = e.critical)
		}
	};

	function b(e, t, n) {
		u = !0, h = h || e, n && g.set(0), t && (a = t)
	}

	function w() {
		if (p > 0) return p--;
		const t = e.time.dt;
		if (!(g.value >= 2)) {
			if (u && (l = 0, c = 0, h && (m = 0), o = a || n, u = h = !1, a = n), o > 0) return o -= t;
			l += t, c++, l >= 1e3 && (f[m++] = c, v.set(c), c = 0, l %= 1e3, m > f.length && function() {
				const e = function(e = []) {
					const t = e.slice(0).sort(((e, t) => e - t)),
						n = Math.floor(t.length / 2);
					return t.length % 2 == 0 ? (t[n] + t[n - 1]) / 2 : t[n]
				}(f);
				let t = y.value;
				e <= s ? t -= 2 : e < r ? t -= 1 : e > i && (t += 1), t = ky(t, 0, 5);
				const n = y.value;
				t === n ? g.set(Math.max(0, g.value - .2)) : t !== n && t !== d ? g.set(0) : t === d && g.set(g.value + 1), g.value >= 2 && (t = Math.min(d, n)), d = n, y.set(t), _.set(e), b(!0)
			}())
		}
	}
}

function aA(e) {
	! function(e) {
		const t = e.renderLists;
		if (t._patched) return;
		t._patched = !0;
		const n = t.get;
		t.get = function(e, t) {
			const i = n(e, t);
			return i._patched || function(e) {
				e._patched = !0;
				const t = e.push,
					n = e.unshift;
				e.push = function(e, n, i, r, s, a) {
					const o = i.transparent && i.forceOpaque;
					o && (i.transparent = !1), t(e, n, i, r, s, a), o && (i.transparent = !0)
				}, e.unshift = function(e, t, i, r, s, a) {
					const o = i.transparent && i.forceOpaque;
					o && (i.transparent = !1), n(e, t, i, r, s, a), o && (i.transparent = !0)
				}
			}(i), i
		}
	}(e)
}
const oA = new vS(-1, 1, 1, -1, 0, 1);
oA.parent = !0;
var lA = oA;
const cA = new Float32Array([-2, 0, 0, -2, 2, 2]),
	uA = new ww;
uA.setAttribute("position", new uw(cA, 2));
const hA = ["precision highp float;", "attribute vec2 position;", "varying vec2 vUv;", "void main() {", "vUv = position;", "gl_Position =  vec4(2.0 * position - 1.0, 0.,  1);", "}"].join("");
let dA;

function pA(e) {
	const t = e.renderer;
	delete e.renderer;
	const n = new _S(Object.assign({}, {
		vertexShader: hA,
		fragmentShader: "void() { gl_FragColor = vec4(); }",
		depthTest: !1,
		depthWrite: !1,
		transparent: !0
	}, e));
	dA || (dA = new Bw(uA, n), dA.frustumCulled = !1, dA.matrixAutoUpdate = !1);
	return {
		cam: lA,
		screen: dA,
		material: n,
		uniforms: n.uniforms,
		u: n.uniforms,
		render() {
			const e = t.sortObjects,
				i = t.shadowMap.enabled,
				r = t.autoclear;
			t.sortObjects = !1, t.shadowMap.enabled = !1, t.autoclear = !1, dA.material = n, t.render(dA, lA), t.sortObjects = e, t.shadowMap.enabled = i, t.autoclear = r
		}
	}
}

function fA(e, t, n) {
	return {
		vs: e,
		fs: t,
		use: n => {
			n.fragmentShader = t, n.vertexShader = e
		},
		unuse: () => {}
	}
}
var mA = fA("precision highp float;attribute vec2 position;void main(){gl_Position=vec4(2.0*position-1.0,0.,1);}", "precision highp float;\n#include <bg_pars>\nvoid main(){\n#include <bg>\ngl_FragColor=vec4(bgColor,1.);}");
const gA = {
		res: {
			value: new Cx
		},
		bgCamRotation: {
			value: new Cx
		}
	},
	vA = new zx,
	_A = new zx;

function yA() {
	const e = Nl(),
		t = pA({
			renderer: e.threeRenderer,
			transparent: !1,
			uniforms: gA
		});
	return gA.res = e.renderer.drawingBufferSize, mA.use(t.material), t.update = function() {
		const t = e.scene.currentCamera.cam,
			n = t.getWorldDirection(vA),
			i = t.localToWorld(_A.set(1, 0, 0)).sub(t.position),
			r = n.y,
			s = -i.y;
		gA.bgCamRotation.value.set(r, s)
	}, t
}
yA.uniforms = gA;
class xA {
	constructor(e) {
		this.isComponent = !0, this.components = [], this.dynamicComponents = [], this.refs = {}, this.tweens = {}, this.timers = [], this.props = e
	}
	bind(e, t = 0) {
		return this[e] = fx(e, this, t), this[e]
	}
	init() {}
	beforeDestroy() {}
	add(e) {
		return this.base.add(e), e
	}
	remove(e) {
		return this.base.remove(e), null
	}
	addComponent(e, t) {
		t || (t = {});
		const n = t.mountTo || this.base;
		return e.isComponent || (e = new e(t)), ~this.components.indexOf(e) || ~this.dynamicComponents.indexOf(e) || (e.parentComponent && e.parentComponent.removeComponent(e), e.parentComponent = this, e.static || this.dynamicComponents.push(e), this.components.push(e), n && e.base && n.add(e.base), e.added && e.added(this)), e
	}
	removeComponent(e) {
		const t = this.components.indexOf(e),
			n = this.dynamicComponents.indexOf(e);
		if (~t) return e.parentComponent = null, this.components.splice(t, 1), ~n && this.dynamicComponents.splice(n, 1), this.base && e.base && this.base.remove(e.base), e.removed && e.removed(this), null
	}
	update(e) {
		if (this.updateTimers(e), !this.destroyed)
			for (let t = 0, n = this.dynamicComponents.length; t < n; t++) this.dynamicComponents[t] && this.dynamicComponents[t].update(e)
	}
	updateTimers(e) {
		let t = this.timers.length;
		const n = this.timers;
		for (; t--;) n[t].update(e), n._stopped && (n[t].dispose(), n.splice(t, 1))
	}
	wait(e) {
		return this.timer(e)
	}
	timer(e, t) {
		if (!this.destroyed) {
			if (t) {
				const n = Qc(e, t);
				return this.timers.push(n), n
			}
			return new Promise((t => {
				const n = Qc(e, t);
				this.timers.push(n)
			}))
		}
	}
	clearTimers() {
		for (let e = 0, t = this.timers.length; e < t; e++) this.timers[e].dispose();
		this.timers.length = 0
	}
	destroy() {
		if (!this.destroyed) {
			this.hiding = !0, this.beforeDestroy(), this.clearTimers(), this.parentComponent && this.parentComponent.removeComponent(this);
			for (let e = this.components.length - 1; e >= 0; e--) this.components[e].destroy();
			if (this.base)
				for (let e = this.base.children.length - 1; e >= 0; e--) this.base.remove(this.base.children[e]);
			for (const e in this.tweens) this.tweens[e] && this.tweens[e].kill();
			this.tweens = null, this.base && this.base.parent && this.base.parent.remove(this.base), this.refs = null, this.props = null, this.base = null, this.destroyed = !0, this.components = null, this.dynamicComponents = null, this.anims = null, this.timers = null
		}
	}
}
class bA extends xA {
	constructor(e = {}) {
		var t;
		super(e), this.isCamera = !0, e.noInit || this.init(e), this.props || (this.props = e), this.base || ((t = this).cam = new Xw(55, window.innerWidth / window.innerHeight, .1, 100), t.base = t.cam, t.base.position.set(0, .2, 1).multiplyScalar(5), t.base.lookAt(new zx(0, 0, 0)));
		const n = Nl().renderer.drawingBufferSize;
		this.unwatchResize = n.watch(this.resize, this), this.resize(n.value), this.used = !1
	}
	afterEnable() {}
	afterDisable() {}
	update() {}
	resize(e) {
		this.cam.aspect = e.x / e.y, this.cam.updateProjectionMatrix()
	}
	beforeDestroy() {
		this.unwatchResize()
	}
	destroy() {
		this.cam = null, super.destroy()
	}
}
const wA = function(e, t) {
	e && e.used != t && (e.used = !!t, t ? e.afterEnable() : e.afterDisable())
};
class SA extends xA {
	constructor(e = {}) {
		super(e), this.isScene = !0, this.scene = this.base = new YT, this.background = new aw(0, 0, 0), e.noInit || this.init(e), this.props || (this.props = e), this.currentCamera || this.fallbackCamera()
	}
	fallbackCamera() {
		this.defaultCamera || (this.defaultCamera = this.addComponent(new bA)), this.useCamera(this.defaultCamera)
	}
	useCamera(e) {
		return this.currentCamera && (this.previousCamera = this.currentCamera), this.currentCamera = e, this.previousCamera !== this.currentCamera && wA(this.previousCamera, !1), wA(this.currentCamera, !0), this.currentCamera || this.fallbackCamera(), e
	}
	usePreviousCamera() {
		const e = this.currentCamera;
		this.currentCamera = this.previousCamera, this.previousCamera = e, this.previousCamera !== this.currentCamera && wA(this.previousCamera, !1), wA(this.currentCamera, !0), this.currentCamera || this.fallbackCamera()
	}
	enter() {}
	exit() {}
	render() {
		Nl().threeRenderer.render(this.base, this.currentCamera.cam)
	}
}
var MA = function(e) {
	function t(t) {
		(e = (0 | t) % 2147483647) <= 0 && (e += 2147483646)
	}

	function n() {
		return e = 48271 * e % 2147483647
	}
	return t(e), {
		seed: t,
		nextInt: n,
		nextFloat: function() {
			return (n() - 1) / 2147483646
		}
	}
};
var TA = function(e = 0) {
	let t = MA(e);
	return t.nextFloat(), t.nextFloat(), {
		setSeed: function(n) {
			t = MA(e = n)
		},
		random: function() {
			return t.nextFloat()
		},
		randomFloat: function(e = 0, n = 1) {
			return t.nextFloat() * (n - e) + e
		},
		randomInt: function(e, n) {
			return Math.floor(t.nextFloat() * (n - e + 1)) + e
		},
		hash2d: n,
		hash2dInt: function(e, t, i, r) {
			return Math.floor(n(e, t) * (r - i + 1)) + i
		}
	};

	function n(e, t) {
		return function(e) {
			return e - Math.floor(e)
		}(43758.5453 * Math.sin(e * 78.233 - 12.9898 * t))
	}
}(Date.now());
const CA = (3 - Math.sqrt(3)) / 6,
	EA = [
		[1, 1],
		[-1, 1],
		[1, -1],
		[-1, -1],
		[1, 0],
		[-1, 0],
		[1, 0],
		[-1, 0],
		[0, 1],
		[0, -1],
		[0, 1],
		[0, -1]
	];

function AA(e = Math.random) {
	const t = new Uint8Array(256);
	for (let a = 0; a < 256; a++) t[a] = a;
	let n, i;
	for (let a = 255; a > 0; a--) n = Math.floor((a + 1) * e()), i = t[a], t[a] = t[n], t[n] = i;
	const r = new Uint8Array(512),
		s = new Uint8Array(512);
	for (let a = 0; a < 512; a++) r[a] = t[255 & a], s[a] = r[a] % 12;
	return (e, t) => {
		const n = .5 * (e + t) * (Math.sqrt(3) - 1),
			i = Math.floor(e + n),
			a = Math.floor(t + n),
			o = (i + a) * CA,
			l = e - (i - o),
			c = t - (a - o),
			u = l > c ? 1 : 0,
			h = l > c ? 0 : 1,
			d = l - u + CA,
			p = c - h + CA,
			f = l - 1 + 2 * CA,
			m = c - 1 + 2 * CA,
			g = 255 & i,
			v = 255 & a,
			_ = EA[s[g + r[v]]],
			y = EA[s[g + u + r[v + h]]],
			x = EA[s[g + 1 + r[v + 1]]],
			b = .5 - l * l - c * c,
			w = .5 - d * d - p * p,
			S = .5 - f * f - m * m;
		return 70.14805770653952 * ((b < 0 ? 0 : Math.pow(b, 4) * (_[0] * l + _[1] * c)) + (w < 0 ? 0 : Math.pow(w, 4) * (y[0] * d + y[1] * p)) + (S < 0 ? 0 : Math.pow(S, 4) * (x[0] * f + x[1] * m)))
	}
}

function PA(e) {
	const t = Nl().time.stableDt;
	let n = 1;
	return t > 39 ? n = 1.4 : t > 32 ? n = 1.3 : t > 24 ? n = 1.2 : t > 19 ? n = 1.1 : t > 16 && (n = 1), e * n
}
const LA = AA(),
	IA = new zx,
	DA = new zx,
	RA = new zx,
	kA = new zx,
	NA = new zx,
	OA = new zx,
	FA = new Fx,
	zA = new Fx;
let UA, BA;
class VA extends bA {
	init() {
		UA = Nl(), BA = UA.game, UA.gameCam = BA.gameCam = this, this.turbolineActive = !0, this.cloudParticlesActive = !0;
		const e = this.cam = new Xw(40, 1, .2, 180);
		this.base = this.cam, this.isGameCamera = !0, this.cam.position.set(0, 3, 10), this.cam.lookAt(new zx(0, 0, 0)), this.cam.updateProjectionMatrix(), this.minVel = 10, this.maxVel = 40, this.minFov = 30, this.maxFov = 50, this.targetFov = this.cam.fov, this.baseCam = {
			pos: e.position.clone(),
			qt: e.quaternion.clone()
		}, this.target = {
			pos: new zx,
			qt: new Fx
		}, this.targetLerp1 = {
			pos: new zx,
			qt: new Fx
		}, this.targetLerp2 = {
			pos: new zx,
			qt: new Fx
		}, this.road = BA.createFrameData(), this.veryForwardRoad = BA.createFrameData(), this.forwardRoad = BA.createFrameData(), this.behindRoad = BA.createFrameData(), this.plane = new tS, this.forwardLine = new QE, this.carTranslation = 0, this.activeInfluence = 0, this.shakeState = {
			shaking: !1,
			maxDuration: 0,
			maxAmplitude: 0,
			currentDuration: 0,
			currentAmplitude: 0,
			freqMult: 1,
			value: [0, 0],
			pos: [0, 0],
			speed: [.006, 1e-4]
		}, this.hitPoint = new Bb, this.camPoint = new Bb, UA.viewport.changed.watch(this.updateBaseDistance, this), BA.hooks.reset.watch(this.reset, this), this.reset(), BA.turbo.active.watch((e => {
			this.shakeTurboTarget = e ? 1 : 0, e && (this.shakeTurbo = this.shakeTurboTarget, this.shake(800, -.15, !0, !0, 1.1))
		})), BA.ended.watch((e => {
			this.endedInfluence = 0
		}))
	}
	updateBaseDistance() {
		const e = UA.viewport.size.value,
			t = e.x / e.y;
		this.baseDistance = zy(1.65, 1.4, ky(Ny(t, .55, .85), 0, 1))
	}
	afterEnable() {
		this.reset()
	}
	afterDisable() {
		this.activeInfluenceTarget = 0, this.activeInfluence = 0
	}
	reset() {
		this.baseDistance = 1.6, this.updateBaseDistance(), this.turboInfluence = 0, this.shakeTurbo = this.shakeTurboTarget = 0, this.targetFovSmooth = this.targetFov = 70, this.autoInfluence = 0, this.endedInfluence = 0, this.activeInfluence = 0, this.activeInfluenceTarget = this.used ? 1 : 0, "game" === Ll.$route.name && (this.forwardInfluence = 1, this.forwardInfluenceRotate = 1), this.update(!0)
	}
	updateMatrix() {
		const e = this.cam;
		e.updateMatrix(), e.matrixWorld.copy(e.matrix)
	}
	updateUp(e) {
		this.cam.up.copy(kA.set(0, 1, 0).applyQuaternion(e || this.cam.quaternion))
	}
	update(e) {
		BA.resetting && (e = !0);
		const t = UA.time.stableDt,
			n = BA.turbo.active.value;
		this.turboInfluence = By(this.turboInfluence, n ? 1 : 0, n ? .1 : .06, t), this.distance = this.baseDistance + .15 * this.baseDistance * this.turboInfluence, this.activeInfluence = Vy(this.activeInfluence, this.activeInfluenceTarget, .08, t, 1e-5), this.autoInfluence = zy(this.autoInfluence, BA.autopilot.value ? 1 : 0, BA.autopilot.value ? .05 : .08);
		const i = this.cam,
			r = this.baseCam,
			s = this.target,
			a = this.targetLerp1,
			o = this.targetLerp2,
			l = this.road,
			c = this.behindRoad,
			u = this.forwardRoad,
			h = this.veryForwardRoad;
		i.position.copy(r.pos), i.quaternion.copy(r.qt), this.updateMatrix();
		const d = zy(2, 15, this.autoInfluence),
			p = zy(8, 30, this.autoInfluence);
		let f = 0;
		const m = BA.checkpoints.list.finish + 7;
		BA.ended.value && BA.progress > m && (this.activeInfluenceTarget = 0, this.endedInfluence = By(this.endedInfluence, 1, .02, t), f = zy(0, m + 8 * this.endedInfluence - BA.progress, this.endedInfluence)), BA.getRelativeRoadData(0 + f, l), BA.getRelativeRoadData(d + f, u), BA.getRelativeRoadData(p + f, h), BA.getRelativeRoadData(-this.distance + f, c);
		const g = IA.copy(h.position),
			v = RA.copy(l.position).sub(g).normalize(),
			_ = DA.copy(v).multiplyScalar(this.distance).add(l.position);
		this.forwardLine.start.copy(u.position), this.forwardLine.end.copy(_), this.hitPoint.position.copy(_), this.hitPoint.quaternion.copy(l.quaternion), this.hitPoint.updateWorldMatrix(!0), this.camPoint.position.copy(c.position), this.camPoint.quaternion.copy(c.quaternion), this.camPoint.updateWorldMatrix(!0), this.camPoint.worldToLocal(NA.copy(this.hitPoint.position)), this.camPoint.translateX(NA.x), this.camPoint.translateY(ky(NA.y, 0, 10)), this.camPoint.translateZ(NA.z), this.camPoint.quaternion.copy(this.hitPoint.quaternion), this.camPoint.updateWorldMatrix(!0), i.position.copy(this.camPoint.position), i.quaternion.copy(this.camPoint.quaternion), this.updateUp(), i.translateY(zy(-.1, -.3, this.autoInfluence));
		const y = NA.y;
		i.translateY(-y), i.lookAt(l.position), FA.copy(i.quaternion), i.translateY(y), i.lookAt(u.position), zA.copy(i.quaternion), i.quaternion.copy(zA), i.quaternion.slerp(FA, zy(.15 * -y, 0, this.autoInfluence)), s.pos.copy(i.position), s.qt.copy(i.quaternion), i.position.copy(r.pos), i.quaternion.copy(r.qt);
		const x = PA;
		a.pos.lerp(s.pos, e ? 1 : x(.2)), a.qt.slerp(s.qt, e ? 1 : x(.2)), o.pos.lerp(a.pos, e ? 1 : x(.15)), o.qt.slerp(a.qt, e ? 1 : x(.15)), i.position.lerp(o.pos, e ? 1 : x(.1)), i.quaternion.slerp(o.qt, e ? 1 : x(.1)), e && i.translateY(.45), NA.copy(l.position).sub(i.position).normalize();
		const b = OA.copy(NA).multiplyScalar(-this.distance).add(l.position);
		i.position.copy(b), i.translateY(Oy(BA.velocity * t / 16.6667, 0, 10, .05, .08)), r.pos.copy(i.position), r.qt.copy(i.quaternion);
		const w = UA.scene.road.car;
		this.carTranslation = zy(this.carTranslation, w.base.position.z, e ? 1 : x(.2)), i.rotateZ(-.025 * this.carTranslation), i.translateX(this.carTranslation), i.rotateZ(-.025 * this.carTranslation);
		const S = BA.velocity;
		this.targetFov = ky(Oy(S, 6, 10, 70, 79), 70, 95), this.targetFov *= 1 + .015 * n;
		const M = e ? 1 : .09 + .2 * this.turboInfluence;
		if (this.targetFovSmooth = zy(i.fov, this.targetFov, M), i.fov = zy(i.fov, this.targetFovSmooth, M), this.cam.updateProjectionMatrix(), this.forwardInfluence > 1e-5 && (this.cam.translateY(-.2 * this.forwardInfluence), this.cam.translateZ(-3 * this.forwardInfluence)), this.forwardInfluenceRotate > 1e-5 && (this.cam.rotateZ(-.2 * this.forwardInfluenceRotate), this.cam.rotateX(-.4 * this.forwardInfluenceRotate)), BA.paused.value) return;
		this.forwardInfluence > 1e-5 && (this.forwardInfluence = By(this.forwardInfluence, 0, .07, t)), this.forwardInfluenceRotate > 1e-5 && (this.forwardInfluenceRotate = By(this.forwardInfluenceRotate, 0, .03, t));
		const T = this.shakeState;
		if (T.shaking) {
			const e = 1 - T.currentDuration / T.maxDuration;
			let n = zy(T.speed[0], T.speed[1], e);
			n *= T.freqMult, T.currentAmplitude = zy(T.maxAmplitude, 0, e), T.pos[0] += t * n, T.pos[1] += t * n, T.value[0] = Math.cos(9 * T.pos[0]) * T.currentAmplitude * .6, T.value[1] = LA(10, T.pos[1]) * T.currentAmplitude;
			const i = .9 * T.value[0],
				r = .3 * T.value[1],
				s = T.vertical ? r : i,
				a = T.vertical ? i : r;
			this.base.translateY(a), this.base.translateX(s), this.base.rotateZ(.5 * a), this.base.rotateY(.5 * s), T.currentDuration = Math.max(0, T.currentDuration - t), 0 === T.currentDuration && (T.maxAmplitude = 0, T.maxDuration = 0, T.shaking = !1)
		}
		const C = UA.game.elapsed;
		if (w.dipShake > .001) {
			const e = Math.cos(.09 * C) * w.dipShake + w.dipShake;
			this.base.translateX(.9 * e), this.base.rotateX(.3 * e)
		}
		if (this.shakeTurbo > .001) {
			this.shakeTurbo = By(this.shakeTurbo, this.shakeTurboTarget, .08, t);
			const e = (.5 * Math.cos(.079 * C) + .5) * this.shakeTurbo * .01;
			this.base.translateY(1 * e), this.base.rotateZ(1.4 * e)
		}
	}
	shake(e = 500, t = .1, n = !1, i = !1, r = 1) {
		const s = this.shakeState;
		t *= 1.07, s.vertical = n, (i || !s.shaking || e > s.maxDuration) && (s.maxDuration = e, s.currentDuration = e), (i || !s.shaking || t > s.maxAmplitude) && (s.maxAmplitude = t, s.currentAmplitude = t, s.freqMult = r), (e || t) && (s.shaking = !0), s.pos[0] = 200 * Math.PI, s.pos[1] = 500 * Math.random()
	}
	devtools() {
		const e = UA.scene,
			t = new Hw;
		t.scale(.06, .06, .06), this.forwardRuler = e.addComponent(LineHelper, {
			line: this.forwardLine
		}), this.planeHelper = e.add(new eA(this.plane, 1e3)), this.cameraHelper = e.add(new CameraHelper(this.cam)), this.hitPoint = e.add(new Bw(t, new ow({
			color: 16776960
		}))), this.camPoint = e.add(new Bw(t, new ow({
			color: 16777215
		}))), this.showHelper = tf(ef(!1), "cam_helper", {
			type: Boolean
		}), requestAnimationFrame((() => {
			UA.scene.gui.addButton({
				title: "Shake",
				label: "Game Camera"
			}).on("click", (() => this.shake())), UA.scene.gui.addInput(this, "showHelper", {
				label: "Cam Helpers",
				index: 1
			})
		})), this.showHelper.watchImmediate((e => {
			this.cameraHelper.visible = this.forwardRuler.visible = this.planeHelper.visible = this.camPoint.visible = this.hitPoint.visible = e
		}))
	}
}
var HA = [{
	fromPos: [282.891704, -18.581829, -50.960995],
	fromQt: [-.02241292, .97635353, -.12517048, -.17482507],
	toPos: [299.941729, -5.772501, -4.877451],
	toQt: [-.02241292, .97635353, -.12517048, -.17482507],
	carProgress: 845,
	minDuration: 3e3,
	maxDuration: 3e3,
	portrait: !0
}, {
	fromPos: [175.216669, -.036465, 11.9629],
	fromQt: [.02326362, .92994943, -.05975366, .36205297],
	toPos: [167.658131, 2.232513, 20.198758],
	toQt: [.02326362, .92994943, -.05975366, .36205297],
	carProgress: 450,
	minDuration: 2e3,
	maxDuration: 2e3,
	shotDuration: 4e3,
	engineMult: 1.02,
	portrait: !0
}, {
	fromPos: [187.853648, 1.957363, 48.003604],
	fromQt: [.01508246, .86160589, -.02564635, .50670512],
	toPos: [183.340058, 2.267299, 49.875425],
	toQt: [.01670806, .85731853, -.02788102, .51375911],
	carProgress: 490,
	minDuration: 2700,
	maxDuration: 2700,
	engineMult: 1.1,
	carTowardsCam: !0
}, {
	fromPos: [128.718036, 4.103217, 3.850563],
	fromQt: [-.02500299, .09774558, .00245647, .99489428],
	toPos: [125.773766, 5.079072, -5.987887],
	toQt: [.04454532, -.36356677, .01740783, .93033966],
	carProgress: 330,
	minDuration: 2e3,
	maxDuration: 2e3,
	portrait: !0,
	selfieMode: !0
}, {
	fromPos: [128.718036, 4.103217, 3.850563],
	fromQt: [-.02500299, .09774558, .00245647, .99489428],
	toPos: [125.773766, 5.079072, -5.987887],
	toQt: [.04454532, -.36356677, .01740783, .93033966],
	carProgress: 340,
	minDuration: 2e3,
	maxDuration: 2e3
}, {
	fromPos: [225.97637, -.396231, -31.212934],
	fromQt: [-.00207845, .99464626, -.02041174, -.10128113],
	toPos: [228.390101, .091184, -19.913308],
	toQt: [.00430996, .99565115, .06124577, -.07006551],
	carProgress: 592,
	minDuration: 1700,
	maxDuration: 1700,
	shotDuration: 1700,
	carTowardsCam: !0,
	portrait: !0
}, {
	fromPos: [227.461658, -.290387, -21.434235],
	fromQt: [-.05747906, -.0279098, -.00160752, .99795522],
	toPos: [222.675706, -.038329, -63.153271],
	toQt: [.0892923, -.0343194, .00307859, .99540926],
	carProgress: 605,
	minDuration: 4e3,
	maxDuration: 4e3,
	engineMult: .95,
	portrait: !0
}, {
	fromPos: [88.076076, 6.250712, 32.666098],
	fromQt: [-.00314254, .40548705, .00139402, .91409432],
	toPos: [84.67264, 5.274827, 21.484648],
	toQt: [-.0034374, -.01624803, -5586e-8, .99986208],
	carProgress: 220,
	minDuration: 2e3,
	maxDuration: 2e3,
	shotDuration: 2500,
	carTowardsCam: !0,
	engineMult: 1.1
}, {
	fromPos: [103.419212, -.721882, 52.708181],
	fromQt: [-.11709994, -.53352681, -.07488577, .83428344],
	toPos: [111.952886, -1.969951, 47.591677],
	toQt: [-.05274749, -.4966684, -.03025847, .8658075],
	carProgress: 135,
	minDuration: 2e3,
	maxDuration: 2e3,
	engineMult: 1.04
}, {
	fromPos: [123.084511, -.299156, 19.813292],
	fromQt: [.00560572, .95071188, .01721688, -.30954655],
	toPos: [115.367267, .175733, 9.218633],
	toQt: [.00560572, .95071188, .01721688, -.30954655],
	carProgress: 160,
	minDuration: 2500,
	maxDuration: 2500,
	shotDuration: 2500,
	carTowardsCam: !0,
	portrait: !0
}, {
	fromPos: [123.084511, -.299156, 19.813292],
	fromQt: [.00560572, .95071188, .01721688, -.30954655],
	toPos: [115.367267, .175733, 9.218633],
	toQt: [.00560572, .95071188, .01721688, -.30954655],
	carProgress: 160,
	minDuration: 2500,
	maxDuration: 2500,
	shotDuration: 2500,
	carTowardsCam: !0,
	portrait: !0,
	selfieMode: !0
}, {
	fromPos: [254.197647, -.5098, -94.872706],
	fromQt: [-.02720285, .33842121, .00978791, .94055052],
	toPos: [244.776459, -.59221, -96.238816],
	toQt: [.0086017, .52566449, -.00531559, .85063188],
	carProgress: 700,
	minDuration: 1200,
	maxDuration: 1200,
	carTowardsCam: !0,
	engineMult: 1.1,
	portrait: !0
}, {
	fromPos: [18.68355, .305625, -.552699],
	fromQt: [.05793902, -.75217683, .06673793, .65300776],
	toPos: [36.576095, 1.201599, -.9713],
	toQt: [.01251986, -.8333603, .01889228, .55226529],
	carProgress: 18,
	minDuration: 3e3,
	maxDuration: 3e3,
	shotDuration: 3e3,
	engineMult: 1.07,
	portrait: !0
}];

function GA(e) {
	return e[(t = 0, n = e.length, Math.floor(Math.random() * (n - t)) + t)];
	var t, n
}
AA();
const WA = new zx,
	qA = new zx;
new zx, new Fx, new Fx;
const jA = new Bb;
let YA, XA;
class $A extends bA {
	init() {
		YA = Nl(), XA = YA.game, this.cam = new Xw(55, 1, .2, 180), this.base = this.cam, this.forceCarAutopilot = !0, this.forceCarVelocity = 8, this.isIdleCamera = !0, this.cam.position.set(0, 3, 10), this.cam.lookAt(new zx(0, 0, 0)), this.cam.updateProjectionMatrix(), this.enabled = ef(!1), this.shot = {
			fromPos: new zx,
			toPos: new zx,
			fromQt: new Fx,
			toQt: new Fx,
			lookAt: new zx,
			useLookAt: !1,
			towardsCam: !1,
			seflieMode: !1
		}, this.reset()
	}
	reset() {
		this.index = -1, this.shot.fromPos.setScalar(0), this.shot.toPos.setScalar(0), this.shot.useLookAt = !1, this.nextShot(), this.update(!0)
	}
	updateMatrix() {
		const e = this.cam;
		e.updateMatrix(), e.matrixWorld.copy(e.matrix)
	}
	updateUp(e) {
		const t = WA.set(0, 1, 0).applyQuaternion(e || this.cam.quaternion);
		this.cam.up.copy(t)
	}
	nextShot(e) {
		const t = (this.index + 1) % HA.length,
			n = HA[e || t];
		if (n.fromPos && this.shot.fromPos.fromArray(n.fromPos), n.toPos && this.shot.toPos.fromArray(n.toPos), n.fromQt && this.shot.fromQt.fromArray(n.fromQt), n.toQt && this.shot.toQt.fromArray(n.toQt), n.lookAt && this.shot.lookAt.fromArray(n.lookAt), this.shot.selfieMode = !!n.selfieMode, this.carTowardsCam = !!n.carTowardsCam, this.engineMult = null != n.engineMult ? n.engineMult : TA.randomFloat(.98, 1.03), this.shot.useLookAt = n.lookAt, this.index = t, this.time = 0, this.shotDuration = n.shotDuration || 1e4, this.duration = TA.randomFloat(n.minDuration || 3e3, n.maxDuration || 5e3), this.used) {
			const e = n.carProgress || 0;
			XA.progress = e
		}
	}
	afterEnable() {
		this.reset(), "result" === Ll.$route.name && this.nextShot(1)
	}
	afterDisable() {
		this.reset()
	}
	update(e) {
		if (this.visible = this.used, !e && !this.visible) return;
		const t = e ? 0 : YA.time.stableDt;
		this.time += t;
		const n = this.shot,
			i = this.cam,
			r = ky(this.time / this.shotDuration, 0, 1);
		n.selfieMode ? this.selfieMode(i) : (i.position.lerpVectors(n.fromPos, n.toPos, r), n.useLookAt ? i.lookAt(n.lookAt) : i.quaternion.slerpQuaternions(n.fromQt, n.toQt, r)), this.time >= this.duration && this.nextShot()
	}
	selfieMode(e) {
		const t = YA.game.getRelativeRoadData(1),
			n = XA.pointer.base;
		jA.position.copy(t.position), jA.quaternion.copy(n.quaternion), jA.lookAt(n.position), jA.rotateY(Math.PI), jA.updateMatrixWorld();
		const i = jA.localToWorld(qA.set(0, .26, 0));
		jA.position.copy(i), e.position.copy(jA.position), e.quaternion.copy(jA.quaternion)
	}
}
class ZA extends xA {
	constructor(e = {}) {
		super(e), e.noInit || this.init(e), this.props || (this.props = e), this.base || (this.base = new Bb), void 0 === this.static && (this.static = !1)
	}
	destroy() {
		super.destroy()
	}
}
var KA = fA("#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}", "#define PHONG\n#define NEON\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform float speedInfluence;uniform sampler2D data;uniform sampler2D matcaps;void main(){vec3 data=texture2D(data,vUv).rgb;float speedLineInfluence=clamp(smoothstep(0.1,1.,gl_FragCoord.w),0.,1.)*data.b*speedInfluence;vec4 diffuseColor=vec4(diffuse,opacity);float rimLightPower=2.5;float rimLightStrength=0.9;float rightLight=rimLightPower*abs(dot(vNormal,normalize(vViewPosition)));rightLight=1.-smoothstep(.0,1.,rightLight);diffuseColor.rgb+=diffuseColor.rgb*vec3(rightLight*rimLightStrength)*0.5;diffuseColor.rgb+=clamp(vNormal.x*0.9,-1.,0.)*0.7;diffuseColor.rgb-=vNormal.z*0.2;ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <map_fragment>\nfloat specularStrength=1.0;specularStrength=data.g*10.+speedLineInfluence*8.;\n#include <normal_fragment_begin>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;outgoingLight=mix(outgoingLight,outgoingLight*0.5+vec3(1.),speedLineInfluence*1.);float neonIntensity=data.r;outgoingLight.rgb=min(vec3(1.),outgoingLight.rgb+vec3(neonIntensity));\n#include <output_fragment>\n#include <neon_encode>\n#include <bg_fog>\n}");
let JA, QA, eP = null;
class tP extends jw {
	constructor(e = {}) {
		super(e);
		const t = this.uniforms = l(o(o({}, qw.merge([cS.common, cS.specularmap, cS.fog, cS.lights])), yA.uniforms), {
			map: {
				value: Ol.textures.roadDiffuse
			},
			data: {
				value: Ol.textures.roadData
			},
			specular: {
				value: new aw(1118481)
			},
			shininess: {
				value: 130
			},
			speedInfluence: {
				value: 0
			}
		});
		this.map = t.map.value, KA.use(this), this.lights = !0, this.fog = !0, this.type = "ShaderMaterial", this.isShaderMaterial = !0
	}
}
tP.get = e => eP = eP || new tP(e);
class nP extends ZA {
	init() {
		JA = Nl(), QA = JA.game, QA.pointer = this, this.base = new Bb
	}
	update() {
		const e = QA.getRoadData();
		this.base.position.copy(e.position), this.base.quaternion.copy(e.quaternion), this.base.updateMatrixWorld()
	}
}
var iP = fA("#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}", "#define PHONG\n#define NEON\n#define TANGENTSPACE_NORMALMAP\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\n#include <remap>\n#include <linearstep>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform float bloomStrength;uniform float turboProgress;uniform vec3 turboColor;uniform sampler2D data;uniform sampler2D matcaps;uniform sampler2D prevFrame;uniform vec2 size;void main(){vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;vec2 ruv=gl_FragCoord.xy/size;ruv.x+=vNormal.x*0.3;ruv.y+=-0.13+vNormal.y*0.3;vec2 testb=texture2D(prevFrame,ruv).rb;float test2=smoothstep(testb.r,0.,0.8)*1.9;test2+=smoothstep(testb.g,-0.4,0.7)*9.9;float test=test2*0.8;\n#include <map_fragment>\nif(diffuseColor.a<0.95)discard;float specularStrength=1.0;\n#include <normal_fragment_begin>\nvec3 mapN=texture2D(normalMap,vUv*50.).xyz*2.0-1.0;float scale=1.3;mapN*=vec3(scale,scale,1.);vec3 normalFlakes=perturbNormal2Arb(-vViewPosition,normal,mapN,faceDirection);\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <envmap_fragment>\n#include <output_fragment>\nvec2 uv=vUv;float data=texture2D(data,uv).r;float id=floor(data*8.);float id_x=mod(id,4.)/4.+0.0001;float id_y=(floor(id/4.)/2.)+0.0001;vec2 start=vec2(id_x,id_y);vec2 size=vec2(0.25,0.5);vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 matcapUV=vec2(dot(x,normal),dot(y,normal))*0.499+0.5;matcapUV.y=1.-matcapUV.y;matcapUV.xy=matcapUV.xy*size+start;vec3 matcapColor=texture2D(matcaps,matcapUV).rgb;vec2 matcapUVFlakes=vec2(dot(x,normalFlakes),dot(y,normalFlakes))*0.499+0.5;matcapUVFlakes.y=1.-matcapUVFlakes.y;matcapUVFlakes.xy=matcapUVFlakes.xy*size+start;vec3 matcapColorFlakes=texture2D(matcaps,matcapUVFlakes).rgb;matcapColor=mix(matcapColor,matcapColorFlakes,smoothstep(0.4,0.,luma(matcapColor))*when_eq(id,4.));float isNotTire=1.-when_eq(id,6.);float isGlass=when_eq(id,5.);float rimLightPower=5.2;float rimLightStrength=0.4*isNotTire;vec3 rimColor=vec3(1.,0.,0.);float rightLight=rimLightPower*abs(dot(vNormal,normalize(vViewPosition)));rightLight=1.-smoothstep(.0,1.,rightLight);matcapColor+=matcapColor*vec3(rightLight*rimLightStrength)*0.5;vec3 rim=mix(matcapColor,rimColor,rightLight*rimLightStrength);float glass=luma(envColor.rgb)*(0.55+isGlass*1.8);test+=glass;matcapColor=mix(rim,matcapColor,0.1+0.6*smoothstep(0.2,0.8,luma(matcapColor)));vec3 lMatcapColor=matcapColor*smoothstep(0.,0.06,(luma(reflectedLight.directDiffuse)));matcapColor=mix(lMatcapColor,matcapColor,(0.4+0.6*smoothstep(0.,0.4,luma(matcapColor)))+reflectedLight.directSpecular*3.+isGlass*test*0.6+test*0.12);matcapColor+=test*0.013*isGlass+test*0.02+glass*0.07;float turbo=step(turboProgress,uv.y);vec3 turboShape=mix(vec3(0.357,0.012,0.035)*0.1,turboColor,turbo);float isTurbo=when_eq(id,1.)*when_gt(vUv.x,0.11)*when_lt(vUv.x,0.14);matcapColor=mix(matcapColor,turboShape,isTurbo);float neonIntensity=when_eq(id,1.)*0.7*bloomStrength;gl_FragColor.rgb=matcapColor;\n#include <neon_encode>\n#include <bg_fog>\n}");
let rP = null;
class sP extends jw {
	constructor(e = {}) {
		super(e), this.envMap = null, this.envMapIntensity = 1;
		const t = this.uniforms = l(o(o({}, qw.merge([cS.common, cS.envmap, cS.normalmap, cS.fog, cS.lights])), yA.uniforms), {
			size: Ol.renderer.drawingBufferSize,
			prevFrame: Ol.previousFrame,
			data: {
				value: Ol.textures.carData
			},
			matcaps: {
				value: Ol.textures.matcaps
			},
			specular: {
				value: new aw(5592405)
			},
			turboProgress: {
				value: 0
			},
			turboColor: {
				value: new aw
			},
			bloomStrength: {
				value: .5
			},
			shininess: {
				value: 100
			},
			reflectivity: {
				value: 1
			}
		});
		this.envMap = t.envMap.value = Ol.textures.envMap2, this.normalMap = t.normalMap.value = Ol.textures.flakes, this.normalScale = t.normalScale.value = new Cx(1), this.extensions.derivatives = {
			derivatives: !0
		}, iP.use(this), this.lights = !0, this.fog = !0, this.type = "ShaderMaterial", this.isShaderMaterial = !0
	}
}
sP.get = e => rP = rP || new sP(e);
const aP = function() {};
class oP {
	constructor({
		atlas: e,
		id: t,
		group: n,
		sequence: i,
		loop: r,
		autoplay: s,
		frame: a,
		onUpdate: o,
		onEnd: l,
		onEndOnce: c,
		frameDuration: u,
		category: h
	}) {
		this.frames = [], this.onUpdate = o || aP, this.onEndOnce = c || aP, this.onEnd = l || aP, this.id = void 0 !== t ? t : n + "/" + i, this.group = "", this.sequence = "", this.loop = !!r, this.autoplay = !!s, this.frame = a || 0, this.frameCount = 0, this.frameDuration = u || 48, this.frameTimer = 60 * Math.random(), this.currentFrameIndex = 0, this.paused = !1, this.ended = !1, this.category = h || "atlas", this.atlas = e, e && (this.setAtlas(e), this.change({
			id: this.id,
			frameDuration: this.frameDuration,
			autoplay: this.autoplay,
			loop: this.loop,
			frame: this.frame
		}))
	}
	setAtlas(e) {
		e && (this.sprites = e.sprites || e)
	}
	change({
		id: e = "circle",
		group: t,
		sequence: n,
		frame: i,
		frameDuration: r,
		autoplay: s,
		loop: a
	}) {
		if (this.sprites[e]) {
			if (void 0 !== e) {
				this.id = e;
				const t = this.id.split("/");
				this.sequence = t.pop(), this.group = t.join("/")
			} else void 0 !== n && (void 0 !== t && (this.group = t), this.sequence = n, this.id = this.group + "/" + this.sequence);
			this.frames = this.sprites[this.id], this.frameCount = this.frames.length, this.currentFrameIndex = Math.min(i || 0, this.frameCount - 1), this.frame = this.frames[this.currentFrameIndex], this.loop = !!a, this.autoplay = !!s, this.frameDuration = r || 48, this.paused = !this.autoplay, this.frameCount < 2 ? this.end() : this.ended = !1, this.onUpdate(this.frame)
		}
	}
	end() {
		this.ended = !0, this.onEndOnce(this.frame), this.onEndOnce = aP, this.onEnd(this.frame)
	}
	play() {
		this.paused = !1, this.isBackwards = !1, this.ended = !1
	}
	playBackwards() {
		this.paused = !1, this.isBackwards = !0, this.ended = !1
	}
	reset() {
		this.ended = !1, this.paused = !1, this.currentFrameIndex = 0
	}
	resetFrame() {
		this.currentFrameIndex = 0, this.frame = this.frames[this.currentFrameIndex]
	}
	pause() {
		this.paused = !0
	}
	nextFrame() {
		let e = this.currentFrameIndex + 1;
		if (e >= this.frameCount) {
			if (!this.loop) return void this.end();
			e = 0
		}
		e !== this.currentFrameIndex && (this.currentFrameIndex = e, this.frame = this.frames[this.currentFrameIndex], !this.loop && e + 1 >= this.frameCount && this.end())
	}
	previousFrame() {
		let e = this.currentFrameIndex - 1;
		if (e < 0) {
			if (!this.loop) return void this.end();
			e = this.frameCount
		}
		e !== this.currentFrameIndex && (this.currentFrameIndex = e, this.frame = this.frames[this.currentFrameIndex], !this.loop && e - 1 < 0 && this.end())
	}
	update(e) {
		this.ended || this.paused || (this.frameTimer <= 0 && (this.frameTimer = Math.max(0, this.frameDuration + this.frameTimer), this.isBackwards ? this.previousFrame() : this.nextFrame()), this.frameTimer -= e)
	}
	destroy() {
		this.sprites = this.frames = this.frame = this.onUpdate = null
	}
}
const lP = new Bb;
let cP, uP, hP, dP, pP;
class fP {
	constructor(e) {
		cP || (cP = Nl()), this.isComponent = !0, e.batcher && (this.batcher = e.batcher, e.atlas = this.batcher.atlas, e.batcher = null), this.dummy = lP, this.position = new zx, this.scale = new Cx(1, 1), this.quaternion = new Fx, this.color = new aw(16777215), e.useEuler && (this.useEuler = !0, this.rotation = new Tb), this.alpha = null != e.alpha ? e.alpha : 1, this.initialAlpha = this.alpha, this.visible = !0, this.parent = e.parent || null, this.billboard = !!e.billboard, this.angle = 0, e.position && this.position.copy(e.position), null != e.color && ("number" == typeof e.color ? this.color.set(e.color) : this.color.copy(e.color)), e.scale && ("number" == typeof e.scale ? this.scale.setScalar(e.scale) : this.scale.copy(e.scale)), e.quaternion && this.quaternion.copy(e.quaternion), this.sprite = new oP(l(o({}, e), {
			id: e.sprite || e.id
		})), this.batcher && this.batcher.addInstance(this), this.init(e), this.sprite.update(1)
	}
	init() {}
	update() {
		const e = cP.time.stableDt;
		this.sprite.update(e)
	}
	destroy() {
		this.batcher && this.batcher.removeInstance(this), this.parentComponent && this.parentComponent.removeComponent(this), this.sprite.destroy(), this.sprite = this.batcher = null, this.props = null
	}
}
class mP extends fP {
	constructor(e) {
		uP = Nl(), hP = uP.game, super({
			sprite: "raysA",
			batcher: uP.particles.batcherDepth,
			parent: e.car.base,
			useEuler: !0,
			scale: 2.5,
			alpha: 0
		}), this.bright = new aw(16777215), this.dark = new aw(0), this.color.copy(this.dark), this.car = e.car.base, this.rotation.y = -Math.PI / 2, this.position.set(.36, .05, 0), this.opacity = 0, this.targetOpacity = 1, uP.game.hooks.reset.watch(this.reset, this)
	}
	reset() {
		this.opacity = 0, this.targetOpacity = 0
	}
	update() {
		const e = hP.turbo.hover,
			t = uP.turboline.getZAt(hP.progress + .2);
		this.targetOpacity = e ? 1 : 0;
		const n = ky(Ny(Math.abs(t - this.car.position.z), .28, .1), 0, 1);
		this.targetOpacity *= n, this.opacity = zy(this.opacity, this.targetOpacity, e ? .08 : .12), this.alpha = 1 - this.opacity, this.color.lerpColors(this.dark, this.bright, this.opacity), this.position.z = t - this.car.position.z, this.rotation.x += .02
	}
}
const gP = new zx,
	vP = new zx,
	_P = new zx,
	yP = new Cx;
new Fx;
class xP extends ZA {
	init({
		car: e
	}) {
		dP = Nl(), pP = dP.game, this.car = e, this.base = null, this.addComponent(mP, {
			car: e
		}), pP.turbo.active.watch(this.onTurbo, this), pP.hooks.reset.watch(this.reset, this), this.reset()
	}
	reset() {
		this.hoverInfluence = 0, this.turboInfluence = 0
	}
	onTurbo(e) {
		e && (dP.car.base.getWorldPosition(gP), pP.particles.emit("flash", {
			amount: 1,
			position: gP.set(-.7, .1, 0),
			scale: yP.set(5, 3),
			duration: 1200,
			parent: dP.car.base,
			power: 1,
			sprite: "raysA"
		}))
	}
	lineEmit() {
		const e = pP.state.hasEnded() && dP.gameCam.activeInfluence < .68,
			t = pP.turbo.active.value,
			n = pP.turbo.hover,
			i = e || t ? 1 : this.hoverInfluence;
		if (!e && !n && !t) return;
		if (!(dP.quality.current.value >= 4 || dP.time.frameNum % 3)) return;
		const r = dP.car.base;
		let s = (Math.random() > .5 ? dP.car.ltl : dP.car.rtl).getWorldPosition(_P);
		if (e) {
			const e = .015 + .3 * ky(Ny(dP.game.progress - dP.game.checkpoints.list.finish, 10, 22), 0, 1);
			return void pP.particles.emit("line", {
				position: _P,
				sprite: "particleA",
				scale: yP.setScalar(e),
				billboard: !0,
				opacity: .7,
				velDrag: .99,
				velocity: gP.set(0, .002, 0)
			})
		}
		s = r.worldToLocal(gP.copy(_P));
		const a = .015;
		s.x -= .01, s.y += TA.randomFloat(-.015, a), s.z += TA.randomFloat(-.015, a);
		const o = vP.set(t ? 3 : 1, 0, dP.car.zVelocity * pP.velocity * .02),
			l = t ? yP.set(TA.randomFloat(.03, .05), .06) : yP.set(TA.randomFloat(.03, .05), .05);
		i > 1e-4 && pP.particles.emit("line", {
			position: s,
			parent: r,
			sprite: "particleA",
			scale: l,
			billboard: !0,
			opacity: i,
			velDrag: .99,
			velocity: o
		})
	}
	tireSmoke() {
		if (dP.quality.current.value < 4) return;
		const e = dP.car.base,
			t = Math.random() > .5,
			n = t ? dP.car.ltl : dP.car.rtl,
			i = Ny(Math.abs(dP.controls.turn), .3, 1) * ky(Ny(Math.abs(dP.car.base.rotation.y), .03, .08), 0, 1) * .5,
			r = ky(Ny(pP.velocity, 5, 15), 0, 1) * ky(pP.turbo.progress, .4, 1) * this.hoverInfluence;
		let s = Math.max(i, r);
		(pP.turbo.active.value || t && dP.car.dipLeft || !t && dP.car.dipRight) && (s = 1), n.getWorldPosition(gP);
		const a = e.worldToLocal(gP),
			o = TA.randomFloat(1, 6.5);
		a.x -= .05 * o, a.y += TA.randomFloat(-.02, .02), a.z += TA.randomFloat(-.04, .04), a.y -= .03, a.z += t ? -.02 : .02;
		const l = vP.set(1.5, 0, 4 * dP.car.zVelocity);
		l.multiplyScalar(.005 * pP.velocity);
		const c = pP.turbo.active.value ? .1 : .8;
		pP.particles.emit("smoke", {
			position: a,
			parent: e,
			sprite: "smoke",
			scale: yP.setScalar(TA.randomFloat(.2, 1)),
			billboard: !0,
			angle: TA.randomFloat(0, Math.PI),
			opacity: .18 * s,
			velDrag: .95,
			velocity: l.set(3, -c, 0).multiplyScalar(.02)
		})
	}
	update() {
		super.update();
		const e = dP.time.stableDt;
		this.hoverInfluence = Vy(this.hoverInfluence, pP.turbo.hover ? 1 : 0, .2, e, .001), this.turboInfluence = By(this.turboInfluence, pP.turbo.active.value ? 1 : 0, .15, e), pP.turbo.active.value && (this.hoverInfluence = 1);
		const t = dP.scene.currentCamera;
		t && t.isGameCamera && (this.lineEmit(), this.tireSmoke())
	}
}
let bP, wP;
const SP = new aw(3355443),
	MP = new aw(0);
AA();
const TP = new zx(.4, 0, 1.01),
	CP = new zx(-.47, 0, 1.01),
	EP = new zx;
class AP extends ZA {
	init() {
		bP = Nl(), wP = bP.game, this.flare = this.addComponent(fP, {
			sprite: "particleA",
			parent: bP.pointer.base,
			position: CP,
			alpha: .6,
			color: SP,
			scale: 2.5,
			batcher: wP.particles.batcher,
			billboard: !0
		}), this.reset(), wP.hooks.reset.watch(this.reset, this)
	}
	reset() {
		this.now = this.lastEmit = this.lastFlash = bP.game.elapsed, this.bigFlashed = !1, this.flareOpacity = this.flareOpacityTarget = 0
	}
	emit() {
		const e = bP.car,
			t = zy(.06, .1, ky(e.dipStrength + e.userDip, 0, 1)),
			n = EP.lerpVectors(CP, TP, e.dipStrength);
		e.dipLeft && (n.z = -n.z), this.lastEmit = this.now, wP.particles.emit("hitSparkles", {
			amount: 2,
			position: n,
			parent: bP.pointer.base,
			sprite: "particleA",
			scale: t,
			velDrag: .99
		})
	}
	bigFlash() {
		const e = bP.car,
			t = EP.lerpVectors(CP, TP, e.dipStrength);
		e.dipLeft && (t.z = -t.z);
		const n = e.userDip ? 2 : 1,
			i = ky(Ny(e.dipStrength * n * wP.velocity, 2, 14), 0, 1),
			r = zy(5, 9, i),
			s = zy(500, 800, i);
		this.bigFlashed = !0, wP.particles.emit("flash", {
			amount: 1,
			position: t,
			scale: r,
			duration: s,
			parent: bP.pointer.base,
			power: i,
			sprite: "particleA"
		})
	}
	update() {
		const e = bP.time.stableDt,
			t = bP.car,
			n = t.userDip ? 20 : 85;
		this.now = bP.game.elapsed, t.dip && t.dipStrength > .1 && !this.bigFlashed && this.bigFlash(), t.dip && this.now - this.lastEmit > n && this.emit(), t.dip || (this.bigFlashed = !1), this.flareOpacityTarget = 0, t.dip && (this.flareOpacityTarget = 1 - .12 * Math.cos(.07 * bP.game.elapsed), t.userDip || (this.flareOpacityTarget *= .4), this.flare.position.z = (t.dipRight ? 1 : -1) * CP.z), this.flareOpacity = By(this.flareOpacity, this.flareOpacityTarget, t.dip ? .3 : .1, e), this.flare.alpha = zy(1, .5, this.flareOpacity), this.flare.color.lerpColors(MP, SP, this.flareOpacity), this.flare.visible = this.flareOpacity > .001
	}
}
let PP, LP;
AA();
const IP = 2 * Math.PI,
	DP = new zx;
new zx, new Fx;
const RP = new aw(16777215),
	kP = new aw(11158596);
al(.295, .03, .99, .555);
const NP = al(0, .59, .29, 1);
al(.16, .035, .29, .96);
class OP extends ZA {
	init() {
		PP = Nl(), LP = PP.game, PP.car = LP.car = this, this.base = PP.meshes.car;
		const e = this.body = this.base.body,
			t = this.wheels = this.base.wheels;
		e.frustumCulled = t.frustumCulled = !1;
		e.position.x = t.position.x = -.18, e.origPosition = e.position.clone(), t.material = e.material = sP.get(), t.renderOrder = e.renderOrder = PP.store.renderOrder.car, t.castShadow = e.castShadow = !0, t.receiveShadow = e.receiveShadow = !1, e.rotation.x = 0, this.dumWheels = this.base.dummyWheels, this.initWheels(), this.addComponent(xP, {
			car: this
		}), this.hitFx = this.addComponent(AP, {
			car: this
		}), this.ltl = new Bb, this.ltl.rotation.y = -.5 * Math.PI, this.ltl.position.set(-.65, .145, -.135), this.ltl.scale.setScalar(.2), this.rtl = new Bb, this.rtl.rotation.y = -.5 * Math.PI, this.rtl.position.set(-.65, .145, .135), this.rtl.scale.setScalar(.2), this.body.add(this.ltl), this.body.add(this.rtl), this.dipStrength = 0, this.bbw = .3 * e.scale.z, this.hitline = new QE, this.turboline = new QE, this.baseQuaternion = this.base.quaternion.clone(), this.prevWorldPos = new zx, this.velocity = new zx, this.reset(), LP.hooks.reset.watch(this.reset, this), LP.turbo.active.watch(this.onTurbo, this), PP.store.shadowActive.watchImmediate((n => {
			t.castShadow = e.castShadow = n
		})), LP.paused.watch((() => this.resetFrictionSample()))
	}
	resetFrictionSample() {
		this.frictionSample && this.frictionSample.stop(), this.frictionSample = null, this.lastFrictionDate = 0
	}
	reset() {
		LP.velocity = 0, this.prevWorldPos.setScalar(0), this.velocity.setScalar(0), this.prevZ = 0, this.zVelocity = 0, this.resetFrictionSample(), this.frictionVolume = 1, this.bloom = .5, this.bloomTarget = .5, this.dipShake = this.targetDipShake = 0, this.dipStrength = 0, this.userDip = !1, this.dip = !1, this.camHitShake = !1, this.turboInfluence = 0, this.autoInfluence = 0, this.accumRotation = 0, this.wheelSteering = 0, this.bodySteer = 0, this.wheelSpin = 0, this.wheelSteer = 0, this.wheelSpinSpeed = 0, this.controlsSteer = 0, this.base.position.set(0, 0, 0), this.noDipTime = 0, this.last, this.acceleration = .03, this.maxVel = LP.minVelocity, this.lastTurbo = -1e5, this.update()
	}
	onTurbo(e) {
		e || (this.lastTurbo = PP.game.elapsed)
	}
	updateVelocity() {
		const e = PP.time.stableDt,
			t = PP.scene.currentCamera;
		if (t.forceCarVelocity) return void(LP.velocity = t.forceCarVelocity);
		if (LP.state.current < LP.state.ACTIVE) return void(LP.velocity = 0);
		const n = LP.turbo.active.value,
			i = !n && !LP.turbo.cooldownActive,
			r = LP.turbo.hover;
		if (this.acceleration = By(this.acceleration, n ? .08 : .03, .1, e), !n) {
			const t = zy(LP.minVelocity, LP.maxVelocity, LP.turbo.velProgress);
			(!r && i || LP.turbo.ended || t > this.maxVel) && (this.maxVel = By(this.maxVel, t, .1, e))
		}
		let s = this.maxVel;
		if (n && (s = LP.turboVelocity), this.dip && !n && i) {
			const e = ky(Oy(this.dipStrength, .01, .02, 0, 1), 0, 1);
			if (e) {
				const t = .75,
					n = ky(Oy(LP.velocity, 2, LP.maxVelocity, 1, t), t, 1);
				s = this.maxVel = zy(this.maxVel, this.maxVel * n, e)
			} else s *= this.userDip ? .92 : .97
		}
		const a = PP.time.stableDt / 16.6667;
		LP.velocity < s ? LP.velocity += this.acceleration * a : LP.velocity = By(LP.velocity, s, .1, e)
	}
	update() {
		if (LP.isPaused()) return;
		const e = LP.getRoadData(),
			t = LP.velocity;
		this.autoInfluence = zy(this.autoInfluence, LP.autopilot.value ? 1 : 0, LP.autopilot.value ? .07 : .14);
		const n = 1 - this.autoInfluence;
		this.base.quaternion.copy(this.baseQuaternion);
		const i = LP.velocity / 10,
			r = ky(t / 10, 0, 1),
			s = 1 - NP(ky(t / 4, 0, 1)),
			a = NP(ky(t / 3, 0, 1)),
			o = ky(t / 3, 0, 1),
			l = PP.controls.keyboard ? PP.controls.steeringMultKeyboard : PP.controls.steeringMultTouch,
			c = a * (Oy(t / 10, 0, 1, 0, .015) + .004 * s) * l,
			u = .15 * a * (PP.controls.keyboard ? PP.controls.rotationMultKeyboard : PP.controls.rotationMultTouch),
			h = LP.getRelativeRoadData(.9);
		LP.pointer.base.worldToLocal(DP.copy(h.position));
		const d = PP.time.stableDt,
			p = d / 16.6667,
			f = Math.atan2(DP.z, DP.x) * p;
		this.accumRotation += .16 * f * i * n, this.base.rotation.y += this.accumRotation;
		let m = ky(-1 + this.base.rotation.y, -1, 0),
			g = ky(1 + this.base.rotation.y, 0, 1);
		this.dipRight && (g = 0), this.dipLeft && (m = 0);
		let v = PP.controls.turn * n;
		v = ky(v * c, m, g), this.accumRotation -= v, this.base.rotation.y -= v, this.base.position.z += this.base.rotation.y * -u * i * p, this.base.rotation.y += .5 * v, this.wheelSteering = v;
		const _ = .5 * e.scale.y - this.bbw;
		this.dipStrength = ky(Ny(Math.abs(this.accumRotation), 0, .7), 0, 1);
		const y = PP.controls.turnTarget;
		if (this.dipLeft = this.base.position.z < -_ - 0, this.dipRight = this.base.position.z > _ + 0, this.dip = this.dipLeft || this.dipRight, this.userDip = (this.dipLeft && y) < 0 || this.dipRight && y > 0, this.dip && this.dipStrength > .04 && !this.didImpact ? (this.didImpact = !0, PP.audio.playSound("Car_Impact", {
				volume: zy(.4, 1.15, this.dipStrength)
			})) : this.dip || (this.didImpact = !1), this.dip ? this.noDipTime = 0 : this.noDipTime += d, this.dip && !this.camHitShake && this.dipStrength > .007 && !LP.turbo.active.value) {
			this.camHitShake = !0;
			const e = Math.min(.22 * this.dipStrength * i * 1 * (this.userDip ? 1.2 : .9), this.userDip ? 1.25 : .75);
			PP.gameCam.shake(400 + 200 * e, e, !1, !0)
		} else this.dip || (this.camHitShake = !1);
		if (this.dip && !this.frictionSample && PP.game.elapsed - this.lastFrictionDate > 500 ? this.frictionSample = PP.audio.playSound("Car_Friction_Loop") : this.noDipTime > 200 && this.frictionSample && (this.resetFrictionSample(), this.lastFrictionDate = PP.game.elapsed), this.frictionSample && (this.frictionSample.volume = zy(this.frictionSample.volume, this.userDip ? 1.5 : .9, .1)), Math.abs(this.base.position.z) > _ && (this.accumRotation += -.18 * this.base.rotation.y * i), this.dip) {
			const e = this.base.position.z;
			this.base.position.z = ky(e, -_, _)
		}
		this.autoInfluence > .01 && (this.accumRotation -= .02 * this.accumRotation * i * this.autoInfluence, this.base.position.z -= .01 * this.base.position.z * this.autoInfluence), PP.store.carShadow.set(.5 * this.base.position.z, this.base.rotation.y), this.base.updateMatrixWorld(), this.updateHitLine(), this.wheelSteer = zy(this.wheelSteer, .26 * PP.controls.turn, PP.controls.active ? zy(.05, .5, r) : .9), this.bodySteer = zy(this.bodySteer, PP.controls.turn * zy(.05, .06, r) * o, zy(.05, .15, r)), this.body.rotation.x = ky(this.bodySteer, -.07, .07), this.body.rotation.z = ky(this.body.rotation.z, -.025, .04), this.wheelSpinSpeed = .015 * t, this.wheelSteer = ky(this.wheelSteer, -.5, .5), this.wheelSpinSpeed = ky(this.wheelSpinSpeed, -.1, .1), this.wheelSpin = (this.wheelSpin + this.wheelSpinSpeed) % IP, this.updateWheels(), this.body.position.copy(this.body.origPosition);
		const x = PP.game.elapsed,
			b = ky(Ny(LP.velocity, 6, 15), 0, 1),
			w = .01 * Ny(LP.velocity, 7, 15),
			S = .0035 * (.5 * Math.cos(x * (.07 + w)) + .5) * b;
		if (this.body.translateY(S), this.dip || this.dipShake > .001) {
			const e = this.dip ? this.userDip ? .0038 : .0015 : 0;
			this.targetDipShake = e, this.dipShake = zy(this.dipShake, this.targetDipShake, this.dip ? .1 : .25);
			const t = Math.cos(.09 * x) * this.dipShake + this.dipShake;
			this.body.translateY(t)
		}
		this.zVelocity = this.base.position.z - this.prevZ, this.prevZ = this.base.position.z, this.updateMaterial(), super.update()
	}
	updateHitLine() {
		this.base.localToWorld(DP.set(.4, 0, -this.bbw - .04)), this.hitline.start.copy(DP), this.base.localToWorld(DP.set(.4, 0, this.bbw - -.04)), this.hitline.end.copy(DP), PP.turboline.testCollision(this.hitline)
	}
	initWheels() {
		for (let e = 0, t = this.dumWheels.length; e < t; e++) {
			const t = this.dumWheels[e];
			t.steerMult = 2 === e ? 1 : 3 === e ? -1 : 0, t.rotation.reorder("XZY")
		}
	}
	updateWheels() {
		for (let e = 0, t = this.dumWheels.length; e < t; e++) {
			const t = this.dumWheels[e],
				n = t.rotation,
				i = this.wheelSteer * t.steerMult;
			n.y += this.wheelSpin, n.z += i, t.updateWorldMatrix(!0, !1), this.wheels.setMatrixAt(e, t.matrixWorld), n.y -= this.wheelSpin, n.z -= i
		}
		this.wheels.instanceMatrix.needsUpdate = !0
	}
	updateMaterial() {
		const e = PP.time.stableDt,
			t = this.body.material.uniforms,
			n = LP.turbo.progress;
		t.turboProgress.value = Oy(n, 0, 1, .983, .9489), t.turboColor.value.lerpColors(kP, RP, n);
		const i = LP.state.hasEnded() && PP.gameCam.activeInfluence < .7;
		PP.scene.currentCamera && !PP.scene.currentCamera.isGameCamera || i || LP.turbo.hover || LP.turbo.active.value ? this.bloomTarget = 1 : this.bloomTarget = .4, this.bloom = By(this.bloom, this.bloomTarget, .08, e), t.bloomStrength.value = this.bloom
	}
}
var FP = fA("#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvarying vec2 vUv;void main(){vUv=uv;\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\n#include <worldpos_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}", "#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvarying vec2 vUv;uniform float scale;uniform float dirOpacity;uniform vec2 car;vec2 rotate(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,-s,s,c);return m*v;}float fakeShadow(vec2 center,vec2 size,float radius){return length(max(abs(center)-size+radius,0.0))-radius;}void main(){vec2 uv=vUv;vec3 color=vec3(0.459,0.2,0.157);float shadow=1.*(1.0-getShadowMask());shadow*=0.2*min(smoothstep(0.5,0.3,abs(uv.x-0.5)),smoothstep(0.5,0.45,abs(uv.y-0.5)))*dirOpacity;vec2 pivot=vec2(0.5,0.5-car.x);vec2 box=rotate(vUv-pivot,car.y)+0.5;box-=vec2(0.431,0.5);float ao=fakeShadow(box,vec2(-0.126,-0.24),-0.28);ao=smoothstep(0.42,0.22,ao)*0.8+smoothstep(0.35,0.3,ao)*0.6;shadow+=ao;color=vec3(1.-shadow);gl_FragColor=vec4(color,1.);\n#include <tonemapping_fragment>\n#include <encodings_fragment>\n#include <fog_fragment>\n}");
let zP, UP, BP = null;
class VP extends jw {
	constructor(e = {}) {
		super(e), this.uniforms = o(o({
			scale: {
				value: 0
			},
			car: {
				value: Ol.store.carShadow
			},
			dirOpacity: {
				value: 1
			}
		}, e.uniforms || {}), qw.clone(uS.shadow.uniforms)), FP.use(this), this.blending = 4, this.opacity = .2, this.color = new aw(0), this.forceOpaque = !0, this.depthTest = !1, this.depthWrite = !1, this.lights = !0, this.isShaderMaterial = !0
	}
}
VP.get = e => BP = BP || new VP(e);
class HP extends ZA {
	init() {
		zP = Nl(), UP = zP.game, this.base = new Bw(zP.geometries.plane, VP.get()), this.base.renderOrder = zP.store.renderOrder.carShadow, this.base.receiveShadow = !0, this.base.position.y += .001, this.base.rotateX(-.5 * Math.PI);
		const e = 3 * this.props.car.body.scale.x;
		this.base.scale.x = e
	}
	update() {
		const e = UP.getRoadData().scale.y;
		this.base.scale.y = e, this.base.material.uniforms.scale.value = e / 2
	}
}

function GP(e) {
	e.blending = 5, e.blendEquation = 100, e.blendSrc = 201, e.blendDst = 201, e.blendEquationAlpha = 103
}
var WP = fA("attribute float progress;attribute float side;varying float vProgress;varying float vX;void main(){vProgress=progress;vX=side;vec3 transformed=vec3(position);gl_Position=projectionMatrix*modelViewMatrix*vec4(transformed,1.0);}", "varying float vProgress;varying float vX;uniform float time;uniform float globalProgress;uniform float width;uniform float opacity;uniform vec2 hitA;uniform vec2 hitB;uniform vec2 clamping;\n#include <conditionals>\nfloat between(float x,vec2 hit){return min(1.,smoothstep(hit.x+0.25,hit.x-0.25,x)+smoothstep(hit.y-0.25,hit.y+0.25,x));}void main(){float x=vX;vec2 uv=vec2(vX,mod(vProgress/width*0.15,1.));vec3 c=vec3(uv,0.);float w=0.1;float alpha=1.;alpha*=(1.-abs(uv.x-0.5)*2.);alpha*=between(vProgress,hitA)*between(vProgress,hitB);alpha*=smoothstep(clamping.x,clamping.x+3.,vProgress);alpha*=smoothstep(clamping.y,clamping.y-5.,vProgress);float fog=(globalProgress-vProgress)*0.05+2.8;alpha*=fog;alpha*=opacity;float intensity=max(0.,alpha-gl_FragCoord.w*1.);gl_FragColor=vec4(vec3(1.,1.,1.)*alpha,1.-intensity);}");
let qP = null;
class jP extends jw {
	constructor(e = {}) {
		super(e), this.uniforms = o({
			width: {
				value: .2
			},
			globalProgress: {
				value: 0
			},
			opacity: {
				value: 1
			},
			time: {
				value: 0
			},
			hitA: {
				value: [0, 1]
			},
			hitB: {
				value: [0, 1]
			},
			clamping: {
				value: [0, 1]
			}
		}, e.uniforms || {}), this.side = 2, GP(this), this.color = new aw, this.transparent = 1, this.forceOpaque = !0, WP.use(this), this.isShaderMaterial = !0
	}
	set width(e) {
		this.uniforms.width.value = e
	}
	get width() {
		return this.uniforms.width.value
	}
}
jP.get = e => qP = qP || new jP(e);
const YP = AA((() => 35410));
let XP, $P;
const ZP = new zx,
	KP = new zx;
new Fx;
class JP extends ZA {
	init() {
		XP = Nl(), $P = XP.game, XP.turboline = $P.turboline = this, this.line = new QE, this.lastProgress = -100, this.y = .04, this.segments = 120, this.step = .5, this.offset = -3, this.width = .033;
		const e = 2 * this.segments,
			t = this.vertices = e + 2;
		this.geo = new ww, this.buffer = new Float32Array(4 * t), this.ibuffer = new XT(this.buffer, 4), this.ibuffer.setUsage(35048), this.geo.setAttribute("position", new ZT(this.ibuffer, 3, 0, !1)), this.geo.setAttribute("progress", new ZT(this.ibuffer, 1, 3, !1)), this.geo.setAttribute("side", new hw(t, 1)), this.geo.setIndex(new Array(3 * e)), this.pts = this.geo.attributes.position.array, this.indexes = this.geo.index.array, this.sides = this.geo.attributes.side.array, this.initGeo(), this.updateGeo(), this.geo.needsUpdate = !0, this.base = new Bw(this.geo, jP.get()), this.base.frustumCulled = !1, this.base.renderOrder = XP.store.renderOrder.turboLine, this.base.material.width = this.width, this.collideUniforms = [this.base.material.uniforms.hitA.value, this.base.material.uniforms.hitB.value], this.currentCollideUniform = 0, this.colliding = !1, $P.hooks.reset.watch(this.reset, this), this.reset(), $P.turbo.active.watch(this.onTurboActive, this);
		let n = !1;
		XP.hooks.beforePrerender.watchOnce((() => {
			n = this.base.visible, this.base.visible = !0
		})), XP.hooks.afterPrerender.watchOnce((() => {
			this.base.visible = n
		}))
	}
	stopHitSample() {
		this.hitSample && this.hitSample.stop(), this.hitSample = null
	}
	reset() {
		this.stopHitSample(), this.hitSampleVolume = 0, this.turboCount = 0, $P.turbo.ended = !1;
		for (const t of this.collideUniforms) t[0] = 0, t[1] = 0;
		const e = $P.checkpoints.list;
		this.base.material.uniforms.clamping.value[0] = e.start + 20, this.base.material.uniforms.clamping.value[1] = e.finish - 20, this.currentCollideUniform = 0, this.colliding = !1, this.update(!0), this.resetting = !0
	}
	initGeo() {
		const e = this.indexes;
		for (let n = 0, i = 0; n < e.length; n += 3, i++) {
			const t = i % 2;
			e[n] = t ? i + 2 : i, e[n + 1] = i + 1, e[n + 2] = t ? i : i + 2
		}
		const t = this.sides;
		for (let n = 0; n < this.vertices; n += 2) t[n] = 0, t[n + 1] = 1
	}
	getZAt(e) {
		const t = .4 * ky(Ny(this.turboCount, 2, 6), 0, 1);
		return .05 * Math.cos(.1 * e) + YP(e * (.02 + .01 * t), 1) * t
	}
	updateGeo(e) {
		const t = $P.progress - $P.progress % (this.offset * this.step);
		if (!e && t === this.lastProgress) return;
		this.lastProgress = t;
		const n = this.offset,
			i = this.step,
			r = this.pts;
		for (let s = 0, a = 0; s < this.pts.length; s += 8, a += 1) {
			const e = t + (a + n) * i,
				o = $P.normalizeProgress(e),
				l = $P.getAbsoluteRoadData(o),
				c = this.width,
				u = this.y,
				h = this.getZAt(e),
				d = ZP.set(0, u, -c + h).applyQuaternion(l.quaternion).add(l.position),
				p = KP.set(0, u, c + h).applyQuaternion(l.quaternion).add(l.position);
			r[s] = d.x, r[s + 1] = d.y, r[s + 2] = d.z, r[s + 3] = e, r[s + 4] = p.x, r[s + 5] = p.y, r[s + 6] = p.z, r[s + 7] = e
		}
		this.geo.attributes.position.needsUpdate = !0
	}
	update(e) {
		this.resetting ? (this.turboCount = 0, this.resetting = !1, this.updateGeo(!0)) : this.updateGeo();
		const t = XP.scene.currentCamera && XP.scene.currentCamera.turbolineActive;
		this.base.visible = !!t, $P.turbo.hover !== this.hit && (this.hit = $P.turbo.hover, this.hit ? this.startCollision() : this.endCollision());
		const n = this.base.material.uniforms;
		if (n.globalProgress.value = XP.game.progress, n.time.value = XP.game.elapsed, this.hit) {
			const e = this.collideUniforms[this.currentCollideUniform],
				t = XP.game.progress + .5,
				n = t - e[1];
			XP.game.turbo.addHitDistance(n), e[1] = t
		}
		if (!this.hit && this.hitSample && this.hitSample.volume < 1e-4 && this.stopHitSample(), this.hit && !this.hitSample && (this.hitSample = XP.audio.playSound("Boost_Line_Loop", {
				volume: .05
			})), this.hitSample) {
			const e = this.hit && !XP.game.paused.value;
			this.hitSampleVolume = e ? 1.2 : 0, this.hitSample.volume = zy(this.hitSample.volume, this.hitSampleVolume, e ? .12 : .07)
		}
		const i = $P.turbo.active.value || $P.turbo.ended;
		n.opacity.value = zy(n.opacity.value, i ? 0 : 1, e ? 1 : .1)
	}
	startCollision() {
		const e = this.collideUniforms[this.currentCollideUniform],
			t = XP.game.progress + .5;
		e[0] = t, e[1] = t
	}
	endCollision() {
		this.currentCollideUniform = (this.currentCollideUniform + 1) % this.collideUniforms.length
	}
	onTurboActive(e) {
		if (e) return;
		this.turboCount++;
		const t = $P.progress,
			n = this.base.material.uniforms.clamping.value;
		n[0] = t + $P.turbo.cooldown, Math.abs(n[0] - n[1]) < $P.turbo.distanceToFill && ($P.turbo.ended = !0), this.updateGeo(!0)
	}
	testCollision(e) {
		const t = $P.progress,
			n = t - .1,
			i = t + .8,
			r = this.getZAt(n),
			s = this.getZAt(i),
			a = this.base.material.uniforms.clamping.value;
		if (!this.base.visible || $P.turbo.active.value || t < a[0] - 1 || t > a[1] + 1 || $P.turbo.ended) return $P.turbo.hover = !1;
		const o = $P.getAbsoluteRoadData($P.normalizeProgress(n));
		this.line.start.set(0, 0, r).applyQuaternion(o.quaternion).add(o.position);
		const l = $P.getAbsoluteRoadData($P.normalizeProgress(i));
		this.line.end.set(0, 0, s).applyQuaternion(l.quaternion).add(l.position);
		const c = e,
			u = this.line;
		return $P.turbo.hover = function(e, t, n, i, r, s, a, o) {
			let l, c;
			const u = (n - e) * (o - s) - (a - r) * (i - t);
			return 0 !== u && (c = ((o - s) * (a - e) + (r - a) * (o - t)) / u, l = ((t - i) * (a - e) + (n - e) * (o - t)) / u, 0 < c && c < 1 && 0 < l && l < 1)
		}(c.start.x, c.start.z, c.end.x, c.end.z, u.start.x, u.start.z, u.end.x, u.end.z)
	}
}
var QP = fA("attribute float dist;attribute float side;varying float vSide;varying float vDist;void main(){vSide=side;vDist=dist;vec3 transformed=vec3(position);gl_Position=projectionMatrix*modelViewMatrix*vec4(transformed,1.0);}", "varying float vDist;varying float vSide;uniform float progress;uniform float time;uniform float maxDist;uniform sampler2D noise;uniform float trailLength;void main(){vec3 noiseTexel=texture2D(noise,vec2(vSide*0.2,vDist*0.1+progress*-0.04)).rgb;float len=trailLength;float len2=min(len*1.5,len+0.25);float m=smoothstep(0.4,0.1,noiseTexel.b)*0.5*smoothstep(len2,len2-0.4,vDist);float fallin=smoothstep(0.05,0.1,vDist);float falloff=smoothstep(trailLength+m,trailLength-0.4,vDist);float falloff2=smoothstep(maxDist+0.6,0.,vDist);float size=1.*falloff2;size+=-0.3+cos(time*-0.03+vDist*20.*vDist)*0.07;float offset=(1.-size)*0.5;float side=clamp((vSide-offset)/size,0.,1.);float p=progress*10.;float lim=abs(side-0.5)*2.;float border=pow(lim,3.)*0.5;float lim2=(1.-step(1.,side))*(1.-step(side,0.));float matter=smoothstep(0.4,0.0,noiseTexel.r)*0.5;float matter2=smoothstep(0.9,0.5,noiseTexel.g)*smoothstep(0.4,0.0,vDist);float intensity=max(0.,border+matter*1.+matter2*0.8)*lim2*falloff*fallin;vec3 diffuse=vec3(1.,0.2,0.2)*intensity*5.;float glow=1.-intensity*0.2;gl_FragColor=vec4(diffuse,glow);}");
let eL, tL, nL = null;
class iL extends jw {
	constructor(e = {}) {
		super(e), this.uniforms = {
			time: {
				value: 0
			},
			progress: {
				value: 0
			},
			maxDist: {
				value: 0
			},
			trailLength: {
				value: 0
			},
			noise: {
				value: Ol.textures.blueNoise
			}
		}, GP(this), this.color = new aw, this.transparent = 1, this.forceOpaque = !0, QP.use(this), this.isShaderMaterial = !0
	}
}
iL.get = e => nL = nL || new iL(e);
const rL = new zx,
	sL = new zx,
	aL = e => Array.from(new Array(e)).map((() => ({
		qt: new Fx,
		pos: new zx
	})));
class oL extends ZA {
	init() {
		eL = Nl(), tL = eL.game, this.turboInfluence = this.hoverInfluence = 0, this.car = this.props.car, this.geo = new ww, this.iterations = 0, this.segments = 8;
		const e = 2 * this.segments * 2,
			t = this.vertices = e + 4;
		this.ptsIndex = 0, this.leftPts = aL(t / 4), this.rightPts = aL(this.leftPts.length);
		const n = this.bufferDims = 4;
		this.buffer = new Float32Array(t * n), this.ibuffer = new XT(this.buffer, n), this.geo.setAttribute("position", new ZT(this.ibuffer, 3, 0, !1)), this.geo.setAttribute("dist", new ZT(this.ibuffer, 1, 3, !1)), this.ibuffer.setUsage(35048), this.geo.setAttribute("side", new hw(t, 1)), this.geo.setIndex(new Array(3 * e)), this.indexes = this.geo.index.array, this.sides = this.geo.attributes.side.array, this.initGeo(false), this.initGeo(true), this.mat = iL.get(), this.base = new Bw(this.geo, this.mat), this.base.renderOrder = eL.store.renderOrder.carTrails, this.base.frustumCulled = !1, this.maxDist = 0, eL.game.hooks.reset.watch(this.reset, this), this.reset();
		let i = !1;
		eL.hooks.beforePrerender.watchOnce((() => {
			i = this.base.visible, this.base.visible = !0
		})), eL.hooks.afterPrerender.watchOnce((() => {
			this.base.visible = i
		}))
	}
	reset(e) {
		this.car.ltl.updateWorldMatrix(!0, !0), this.car.rtl.updateWorldMatrix(!0, !0);
		for (let t = 0; t < this.leftPts.length; t++) this.appendPts(), this.updateGeo(false), this.updateGeo(true);
		this.reseting = !e
	}
	initGeo(e) {
		const t = this.indexes,
			n = t.length / 2,
			i = e ? n : 0,
			r = e ? this.vertices / 2 : 0;
		for (let a = i, o = r; a < n + i; a += 3, o++) {
			const e = o % 2;
			t[a] = e ? o + 2 : o, t[a + 1] = o + 1, t[a + 2] = e ? o : o + 2
		}
		const s = this.sides;
		for (let a = r; a < this.vertices / 2 + r; a += 2) s[a] = 0, s[a + 1] = 1
	}
	updateLastPts() {
		const e = 0 === this.ptsIndex ? this.leftPts.length - 1 : this.ptsIndex - 1,
			t = this.leftPts[e],
			n = this.rightPts[e];
		this.car.ltl.getWorldPosition(t.pos), this.car.ltl.getWorldQuaternion(t.qt), this.car.rtl.getWorldPosition(n.pos), this.car.rtl.getWorldQuaternion(n.qt)
	}
	appendPts() {
		let e = .014 + .021 * tL.turbo.progress;
		e = zy(e, .12, this.turboInfluence);
		tL.state.hasEnded() && eL.gameCam.activeInfluence < .75 && (e = Math.max(e, .028));
		const t = this.leftPts[this.ptsIndex],
			n = this.rightPts[this.ptsIndex];
		this.car.ltl.getWorldPosition(t.pos), this.car.ltl.getWorldQuaternion(t.qt), this.car.rtl.getWorldPosition(n.pos), this.car.rtl.getWorldQuaternion(n.qt), t.width = n.width = e, this.ptsIndex = (this.ptsIndex + 1) % this.leftPts.length
	}
	updateGeo(e) {
		const t = e ? this.rightPts : this.leftPts,
			n = e ? this.buffer.length / 2 : 0,
			i = this.buffer,
			r = t.length,
			s = r - 1,
			a = !e;
		let o = 0;
		for (let l = s; l >= 0; l--) {
			const e = (this.ptsIndex + l) % r,
				c = t[e];
			if (a)
				if (l < s) {
					o += t[(this.ptsIndex + l + 1) % r].pos.distanceTo(c.pos), c.dist = o
				} else c.dist = 0;
			else c.dist = this.leftPts[e].dist;
			let u = n + 2 * l * this.bufferDims;
			const h = rL.set(-c.width, 0, 0).applyQuaternion(c.qt).add(c.pos),
				d = sL.set(c.width, 0, 0).applyQuaternion(c.qt).add(c.pos);
			i[u++] = h.x, i[u++] = h.y, i[u++] = h.z, i[u++] = c.dist, i[u++] = d.x, i[u++] = d.y, i[u++] = d.z, i[u++] = c.dist
		}
		a && (this.maxDist = o), this.geo.attributes.position.needsUpdate = !0
	}
	update() {
		this.reseting && this.reset(!0);
		const e = eL.scene.currentCamera;
		if (!e || !e.isGameCamera) return this.base.visible = !1, void(this.visible = !1);
		this.base.visible = !0, this.visible = !0, this.appendPts(), this.updateGeo(false), this.updateGeo(true);
		const t = eL.time.stableDt,
			n = this.mat.uniforms;
		n.time.value = tL.elapsed, n.progress.value = tL.progress, n.maxDist.value = this.maxDist;
		const i = tL.turbo.hover,
			r = tL.turbo.active.value,
			s = tL.state.hasEnded() && eL.gameCam.activeInfluence < .5;
		n.trailLength.value = s ? By(n.trailLength.value, 3.5, .019, t) : By(n.trailLength.value, r ? 1 : i ? .35 + .1 * tL.turbo.progress : 0, r ? .3 : i ? .1 : .02, t)
	}
}
let lL;
class cL extends ZA {
	init() {
		lL = Nl(), lL.road = this, this.base = new Bb, lL.getRoadDataAt = fx("getRoadDataAt", this, 2), this.curve = lL.curves.road, this.road = this.add(lL.meshes.road), this.road.material = tP.get(), this.road.renderOrder = lL.store.renderOrder.road, this.road.castShadow = !1, this.road.receiveShadow = !1, this.pointer = this.addComponent(nP), lL.pointer = lL.game.pointer = this.pointer, this.line = this.addComponent(JP), this.car = this.addComponent(OP, {
			mountTo: this.pointer
		}), this.carShadow = this.addComponent(HP, {
			mountTo: this.pointer,
			car: this.car
		}), this.carTrails = this.addComponent(oL, {
			car: this.car
		}), this.alphaInfluence = 1
	}
	update() {
		super.update();
		this.road.material.uniforms.speedInfluence.value = ky(Ny(lL.game.velocity, 7.3, 14), 0, 1) * lL.scene.gameCam.activeInfluence
	}
}
const uL = new zx,
	hL = new zx;
class dL extends ZA {
	constructor(e) {
		super(e), this.base = null
	}
	init(e) {
		this.dirLightPos = new zx(0, .4, 1).multiplyScalar(2), this.shadowSize = .85;
		const t = this.ambLight = new FE(16777215, 1),
			n = this.dirLight = new OE(16019554, .5);
		n.position.copy(this.dirLightPos), n.castShadow = !0, n.shadow.camera.near = .4, n.shadow.camera.far = 10, n.shadow.camera.fov = 50, n.shadow.camera.top = this.shadowSize, n.shadow.camera.bottom = -this.shadowSize, n.shadow.camera.left = this.shadowSize, n.shadow.camera.right = -this.shadowSize, this.setShadowSize(128), e.scene.add(t), e.scene.add(n)
	}
	setShadowSize(e = 128) {
		this.dirLight.shadow.mapSize.width !== e && (this.dirLight.shadow.mapSize.width = e, this.dirLight.shadow.mapSize.height = e, this.dirLight.shadow.map && (this.dirLight.shadow.map.dispose(), this.dirLight.shadow.map = null))
	}
	toggleShadow(e) {
		const t = Ol.threeRenderer;
		Ol.store.shadowActive.set(e), t.shadowMapAutoUpdate = e;
		const n = t.getRenderTarget();
		t.setRenderTarget(this.dirLight.shadow.map), t.clear(), t.setRenderTarget(n)
	}
	update() {
		const e = this.props.scene.road.car.base,
			t = this.props.scene.road.carShadow.base;
		this.dirLight.target = e, this.dirLight.position.copy(e.getWorldPosition(uL)).add(this.dirLightPos), t.worldToLocal(hL.copy(this.dirLight.position));
		const n = ky(Ny(hL.z, .04, .6), 0, 1);
		t.material.uniforms.dirOpacity.value = n
	}
}
var pL = fA("#define PHONG\nvarying vec3 vViewPosition;varying float vY;\n#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main(){\n#include <uv_vertex>\n#include <beginnormal_vertex>\n#include <defaultnormal_vertex>\n#include <normal_vertex>\n#include <begin_vertex>\n#include <project_vertex>\nvViewPosition=-mvPosition.xyz;\n#include <worldpos_vertex>\nvY=worldPosition.y;\n#include <envmap_vertex>\n#include <shadowmap_vertex>\n#include <fog_vertex>\n}", "#define PHONG\n#define NEON\n#define STRUCTURE\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <bg_fog_pars>\n#include <conditionals>\n#include <luma>\nuniform vec3 diffuse;uniform vec3 emissive;uniform vec3 specular;uniform float shininess;uniform float opacity;uniform sampler2D data;uniform sampler2D matcaps;void main(){vec3 texelData=texture2D(data,vUv).rgb;vec4 diffuseColor=vec4(diffuse,opacity);ReflectedLight reflectedLight=ReflectedLight(vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));vec3 totalEmissiveRadiance=emissive;\n#include <map_fragment>\nfloat specularStrength=texelData.b;\n#include <normal_fragment_begin>\n#include <lights_phong_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\nvec3 outgoingLight=reflectedLight.directDiffuse+reflectedLight.indirectDiffuse+reflectedLight.directSpecular+reflectedLight.indirectSpecular+totalEmissiveRadiance;\n#include <output_fragment>\nvec2 uv=vUv;float id=floor(texelData.g*8.);float id_x=mod(id,4.)/4.+0.0001;float id_y=(floor(id/4.)/2.)+0.0001;vec2 start=vec2(id_x,id_y);vec2 size=vec2(0.25,0.5);float hasMatcap=min(id,1.);vec3 viewDir=normalize(vViewPosition);vec3 x=normalize(vec3(viewDir.z,0.0,-viewDir.x));vec3 y=cross(viewDir,x);vec2 matcapUV=vec2(dot(x,normal),dot(y,normal))*0.499+0.5;matcapUV.y=1.-matcapUV.y;matcapUV.xy=matcapUV.xy*size+start;vec3 matcapColor=texture2D(matcaps,matcapUV).rgb;vec3 lMatcapColor=matcapColor*smoothstep(0.,0.06,(luma(reflectedLight.directDiffuse)));matcapColor=mix(lMatcapColor,matcapColor,0.4+0.6*smoothstep(0.,0.4,luma(matcapColor)))+reflectedLight.directSpecular;gl_FragColor.rgb=mix(gl_FragColor.rgb,matcapColor,hasMatcap);float neonIntensity=texelData.r;\n#include <neon_encode>\n#include <bg_fog>\n}");
let fL = null;
class mL extends jw {
	constructor(e = {}) {
		super(e);
		const t = this.uniforms = l(o(o({}, qw.merge([cS.common, cS.specularmap, cS.fog, cS.lights])), yA.uniforms), {
			data: {
				value: Ol.textures.structureData
			},
			matcaps: {
				value: Ol.textures.matcaps
			},
			specular: {
				value: new aw(16720418)
			},
			shininess: {
				value: 10
			}
		});
		this.map = t.map.value = Ol.textures.structureDiffuse, pL.use(this), this.lights = !0, this.fog = !0, this.type = "ShaderMaterial", this.isShaderMaterial = !0
	}
}
mL.get = e => fL = fL || new mL(e);
class gL extends ZA {
	init() {
		this.base = Ol.meshes.structure, this.base.material = mL.get(), this.base.castShadow = !1, this.base.receiveShadow = !1, this.base.renderOrder = Ol.store.renderOrder.structure, this.base.frustumCulled = !1;
		let e = !1;
		Ol.hooks.beforePrerender.watchOnce((() => {
			e = this.base.visible, this.base.visible = !0
		})), Ol.hooks.afterPrerender.watchOnce((() => {
			this.base.visible = e
		}))
	}
}
var vL = fA("precision highp float;attribute vec3 instancePos;attribute float aOffset;uniform float uTime;uniform float uHalfBoxSize;uniform vec3 uBoxPosition;uniform float uGameVelocity;varying float vFade;varying vec2 vUv;const float DURATION=100.;void main(){vec3 pos=position;float boxSize=uHalfBoxSize*2.;vec3 translation=uBoxPosition-mod(instancePos+uBoxPosition,boxSize)+uHalfBoxSize;float loop=mod((uTime*.0005)+aOffset*DURATION,DURATION)/DURATION;translation.z+=cos(uTime*(0.0004+instancePos.z*0.0005)+instancePos.y*2.2)*(0.02+instancePos.x*0.02);translation.y+=sin(4.+uTime*(0.0003+instancePos.x*0.00005)+instancePos.z*2.2)*(0.02+instancePos.y*0.02);translation.y+=-2.5+(1.-loop)*(10.+translation.y)*(1.+abs((uTime*.0001+aOffset))*.01);vec4 mvPosition=modelViewMatrix*vec4(translation,1.0);mvPosition.xyz+=pos.xyz;float fade=1.;fade*=.3-smoothstep(.05,.75,(.05*distance(uBoxPosition,translation)));fade*=smoothstep(1.,.75,loop)*smoothstep(.0,.25,loop);fade*=1.-smoothstep(6.,14.,uGameVelocity);vFade=fade;vUv=uv;gl_Position=projectionMatrix*mvPosition;}", "precision highp float;uniform float uActiveInfluence;uniform float uGameVelocity;uniform vec3 uBoxPosition;uniform vec3 uColor;uniform vec2 uResolution;uniform float uPixelRatio;varying float vFade;varying vec2 vUv;void main(){vec2 uv=vUv;vec2 res=gl_FragCoord.xy/uResolution.xy;res/=uPixelRatio;float strength=(.5+(uGameVelocity*.01))/(distance(uv,vec2(.5)));vec3 color=uColor;color*=strength;color*=smoothstep(1.,10.,color);float center=.1/distance(res,vec2(.5,.45));color*=vFade*0.4;color*=uActiveInfluence;float alpha=mix(1.,.85,vFade);gl_FragColor=vec4(color,alpha);}");
let _L;
class yL extends jw {
	constructor(e = {}) {
		super(e), GP(this), this.uniforms = {
			uBoxPosition: {
				value: new zx
			},
			uHalfBoxSize: {
				value: 5
			},
			uGameVelocity: {
				value: 0
			},
			uTime: {
				value: 0
			},
			uColor: {
				value: new aw(16777215)
			},
			uActiveInfluence: {
				value: Ol.scene.gameCam.activeInfluence
			},
			uResolution: {
				value: new Cx(window.innerWidth, window.innerHeight)
			},
			uPixelRatio: {
				value: window.devicePixelRatio
			}
		}, this.depthTest = !0, this.depthWrite = !1, vL.use(this)
	}
}
yL.get = e => _L = _L || new yL(e);
const xL = new oS;
let bL, wL, SL, ML, TL, CL, EL;
class AL extends ZA {
	init() {
		bL = Nl(), wL = bL.game, this.material = yL.get(), this.initGeometry(2500), this.base = new Bw(this.geo, this.material), this.base.renderOrder = bL.store.renderOrder.cloudParticles, this.base.frustumCulled = !1, this.position = new zx;
		let e = !1;
		bL.hooks.beforePrerender.watchOnce((() => {
			e = this.base.visible, this.base.visible = !0
		})), bL.hooks.afterPrerender.watchOnce((() => {
			this.base.visible = e
		}))
	}
	initGeometry(e) {
		if (e === this.count) return;
		this.count = e, this.geo && this.geo.dispose(), this.geo = new UE, this.geo.index = xL.index, this.geo.attributes.position = xL.attributes.position, this.geo.attributes.uv = xL.attributes.uv, this.geo.scale(.03, .03, .03), this.stride = 4, this.buffer = new Float32Array(this.count * this.stride);
		const t = this.interleavedBuffer = new ZE(this.buffer, this.stride);
		this.geo.setAttribute("instancePos", new ZT(t, 3, 0, !1)), this.geo.setAttribute("aOffset", new ZT(t, 1, 3, !1));
		const n = this.buffer;
		for (let i = 0; i < this.count; i++) n[i + 0] = TA.randomFloat(-4.8, 4.8), n[i + 1] = TA.randomFloat(-4.8, 4.8), n[i + 2] = TA.randomFloat(-4.8, 4.8), n[i + 3] = TA.randomFloat(-4.8, 4.8);
		this.interleavedBuffer.needsUpdate = !0, this.material.uniforms.uHalfBoxSize.value = 4.8, this.base && (this.base.geometry = this.geo, this.base.needsUpdate = !0)
	}
	update() {
		this.material.uniforms.uGameVelocity.value = wL.velocity, this.material.uniforms.uTime.value = bL.game.elapsed, this.material.uniforms.uActiveInfluence.value = bL.scene.gameCam.activeInfluence;
		const e = this.material.uniforms.uBoxPosition.value;
		let t = bL.scene.currentCamera;
		this.base.visible = !!t.cloudParticlesActive, this.base.visible && e.copy(t.base.position)
	}
}
class PL extends xA {
	constructor(e) {
		super(e), SL = wN(), ML = SL.game, this.emitterOptions = {
			amount: 1,
			depthTest: !0
		}
	}
	update() {
		const e = SL.scene.currentCamera;
		!e || !e.isGameCamera || e.activeInfluence < .002 || ML.velocity < ML.minVelocity || ML.particles.emit("dashline", this.emitterOptions)
	}
}
const LL = new Cx,
	IL = new zx,
	DL = new zx;
new Fx;
class RL extends SA {
	init() {
		EL = Ll, TL = Nl(), CL = TL.game, TL.scene = this, TL.particles.init(this), this.road = this.addComponent(cL), TL.gameCam = CL.gameCam = this.gameCam = this.addComponent(VA), this.idleCam = this.addComponent($A), this.useCamera(this.gameCam), this.lightning = this.addComponent(dL, {
			scene: this
		}), this.structures = this.addComponent(gL), this.cloudParticles = this.addComponent(AL), this.dashLines = this.addComponent(PL);
		let e = null;
		TL.hooks.beforePrerender.watchOnce((() => {
			e = this.currentCamera, this.useCamera(this.gameCam)
		})), TL.hooks.afterPrerender.watchOnce((() => {
			this.useCamera(e)
		})), this.initFog()
	}
	initFog() {
		this.clearColor = tf(ef("#8b0300"), "scene_clear_color"), this.fog = this.base.fog = new jT, this.clearColor.watchImmediate((e => TL.threeRenderer.setClearColor(e))), this.clearColor.watchImmediate((e => this.fog.color.set(e)))
	}
	setFar(e) {
		this.gameCam.cam.far = e, this.gameCam.cam.updateProjectionMatrix(), this.idleCam.cam.far = e, this.idleCam.cam.updateProjectionMatrix(), this.fog.near = Math.max(0, e - 160), this.fog.far = e
	}
	setNear(e) {
		this.gameCam.cam.near = e, this.gameCam.cam.updateProjectionMatrix(), this.idleCam.cam.near = e, this.idleCam.cam.updateProjectionMatrix()
	}
	emitFirework() {
		const e = CL.normalizeProgress(CL.checkpoints.list.finish + 30),
			t = CL.getAbsoluteRoadData(e),
			n = TL.viewport.size.value,
			i = ky(Ny(n.x / n.y, .5, 1.5), 0, 1),
			r = zy(TA.randomFloat(-50, 40), TA.randomFloat(-120, 40), i),
			s = IL.set(r, TA.randomFloat(-19, 45), TA.randomFloat(0, 2)).applyQuaternion(t.quaternion.fromArray([-.10036272, .24738172, .02577216, .96336151])).add(DL.fromArray([356.666661, 12.856385, 67.333084]));
		TL.particles.emit("fireworksFlash", {
			amount: 1,
			position: s,
			scale: LL.set(100, 100),
			duration: 900,
			power: .9,
			powerMult: .92,
			glowMult: 1,
			depthTest: !0,
			rotation: TA.randomFloat(0, 2 * Math.PI),
			gravityY: .2,
			sprite: "smoke"
		}), TL.particles.emit("fireworksFlash", {
			amount: 1,
			position: s,
			scale: LL.set(500, 500),
			duration: 250,
			power: .001,
			depthTest: !0,
			powerMult: .02,
			glowMult: .07,
			sprite: "particleA"
		}), TL.particles.emit("fireworksFlash", {
			amount: 1,
			position: s,
			scale: LL.set(220, 220),
			duration: 200,
			power: .55,
			depthTest: !0,
			powerMult: .9,
			glowMult: .01,
			sprite: "particleA"
		}), TL.particles.emit("fireworksBurst", {
			amount: TA.randomInt(8, 15),
			position: s,
			scale: LL.set(35, 9),
			duration: 800,
			opacity: .3,
			depthTest: !0,
			sprite: "raysA"
		}), TL.particles.emit("fireworksBurstFall", {
			amount: TA.randomInt(4, 6),
			position: s,
			scale: LL.set(6, 4),
			duration: 1100,
			opacity: .9,
			depthTest: !0,
			velocity: .6,
			sprite: "particleA"
		})
	}
	update() {
		let e = "game" !== EL.$route.name && "webgl" !== EL.$route.name,
			t = !e && !this.idleCam.enabled.value;
		(e || this.idleCam.enabled.value) && this.currentCamera !== this.idleCam ? this.useCamera(this.idleCam) : t && this.currentCamera !== this.gameCam && this.useCamera(this.gameCam), super.update(), TL.particles.update()
	}
}
const kL = {
	"./bg.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "vec2 bgUV=bgRot(gl_FragCoord.xy/res.xy,bgCamRotation.y);float bgProgress=smoothstep(1.,0.,bgUV.y+bgCamRotation.x*1.+0.11);vec3 bgColor=mix(bgTopColor,bgBottomColor,bgProgress);"
	}),
	"./bg_fog.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float _fogNear=fogNear;\n#ifdef NEON\n_fogNear+=(fogFar-fogNear)*0.6*neonIntensity;\n#endif\nfloat fogFactor=smoothstep(_fogNear,fogFar,vFogDepth);\n#ifdef STRUCTURE\nfogFactor=max(fogFactor,smoothstep(-90.,-143.,vY)+smoothstep(75.,112.,vY));\n#endif\n#include <bg>\n#ifdef NEON\ngl_FragColor.a=mix(gl_FragColor.a,1.,fogFactor);\n#endif\ngl_FragColor.rgb=mix(gl_FragColor.rgb,bgColor,fogFactor);"
	}),
	"./bg_fog_pars.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "uniform float fogNear;uniform float fogFar;varying float vFogDepth;\n#ifdef STRUCTURE\nvarying float vY;\n#endif\n#include <bg_pars>"
	}),
	"./bg_pars.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "uniform vec2 res;uniform vec2 bgCamRotation;const vec3 bgTopColor=vec3(0.208,0.008,0.012)*0.95;const vec3 bgBottomColor=vec3(0.6,0.,0.);vec2 bgRot(vec2 v,float a){float s=sin(a);float c=cos(a);mat2 m=mat2(c,-s,s,c);return(m*v-0.5)+0.5;}"
	}),
	"./blend_add.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float blendScreen(float base,float blend){return 1.0-((1.0-base)*(1.0-blend));}vec3 blendAdd(vec3 base,vec3 blend){return vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));}"
	}),
	"./conditionals.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float when_gt(float x,float y){return max(sign(x-y),0.0);}float when_lt(float x,float y){return max(sign(y-x),0.0);}float when_ge(float x,float y){return 1.0-when_lt(x,y);}float when_eq(float x,float y){return 1.0-abs(sign(x-y));}"
	}),
	"./equals.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float equals(float x,float y){return 1.0-abs(sign(x-y));}"
	}),
	"./get_instance_matrix.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "mat4 getInstanceMatrix(vec3 p,vec4 q,vec3 s){mat4 m;float x=q.x;float y=q.y;float z=q.z;float w=q.w;float x2=x+x;float y2=y+y;float z2=z+z;float xx=x*x2;float xy=x*y2;float xz=x*z2;float yy=y*y2;float yz=y*z2;float zz=z*z2;float wx=w*x2;float wy=w*y2;float wz=w*z2;float sx=s.x;float sy=s.y;float sz=s.z;m[0][0]=(1.-(yy+zz))*sx;m[0][1]=(xy+wz)*sx;m[0][2]=(xz-wy)*sx;m[0][3]=0.;m[1][0]=(xy-wz)*sy;m[1][1]=(1.-(xx+zz))*sy;m[1][2]=(yz+wx)*sy;m[1][3]=0.;m[2][0]=(xz+wy)*sz;m[2][1]=(yz-wx)*sz;m[2][2]=(1.-(xx+yy))*sz;m[2][3]=0.;m[3][0]=p.x;m[3][1]=p.y;m[3][2]=p.z;m[3][3]=1.;return m;}"
	}),
	"./linearstep.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float linearstep(float start,float end,float value){return(clamp(value,start,end)-start)/(end-start);}"
	}),
	"./luma.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float luma(vec3 color){return dot(color,vec3(0.299,0.587,0.114));}"
	}),
	"./neon_encode.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "gl_FragColor.a=1.-neonIntensity;"
	}),
	"./neon_pars.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "const float neonx=1.0/255.0;vec4 decodeNeon(float v){vec4 enc=vec2(1.0,255.0)*v;enc=fract(enc);enc-=enc.yzww*vec2(neonx,neonx,neonx,0.0);return enc;}float encodeNeon(vec2 rg){return dot(rg,vec2(1.0,neonx));}"
	}),
	"./remap.glsl": Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "float remap(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}"
	})
};
const NL = {
	default: !0,
	webp: !1,
	avif: !1
};
async function OL(e) {
	const t = "image/" + e,
		n = document.createElement("picture"),
		i = document.createElement("img"),
		r = document.createElement("source");
	r.srcset = "data:,x", r.type = t, n.appendChild(r), n.appendChild(i), await 0;
	const s = !!i.currentSrc;
	return NL[e] = s, s
}
var FL = {
	test: async function() {
		await Promise.all([OL("webp"), OL("avif")])
	},
	select: function(e, t, n) {
		return "object" == typeof e && (n = e.avif, t = e.webp, e = e.default), NL.avif && n ? n : NL.webp && t ? t : e
	},
	supports: NL
};
const zL = function() {
	let e = {};
	return {
		get: function(t, n = !0) {
			if (e[t]) return e[t];
			if (!n) return;
			for (const i in e)
				if (i.match(t)) return e[i]
		},
		add: function(t, n) {
			e[t] = n
		},
		clear: function() {
			e = {}
		},
		list: function() {
			return e
		}
	}
}();
const UL = {},
	BL = {};
var VL = {
	get: function(e, t) {
		return zL.get(e, t)
	},
	list: function() {
		return zL.list()
	},
	load: function(e, t = {}) {
		if (zL.get(e)) return Promise.resolve();
		if (BL[e]) return BL[e];
		let n;
		return e.startsWith("http") || e.startsWith("/") || (e = "/" + e), n = t.loader && UL[t.loader] ? UL[t.loader].function(e, t) : function(e, t) {
			for (const n in UL) {
				const i = UL[n];
				if (i.extensions) {
					const n = i.extensions;
					for (let r = 0; r < n.length; r++) {
						const s = n[r];
						if (e.endsWith(s)) return i.function(e, t)
					}
				} else if (i.test && i.test(e, t)) return i.function(e, t)
			}
			return function(e, t = {}) {
				return new Promise(((n, i) => {
					const r = new XMLHttpRequest;
					r.responseType = t.responseType || "arraybuffer", r.onreadystatechange = () => {
						4 === r.readyState && (4 === r.readyState && 200 === r.status ? (t.noCache || zL.add(e, r.response), t.onLoad && t.onLoad(r.response), n(r.response, r.status)) : i(r.status))
					}, r.open("GET", e, !0), r.send()
				}))
			}(e, t)
		}(e, t), n && (BL[e] = n), n
	},
	registerLoader: function(e) {
		e.loader && (e = e.loader), UL[e.name] = e
	}
};

function HL(e, t) {
	return new Promise((n => {
		const i = new Image;
		i.onload = () => {
			const r = {
				node: i,
				url: e
			};
			t.onLoad && t.onLoad(r), zL.add(e, r), n(r)
		}, i.decoding = "async", i.setAttribute("decoding", "async"), i.src = e
	}))
}
HL.loader = {
	name: "image",
	extensions: [".jpg", ".png", ".webp", ".avif", ".gif", ".jpeg"],
	function: HL
};

function GL() {
	let e = {};
	return {
		get: function(t) {
			return e[t]
		},
		add: function(t, n) {
			e[t] = n
		},
		remove: function(t) {
			delete e[t]
		},
		removeAll: function() {
			e = {}
		}
	}
}
const WL = {
	KHR_BINARY_GLTF: "KHR_binary_glTF",
	KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
	KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
	KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
	KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
	KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
	KHR_TEXTURE_BASISU: "KHR_texture_basisu",
	KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
	KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
	EXT_TEXTURE_WEBP: "EXT_texture_webp",
	EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class qL {
	constructor(e) {
		this.parser = e, this.name = WL.KHR_LIGHTS_PUNCTUAL, this.cache = {
			refs: {},
			uses: {}
		}
	}
	_markDefs() {
		const e = this.parser,
			t = this.parser.json.nodes || [];
		for (let n = 0, i = t.length; n < i; n++) {
			const i = t[n];
			i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
		}
	}
	_loadLight(e) {
		const t = this.parser,
			n = "light:" + e;
		let i = t.cache.get(n);
		if (i) return i;
		const r = t.json,
			s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
		let a;
		const o = new aw(16777215);
		void 0 !== s.color && o.fromArray(s.color);
		const l = void 0 !== s.range ? s.range : 0;
		switch (s.type) {
			case "directional":
				a = new OE(o), a.target.position.set(0, 0, -1), a.add(a.target);
				break;
			case "point":
				a = new kE(o), a.distance = l;
				break;
			case "spot":
				a = new PE(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
				break;
			default:
				throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
		}
		return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(a), t.cache.add(n, i), i
	}
	createNodeAttachment(e) {
		const t = this,
			n = this.parser,
			i = n.json.nodes[e],
			r = (i.extensions && i.extensions[this.name] || {}).light;
		return void 0 === r ? null : this._loadLight(r).then((function(e) {
			return n._getNodeRef(t.cache, r, e)
		}))
	}
}
class jL {
	constructor() {
		this.name = WL.KHR_MATERIALS_UNLIT
	}
	getMaterialType() {
		return ow
	}
	extendParams(e, t, n) {
		const i = [];
		e.color = new aw(1, 1, 1), e.opacity = 1;
		const r = t.pbrMetallicRoughness;
		if (r) {
			if (Array.isArray(r.baseColorFactor)) {
				const t = r.baseColorFactor;
				e.color.fromArray(t), e.opacity = t[3]
			}
			void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture))
		}
		return Promise.all(i)
	}
}
class YL {
	constructor(e) {
		this.parser = e, this.name = WL.KHR_MATERIALS_CLEARCOAT
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return t.extensions && t.extensions[this.name] ? QC : null
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			i = n.json.materials[e];
		if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
		const r = [],
			s = i.extensions[this.name];
		if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
			const e = s.clearcoatNormalTexture.scale;
			t.clearcoatNormalScale = new Cx(e, -e)
		}
		return Promise.all(r)
	}
}
class XL {
	constructor(e) {
		this.parser = e, this.name = WL.KHR_MATERIALS_TRANSMISSION
	}
	getMaterialType(e) {
		const t = this.parser.json.materials[e];
		return t.extensions && t.extensions[this.name] ? QC : null
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			i = n.json.materials[e];
		if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
		const r = [],
			s = i.extensions[this.name];
		return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r)
	}
}
class $L {
	constructor(e) {
		this.parser = e, this.name = WL.KHR_TEXTURE_BASISU
	}
	loadTexture(e) {
		const t = this.parser,
			n = t.json,
			i = n.textures[e];
		if (!i.extensions || !i.extensions[this.name]) return null;
		const r = i.extensions[this.name],
			s = n.images[r.source],
			a = t.options.ktx2Loader;
		if (!a) {
			if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
			return null
		}
		return t.loadTextureImage(e, s, a)
	}
}
class ZL {
	constructor(e) {
		this.parser = e, this.name = WL.EXT_TEXTURE_WEBP, this.isSupported = null
	}
	loadTexture(e) {
		const t = this.name,
			n = this.parser,
			i = n.json,
			r = i.textures[e];
		if (!r.extensions || !r.extensions[t]) return null;
		const s = r.extensions[t],
			a = i.images[s.source];
		let o = n.textureLoader;
		if (a.uri) {
			const e = n.options.manager.getHandler(a.uri);
			null !== e && (o = e)
		}
		return this.detectSupport().then((function(r) {
			if (r) return n.loadTextureImage(e, a, o);
			if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
			return n.loadTexture(e)
		}))
	}
	detectSupport() {
		return this.isSupported || (this.isSupported = new Promise((function(e) {
			const t = new Image;
			t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
				e(1 === t.height)
			}
		}))), this.isSupported
	}
}
class KL {
	constructor(e) {
		this.name = WL.EXT_MESHOPT_COMPRESSION, this.parser = e
	}
	loadBufferView(e) {
		const t = this.parser.json,
			n = t.bufferViews[e];
		if (n.extensions && n.extensions[this.name]) {
			const e = n.extensions[this.name],
				i = this.parser.getDependency("buffer", e.buffer),
				r = this.parser.options.meshoptDecoder;
			if (!r || !r.supported) {
				if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
				return null
			}
			return Promise.all([i, r.ready]).then((function(t) {
				const n = e.byteOffset || 0,
					i = e.byteLength || 0,
					s = e.count,
					a = e.byteStride,
					o = new ArrayBuffer(s * a),
					l = new Uint8Array(t[0], n, i);
				return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o
			}))
		}
		return null
	}
}
const JL = "glTF",
	QL = 1313821514,
	eI = 5130562;
class tI {
	constructor(e) {
		this.name = WL.KHR_BINARY_GLTF, this.content = null, this.body = null;
		const t = new DataView(e, 0, 12);
		if (this.header = {
				magic: zE.decodeText(new Uint8Array(e.slice(0, 4))),
				version: t.getUint32(4, !0),
				length: t.getUint32(8, !0)
			}, this.header.magic !== JL) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
		if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
		const n = this.header.length - 12,
			i = new DataView(e, 12);
		let r = 0;
		for (; r < n;) {
			const t = i.getUint32(r, !0);
			r += 4;
			const n = i.getUint32(r, !0);
			if (r += 4, n === QL) {
				const n = new Uint8Array(e, 12 + r, t);
				this.content = zE.decodeText(n)
			} else if (n === eI) {
				const n = 12 + r;
				this.body = e.slice(n, n + t)
			}
			r += t
		}
		if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
	}
}
class nI {
	constructor(e, t) {
		if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
		this.name = WL.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
	}
	decodePrimitive(e, t) {
		const n = this.json,
			i = this.dracoLoader,
			r = e.extensions[this.name].bufferView,
			s = e.extensions[this.name].attributes,
			a = {},
			o = {},
			l = {};
		for (const c in s) {
			const e = yI[c] || c.toLowerCase();
			a[e] = s[c]
		}
		for (const c in e.attributes) {
			const t = yI[c] || c.toLowerCase();
			if (void 0 !== s[c]) {
				const i = n.accessors[e.attributes[c]],
					r = mI[i.componentType];
				l[t] = r, o[t] = !0 === i.normalized
			}
		}
		return t.getDependency("bufferView", r).then((function(e) {
			return new Promise((function(t) {
				i.decodeDracoFile(e, (function(e) {
					for (const t in e.attributes) {
						const n = e.attributes[t],
							i = o[t];
						void 0 !== i && (n.normalized = i)
					}
					t(e)
				}), a, l)
			}))
		}))
	}
}
class iI {
	constructor() {
		this.name = WL.KHR_TEXTURE_TRANSFORM
	}
	extendTexture(e, t) {
		return t.texCoord, void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
	}
}
class rI extends JC {
	constructor(e) {
		super(), this.isGLTFSpecularGlossinessMaterial = !0;
		const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
			n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
			i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
			r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
			s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
			a = {
				specular: {
					value: (new aw).setHex(16777215)
				},
				glossiness: {
					value: 1
				},
				specularMap: {
					value: null
				},
				glossinessMap: {
					value: null
				}
			};
		this._extraUniforms = a, this.onBeforeCompile = function(e) {
			for (const t in a) e.uniforms[t] = a[t];
			e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
		}, Object.defineProperties(this, {
			specular: {
				get: function() {
					return a.specular.value
				},
				set: function(e) {
					a.specular.value = e
				}
			},
			specularMap: {
				get: function() {
					return a.specularMap.value
				},
				set: function(e) {
					a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
				}
			},
			glossiness: {
				get: function() {
					return a.glossiness.value
				},
				set: function(e) {
					a.glossiness.value = e
				}
			},
			glossinessMap: {
				get: function() {
					return a.glossinessMap.value
				},
				set: function(e) {
					a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
				}
			}
		}), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
	}
	copy(e) {
		return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
	}
}
class sI {
	constructor() {
		this.name = WL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
	}
	getMaterialType() {
		return rI
	}
	extendParams(e, t, n) {
		const i = t.extensions[this.name];
		e.color = new aw(1, 1, 1), e.opacity = 1;
		const r = [];
		if (Array.isArray(i.diffuseFactor)) {
			const t = i.diffuseFactor;
			e.color.fromArray(t), e.opacity = t[3]
		}
		if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new aw(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new aw(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
			const t = i.specularGlossinessTexture;
			r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t))
		}
		return Promise.all(r)
	}
	createMaterial(e) {
		const t = new rI(e);
		return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t
	}
}
class aI {
	constructor() {
		this.name = WL.KHR_MESH_QUANTIZATION
	}
}
class oI extends nE {
	constructor(e, t, n, i) {
		super(e, t, n, i)
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			n = this.sampleValues,
			i = this.valueSize,
			r = e * i * 3 + i;
		for (let s = 0; s !== i; s++) t[s] = n[r + s];
		return t
	}
}
oI.prototype.beforeStart_ = oI.prototype.copySampleValue_, oI.prototype.afterEnd_ = oI.prototype.copySampleValue_, oI.prototype.interpolate_ = function(e, t, n, i) {
	const r = this.resultBuffer,
		s = this.sampleValues,
		a = this.valueSize,
		o = 2 * a,
		l = 3 * a,
		c = i - t,
		u = (n - t) / c,
		h = u * u,
		d = h * u,
		p = e * l,
		f = p - l,
		m = -2 * d + 3 * h,
		g = d - h,
		v = 1 - m,
		_ = g - h + u;
	for (let y = 0; y !== a; y++) {
		const e = s[f + y + a],
			t = s[f + y + o] * c,
			n = s[p + y + a],
			i = s[p + y] * c;
		r[y] = v * e + _ * t + m * n + g * i
	}
	return r
};
const lI = 0,
	cI = 1,
	uI = 2,
	hI = 3,
	dI = 4,
	pI = 5,
	fI = 6,
	mI = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	},
	gI = {
		9728: 1003,
		9729: 1006,
		9984: 1004,
		9985: 1007,
		9986: 1005,
		9987: 1008
	},
	vI = {
		33071: 1001,
		33648: 1002,
		10497: 1e3
	},
	_I = {
		SCALAR: 1,
		VEC2: 2,
		VEC3: 3,
		VEC4: 4,
		MAT2: 4,
		MAT3: 9,
		MAT4: 16
	},
	yI = {
		POSITION: "position",
		NORMAL: "normal",
		TANGENT: "tangent",
		TEXCOORD_0: "uv",
		TEXCOORD_1: "uv2",
		COLOR_0: "color",
		WEIGHTS_0: "skinWeight",
		JOINTS_0: "skinIndex"
	},
	xI = {
		scale: "scale",
		translation: "position",
		rotation: "quaternion",
		weights: "morphTargetInfluences"
	},
	bI = {
		CUBICSPLINE: void 0,
		LINEAR: 2301,
		STEP: 2300
	},
	wI = "OPAQUE",
	SI = "MASK",
	MI = "BLEND";

function TI(e, t) {
	return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
}

function CI(e, t, n) {
	for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
}

function EI(e, t) {
	void 0 !== t.extras && "object" == typeof t.extras && Object.assign(e.userData, t.extras)
}

function AI(e, t) {
	if (e.updateMorphTargets(), void 0 !== t.weights)
		for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
	if (t.extras && Array.isArray(t.extras.targetNames)) {
		const n = t.extras.targetNames;
		if (e.morphTargetInfluences.length === n.length) {
			e.morphTargetDictionary = {};
			for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
		}
	}
}

function PI(e) {
	const t = e.extensions && e.extensions[WL.KHR_DRACO_MESH_COMPRESSION];
	let n;
	return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + LI(t.attributes) : e.indices + ":" + LI(e.attributes) + ":" + e.mode, n
}

function LI(e) {
	let t = "";
	const n = Object.keys(e).sort();
	for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
	return t
}

function II(e) {
	switch (e) {
		case Int8Array:
			return 1 / 127;
		case Uint8Array:
			return 1 / 255;
		case Int16Array:
			return 1 / 32767;
		case Uint16Array:
			return 1 / 65535;
		default:
			throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
	}
}
class DI {
	constructor(e = {}, t = {}) {
		this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new GL, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
			refs: {},
			uses: {}
		}, this.cameraCache = {
			refs: {},
			uses: {}
		}, this.lightCache = {
			refs: {},
			uses: {}
		}, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new BE(this.options.manager) : this.textureLoader = new wE(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new xE(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
	}
	setExtensions(e) {
		this.extensions = e
	}
	setPlugins(e) {
		this.plugins = e
	}
	parse(e, t) {
		const n = this,
			i = this.json,
			r = this.extensions;
		this.cache.removeAll(), this._invokeAll((function(e) {
			return e._markDefs && e._markDefs()
		})), Promise.all(this._invokeAll((function(e) {
			return e.beforeRoot && e.beforeRoot()
		}))).then((function() {
			return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
		})).then((function(t) {
			const s = {
				scene: t[0][i.scene || 0],
				scenes: t[0],
				animations: t[1],
				cameras: t[2],
				asset: i.asset,
				parser: n,
				userData: {}
			};
			CI(r, s, i), EI(s, i), Promise.all(n._invokeAll((function(e) {
				return e.afterRoot && e.afterRoot(s)
			}))).then((function() {
				e(s)
			}))
		})).catch(t)
	}
	_markDefs() {
		const e = this.json.nodes || [],
			t = this.json.skins || [],
			n = this.json.meshes || [];
		for (let i = 0, r = t.length; i < r; i++) {
			const n = t[i].joints;
			for (let t = 0, i = n.length; t < i; t++) e[n[t]].isBone = !0
		}
		for (let i = 0, r = e.length; i < r; i++) {
			const t = e[i];
			void 0 !== t.mesh && (this._addNodeRef(this.meshCache, t.mesh), void 0 !== t.skin && (n[t.mesh].isSkinnedMesh = !0)), void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera)
		}
	}
	_addNodeRef(e, t) {
		void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
	}
	_getNodeRef(e, t, n) {
		if (e.refs[t] <= 1) return n;
		const i = n.clone();
		return i.name += "_instance_" + e.uses[t]++, i
	}
	_invokeOne(e) {
		const t = Object.values(this.plugins);
		t.push(this);
		for (let n = 0; n < t.length; n++) {
			const i = e(t[n]);
			if (i) return i
		}
		return null
	}
	_invokeAll(e) {
		const t = Object.values(this.plugins);
		t.unshift(this);
		const n = [];
		for (let i = 0; i < t.length; i++) {
			const r = e(t[i]);
			r && n.push(r)
		}
		return n
	}
	getDependency(e, t) {
		const n = e + ":" + t;
		let i = this.cache.get(n);
		if (!i) {
			switch (e) {
				case "scene":
					i = this.loadScene(t);
					break;
				case "node":
					i = this.loadNode(t);
					break;
				case "mesh":
					i = this._invokeOne((function(e) {
						return e.loadMesh && e.loadMesh(t)
					}));
					break;
				case "accessor":
					i = this.loadAccessor(t);
					break;
				case "bufferView":
					i = this._invokeOne((function(e) {
						return e.loadBufferView && e.loadBufferView(t)
					}));
					break;
				case "buffer":
					i = this.loadBuffer(t);
					break;
				case "material":
					i = this._invokeOne((function(e) {
						return e.loadMaterial && e.loadMaterial(t)
					}));
					break;
				case "texture":
					i = this._invokeOne((function(e) {
						return e.loadTexture && e.loadTexture(t)
					}));
					break;
				case "skin":
					i = this.loadSkin(t);
					break;
				case "animation":
					i = this.loadAnimation(t);
					break;
				case "camera":
					i = this.loadCamera(t);
					break;
				default:
					throw new Error("Unknown type: " + e)
			}
			this.cache.add(n, i)
		}
		return i
	}
	getDependencies(e) {
		let t = this.cache.get(e);
		if (!t) {
			const n = this,
				i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
			t = Promise.all(i.map((function(t, i) {
				return n.getDependency(e, i)
			}))), this.cache.add(e, t)
		}
		return t
	}
	loadBuffer(e) {
		const t = this.json.buffers[e],
			n = this.fileLoader;
		if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
		if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[WL.KHR_BINARY_GLTF].body);
		const i = this.options;
		return new Promise((function(e, r) {
			n.load(TI(t.uri, i.path), e, void 0, (function() {
				r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
			}))
		}))
	}
	loadBufferView(e) {
		const t = this.json.bufferViews[e];
		return this.getDependency("buffer", t.buffer).then((function(e) {
			const n = t.byteLength || 0,
				i = t.byteOffset || 0;
			return e.slice(i, i + n)
		}))
	}
	loadAccessor(e) {
		const t = this,
			n = this.json,
			i = this.json.accessors[e];
		if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
		const r = [];
		return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
			const r = e[0],
				s = _I[i.type],
				a = mI[i.componentType],
				o = a.BYTES_PER_ELEMENT,
				l = o * s,
				c = i.byteOffset || 0,
				u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
				h = !0 === i.normalized;
			let d, p;
			if (u && u !== l) {
				const e = Math.floor(c / u),
					n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
				let l = t.cache.get(n);
				l || (d = new a(r, e * u, i.count * u / o), l = new XT(d, u / o), t.cache.add(n, l)), p = new ZT(l, s, c % u / o, h)
			} else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), p = new uw(d, s, h);
			if (void 0 !== i.sparse) {
				const t = _I.SCALAR,
					n = mI[i.sparse.indices.componentType],
					o = i.sparse.indices.byteOffset || 0,
					l = i.sparse.values.byteOffset || 0,
					c = new n(e[1], o, i.sparse.count * t),
					u = new a(e[2], l, i.sparse.count * s);
				null !== r && (p = new uw(p.array.slice(), p.itemSize, p.normalized));
				for (let e = 0, i = c.length; e < i; e++) {
					const t = c[e];
					if (p.setX(t, u[e * s]), s >= 2 && p.setY(t, u[e * s + 1]), s >= 3 && p.setZ(t, u[e * s + 2]), s >= 4 && p.setW(t, u[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
				}
			}
			return p
		}))
	}
	loadTexture(e) {
		const t = this.json,
			n = this.options,
			i = t.textures[e],
			r = t.images[i.source];
		let s = this.textureLoader;
		if (r.uri) {
			const e = n.manager.getHandler(r.uri);
			null !== e && (s = e)
		}
		return this.loadTextureImage(e, r, s)
	}
	loadTextureImage(e, t, n) {
		const i = this,
			r = this.json,
			s = this.options,
			a = r.textures[e],
			o = (t.uri || t.bufferView) + ":" + a.sampler;
		if (this.textureCache[o]) return this.textureCache[o];
		const l = self.URL || self.webkitURL;
		let c = t.uri || "",
			u = !1,
			h = !0;
		const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
		if (("image/jpeg" === t.mimeType || d) && (h = !1), void 0 !== t.bufferView) c = i.getDependency("bufferView", t.bufferView).then((function(e) {
			if ("image/png" === t.mimeType) {
				const t = new DataView(e, 25, 1).getUint8(0, !1);
				h = 6 === t || 4 === t || 3 === t
			}
			u = !0;
			const n = new Blob([e], {
				type: t.mimeType
			});
			return c = l.createObjectURL(n), c
		}));
		else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
		const p = Promise.resolve(c).then((function(e) {
			return new Promise((function(t, i) {
				let r = t;
				!0 === n.isImageBitmapLoader && (r = function(e) {
					const n = new Dx(e);
					n.needsUpdate = !0, t(n)
				}), n.load(TI(e, s.path), r, void 0, i)
			}))
		})).then((function(t) {
			!0 === u && l.revokeObjectURL(c), t.flipY = !1, a.name && (t.name = a.name), h || (t.format = 1022);
			const n = (r.samplers || {})[a.sampler] || {};
			return t.magFilter = gI[n.magFilter] || 1006, t.minFilter = gI[n.minFilter] || 1008, t.wrapS = vI[n.wrapS] || 1e3, t.wrapT = vI[n.wrapT] || 1e3, i.associations.set(t, {
				type: "textures",
				index: e
			}), t
		})).catch((function() {
			return null
		}));
		return this.textureCache[o] = p, p
	}
	assignTexture(e, t, n) {
		const i = this;
		return this.getDependency("texture", n.index).then((function(r) {
			if (void 0 !== n.texCoord && 0 != n.texCoord && ("aoMap" !== t || n.texCoord), i.extensions[WL.KHR_TEXTURE_TRANSFORM]) {
				const e = void 0 !== n.extensions ? n.extensions[WL.KHR_TEXTURE_TRANSFORM] : void 0;
				if (e) {
					const t = i.associations.get(r);
					r = i.extensions[WL.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t)
				}
			}
			e[t] = r
		}))
	}
	assignFinalMaterial(e) {
		const t = e.geometry;
		let n = e.material;
		const i = void 0 !== t.attributes.tangent,
			r = void 0 !== t.attributes.color,
			s = void 0 === t.attributes.normal,
			a = Object.keys(t.morphAttributes).length > 0,
			o = a && void 0 !== t.morphAttributes.normal;
		if (e.isPoints) {
			const e = "PointsMaterial:" + n.uuid;
			let t = this.cache.get(e);
			t || (t = new TC, Qb.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
		} else if (e.isLine) {
			const e = "LineBasicMaterial:" + n.uuid;
			let t = this.cache.get(e);
			t || (t = new fC, Qb.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
		}
		if (i || r || s || a) {
			let e = "ClonedMaterial:" + n.uuid + ":";
			n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "vertex-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:"), a && (e += "morph-targets:"), o && (e += "morph-normals:");
			let t = this.cache.get(e);
			t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), a && (t.morphTargets = !0), o && (t.morphNormals = !0), i && (t.vertexTangents = !0, t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
		}
		n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
	}
	getMaterialType() {
		return JC
	}
	loadMaterial(e) {
		const t = this,
			n = this.json,
			i = this.extensions,
			r = n.materials[e];
		let s;
		const a = {},
			o = r.extensions || {},
			l = [];
		if (o[WL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
			const e = i[WL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
			s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
		} else if (o[WL.KHR_MATERIALS_UNLIT]) {
			const e = i[WL.KHR_MATERIALS_UNLIT];
			s = e.getMaterialType(), l.push(e.extendParams(a, r, t))
		} else {
			const n = r.pbrMetallicRoughness || {};
			if (a.color = new aw(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) {
				const e = n.baseColorFactor;
				a.color.fromArray(e), a.opacity = e[3]
			}
			void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function(t) {
				return t.getMaterialType && t.getMaterialType(e)
			})), l.push(Promise.all(this._invokeAll((function(t) {
				return t.extendMaterialParams && t.extendMaterialParams(e, a)
			}))))
		}!0 === r.doubleSided && (a.side = 2);
		const c = r.alphaMode || wI;
		return c === MI ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, c === SI && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== ow && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new Cx(1, -1), void 0 !== r.normalTexture.scale && a.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), void 0 !== r.occlusionTexture && s !== ow && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== ow && (a.emissive = (new aw).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== ow && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function() {
			let n;
			return n = s === rI ? i[WL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), r.name && (n.name = r.name), n.map && (n.map.encoding = 3001), n.emissiveMap && (n.emissiveMap.encoding = 3001), EI(n, r), t.associations.set(n, {
				type: "materials",
				index: e
			}), r.extensions && CI(i, n, r), n
		}))
	}
	createUniqueName(e) {
		const t = $E.sanitizeNodeName(e || "");
		let n = t;
		for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
		return this.nodeNamesUsed[n] = !0, n
	}
	loadGeometries(e) {
		const t = this,
			n = this.extensions,
			i = this.primitiveCache;

		function r(e) {
			return n[WL.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
				return kI(n, e, t)
			}))
		}
		const s = [];
		for (let a = 0, o = e.length; a < o; a++) {
			const n = e[a],
				o = PI(n),
				l = i[o];
			if (l) s.push(l.promise);
			else {
				let e;
				e = n.extensions && n.extensions[WL.KHR_DRACO_MESH_COMPRESSION] ? r(n) : kI(new ww, n, t), i[o] = {
					primitive: n,
					promise: e
				}, s.push(e)
			}
		}
		return Promise.all(s)
	}
	loadMesh(e) {
		const t = this,
			n = this.json,
			i = this.extensions,
			r = n.meshes[e],
			s = r.primitives,
			a = [];
		for (let l = 0, c = s.length; l < c; l++) {
			const e = void 0 === s[l].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new JC({
				color: 16777215,
				emissive: 0,
				metalness: 1,
				roughness: 1,
				transparent: !1,
				depthTest: !0,
				side: 0
			})), o.DefaultMaterial) : this.getDependency("material", s[l].material);
			a.push(e)
		}
		var o;
		return a.push(t.loadGeometries(s)), Promise.all(a).then((function(n) {
			const a = n.slice(0, n.length - 1),
				o = n[n.length - 1],
				l = [];
			for (let u = 0, h = o.length; u < h; u++) {
				const n = o[u],
					c = s[u];
				let h;
				const d = a[u];
				if (c.mode === dI || c.mode === pI || c.mode === fI || void 0 === c.mode) h = !0 === r.isSkinnedMesh ? new nC(n, d) : new Bw(n, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), c.mode === pI ? h.geometry = NI(h.geometry, 1) : c.mode === fI && (h.geometry = NI(h.geometry, 2));
				else if (c.mode === cI) h = new SC(n, d);
				else if (c.mode === hI) h = new xC(n, d);
				else if (c.mode === uI) h = new MC(n, d);
				else {
					if (c.mode !== lI) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode);
					h = new LC(n, d)
				}
				Object.keys(h.geometry.morphAttributes).length > 0 && AI(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), EI(h, r), c.extensions && CI(i, h, c), t.assignFinalMaterial(h), l.push(h)
			}
			if (1 === l.length) return l[0];
			const c = new BT;
			for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
			return c
		}))
	}
	loadCamera(e) {
		let t;
		const n = this.json.cameras[e],
			i = n[n.type];
		if (i) return "perspective" === n.type ? t = new Xw(i.yfov * _x, i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new vS(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), EI(t, n), Promise.resolve(t)
	}
	loadSkin(e) {
		const t = this.json.skins[e],
			n = {
				joints: t.joints
			};
		return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
			return n.inverseBindMatrices = e, n
		}))
	}
	loadAnimation(e) {
		const t = this.json.animations[e],
			n = [],
			i = [],
			r = [],
			s = [],
			a = [];
		for (let o = 0, l = t.channels.length; o < l; o++) {
			const e = t.channels[o],
				l = t.samplers[e.sampler],
				c = e.target,
				u = void 0 !== c.node ? c.node : c.id,
				h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
				d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
			n.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), r.push(this.getDependency("accessor", d)), s.push(l), a.push(c)
		}
		return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function(n) {
			const i = n[0],
				r = n[1],
				s = n[2],
				a = n[3],
				o = n[4],
				l = [];
			for (let e = 0, t = i.length; e < t; e++) {
				const t = i[e],
					n = r[e],
					c = s[e],
					u = a[e],
					h = o[e];
				if (void 0 === t) continue;
				let d;
				switch (t.updateMatrix(), t.matrixAutoUpdate = !0, xI[h.path]) {
					case xI.weights:
						d = cE;
						break;
					case xI.rotation:
						d = hE;
						break;
					default:
						d = pE
				}
				const p = t.name ? t.name : t.uuid,
					f = void 0 !== u.interpolation ? bI[u.interpolation] : 2301,
					m = [];
				xI[h.path] === xI.weights ? t.traverse((function(e) {
					!0 === e.isMesh && e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
				})) : m.push(p);
				let g = c.array;
				if (c.normalized) {
					const e = II(g.constructor),
						t = new Float32Array(g.length);
					for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
					g = t
				}
				for (let e = 0, i = m.length; e < i; e++) {
					const t = new d(m[e] + "." + xI[h.path], n.array, g, f);
					"CUBICSPLINE" === u.interpolation && (t.createInterpolant = function(e) {
						return new oI(this.times, this.values, this.getValueSize() / 3, e)
					}, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t)
				}
			}
			const c = t.name ? t.name : "animation_" + e;
			return new fE(c, void 0, l)
		}))
	}
	createNodeMesh(e) {
		const t = this.json,
			n = this,
			i = t.nodes[e];
		return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
			const t = n._getNodeRef(n.meshCache, i.mesh, e);
			return void 0 !== i.weights && t.traverse((function(e) {
				if (e.isMesh)
					for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
			})), t
		}))
	}
	loadNode(e) {
		const t = this.json,
			n = this.extensions,
			i = this,
			r = t.nodes[e],
			s = r.name ? i.createUniqueName(r.name) : "";
		return function() {
			const t = [],
				n = i._invokeOne((function(t) {
					return t.createNodeMesh && t.createNodeMesh(e)
				}));
			return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function(e) {
				return i._getNodeRef(i.cameraCache, r.camera, e)
			}))), i._invokeAll((function(t) {
				return t.createNodeAttachment && t.createNodeAttachment(e)
			})).forEach((function(e) {
				t.push(e)
			})), Promise.all(t)
		}().then((function(t) {
			let a;
			if (a = !0 === r.isBone ? new iC : t.length > 1 ? new BT : 1 === t.length ? t[0] : new Bb, a !== t[0])
				for (let e = 0, n = t.length; e < n; e++) a.add(t[e]);
			if (r.name && (a.userData.name = r.name, a.name = s), EI(a, r), r.extensions && CI(n, a, r), void 0 !== r.matrix) {
				const e = new mb;
				e.fromArray(r.matrix), a.applyMatrix4(e)
			} else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale);
			return i.associations.set(a, {
				type: "nodes",
				index: e
			}), a
		}))
	}
	loadScene(e) {
		const t = this.json,
			n = this.extensions,
			i = this.json.scenes[e],
			r = this,
			s = new BT;
		i.name && (s.name = r.createUniqueName(i.name)), EI(s, i), i.extensions && CI(n, s, i);
		const a = i.nodes || [],
			o = [];
		for (let l = 0, c = a.length; l < c; l++) o.push(RI(a[l], s, t, r));
		return Promise.all(o).then((function() {
			return s
		}))
	}
}

function RI(e, t, n, i) {
	const r = n.nodes[e];
	return i.getDependency("node", e).then((function(e) {
		if (void 0 === r.skin) return e;
		let t;
		return i.getDependency("skin", r.skin).then((function(e) {
			t = e;
			const n = [];
			for (let r = 0, s = t.joints.length; r < s; r++) n.push(i.getDependency("node", t.joints[r]));
			return Promise.all(n)
		})).then((function(n) {
			return e.traverse((function(e) {
				if (!e.isMesh) return;
				const i = [],
					r = [];
				for (let s = 0, a = n.length; s < a; s++) {
					const e = n[s];
					if (e) {
						i.push(e);
						const n = new mb;
						void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * s), r.push(n)
					}
				}
				e.bind(new oC(i, r), e.matrixWorld)
			})), e
		}))
	})).then((function(e) {
		t.add(e);
		const s = [];
		if (r.children) {
			const t = r.children;
			for (let r = 0, a = t.length; r < a; r++) {
				const a = t[r];
				s.push(RI(a, e, n, i))
			}
		}
		return Promise.all(s)
	}))
}

function kI(e, t, n) {
	const i = t.attributes,
		r = [];

	function s(t, i) {
		return n.getDependency("accessor", t).then((function(t) {
			e.setAttribute(i, t)
		}))
	}
	for (const a in i) {
		const t = yI[a] || a.toLowerCase();
		t in e.attributes || r.push(s(i[a], t))
	}
	if (void 0 !== t.indices && !e.index) {
		const i = n.getDependency("accessor", t.indices).then((function(t) {
			e.setIndex(t)
		}));
		r.push(i)
	}
	return EI(e, t),
		function(e, t, n) {
			const i = t.attributes,
				r = new Vx;
			if (void 0 === i.POSITION) return; {
				const e = n.json.accessors[i.POSITION],
					t = e.min,
					s = e.max;
				if (void 0 === t || void 0 === s) return;
				if (r.set(new zx(t[0], t[1], t[2]), new zx(s[0], s[1], s[2])), e.normalized) {
					const t = II(mI[e.componentType]);
					r.min.multiplyScalar(t), r.max.multiplyScalar(t)
				}
			}
			const s = t.targets;
			if (void 0 !== s) {
				const e = new zx,
					t = new zx;
				for (let i = 0, r = s.length; i < r; i++) {
					const r = s[i];
					if (void 0 !== r.POSITION) {
						const i = n.json.accessors[r.POSITION],
							s = i.min,
							a = i.max;
						if (void 0 !== s && void 0 !== a) {
							if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), i.normalized) {
								const e = II(mI[i.componentType]);
								t.multiplyScalar(e)
							}
							e.max(t)
						}
					}
				}
				r.expandByVector(e)
			}
			e.boundingBox = r;
			const a = new ab;
			r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a
		}(e, t, n), Promise.all(r).then((function() {
			return void 0 !== t.targets ? function(e, t, n) {
				let i = !1,
					r = !1;
				for (let o = 0, l = t.length; o < l; o++) {
					const e = t[o];
					if (void 0 !== e.POSITION && (i = !0), void 0 !== e.NORMAL && (r = !0), i && r) break
				}
				if (!i && !r) return Promise.resolve(e);
				const s = [],
					a = [];
				for (let o = 0, l = t.length; o < l; o++) {
					const l = t[o];
					if (i) {
						const t = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : e.attributes.position;
						s.push(t)
					}
					if (r) {
						const t = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : e.attributes.normal;
						a.push(t)
					}
				}
				return Promise.all([Promise.all(s), Promise.all(a)]).then((function(t) {
					const n = t[0],
						s = t[1];
					return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), e.morphTargetsRelative = !0, e
				}))
			}(e, t.targets, n) : e
		}))
}

function NI(e, t) {
	let n = e.getIndex();
	if (null === n) {
		const t = [],
			i = e.getAttribute("position");
		if (void 0 === i) return e;
		for (let e = 0; e < i.count; e++) t.push(e);
		e.setIndex(t), n = e.getIndex()
	}
	const i = n.count - 2,
		r = [];
	if (2 === t)
		for (let a = 1; a <= i; a++) r.push(n.getX(0)), r.push(n.getX(a)), r.push(n.getX(a + 1));
	else
		for (let a = 0; a < i; a++) a % 2 == 0 ? (r.push(n.getX(a)), r.push(n.getX(a + 1)), r.push(n.getX(a + 2))) : (r.push(n.getX(a + 2)), r.push(n.getX(a + 1)), r.push(n.getX(a)));
	r.length;
	const s = e.clone();
	return s.setIndex(r), s
}
const OI = new class extends _E {
	constructor(e) {
		super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
			return new YL(e)
		})), this.register((function(e) {
			return new $L(e)
		})), this.register((function(e) {
			return new ZL(e)
		})), this.register((function(e) {
			return new XL(e)
		})), this.register((function(e) {
			return new qL(e)
		})), this.register((function(e) {
			return new KL(e)
		}))
	}
	load(e, t, n, i) {
		const r = this;
		let s;
		s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : zE.extractUrlBase(e), this.manager.itemStart(e);
		const a = function(t) {
				i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
			},
			o = new xE(this.manager);
		o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
			try {
				r.parse(n, s, (function(n) {
					t(n), r.manager.itemEnd(e)
				}), a)
			} catch (i) {
				a(i)
			}
		}), n, a)
	}
	setDRACOLoader(e) {
		return this.dracoLoader = e, this
	}
	setDDSLoader() {
		throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
	}
	setKTX2Loader(e) {
		return this.ktx2Loader = e, this
	}
	setMeshoptDecoder(e) {
		return this.meshoptDecoder = e, this
	}
	register(e) {
		return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
	}
	unregister(e) {
		return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
	}
	parse(e, t, n, i) {
		let r;
		const s = {},
			a = {};
		if ("string" == typeof e) r = e;
		else {
			if (zE.decodeText(new Uint8Array(e, 0, 4)) === JL) {
				try {
					s[WL.KHR_BINARY_GLTF] = new tI(e)
				} catch (c) {
					return void(i && i(c))
				}
				r = s[WL.KHR_BINARY_GLTF].content
			} else r = zE.decodeText(new Uint8Array(e))
		}
		const o = JSON.parse(r);
		if (void 0 === o.asset || o.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
		const l = new DI(o, {
			path: t || this.resourcePath || "",
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder
		});
		l.fileLoader.setRequestHeader(this.requestHeader);
		for (let u = 0; u < this.pluginCallbacks.length; u++) {
			const e = this.pluginCallbacks[u](l);
			a[e.name] = e, s[e.name] = !0
		}
		if (o.extensionsUsed)
			for (let u = 0; u < o.extensionsUsed.length; ++u) {
				const e = o.extensionsUsed[u],
					t = o.extensionsRequired || [];
				switch (e) {
					case WL.KHR_MATERIALS_UNLIT:
						s[e] = new jL;
						break;
					case WL.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						s[e] = new sI;
						break;
					case WL.KHR_DRACO_MESH_COMPRESSION:
						s[e] = new nI(o, this.dracoLoader);
						break;
					case WL.KHR_TEXTURE_TRANSFORM:
						s[e] = new iI;
						break;
					case WL.KHR_MESH_QUANTIZATION:
						s[e] = new aI;
						break;
					default:
						t.indexOf(e) >= 0 && a[e]
				}
			}
		l.setExtensions(s), l.setPlugins(a), l.parse(n, i)
	}
};
async function FI(e, t = {}) {
	return new Promise(((n, i) => {
		OI.load(e, (i => {
			zL.add(e, i), t.onLoad && t.onLoad(i), n(i)
		}), (() => {}), i)
	}))
}
async function zI(e, t = {}) {
	const n = await fetch(e),
		i = await n.json();
	return zL.add(e, i), t.onLoad && t.onLoad(i), i
}

function UI(e, t, n, i = 0) {
	const r = t.size,
		s = t.scale / Math.max(r.w, r.h),
		a = {},
		o = e.anchor || e.pivot || {
			x: .5,
			y: .5
		};
	"hint" === n.split("_")[0] && (o.x = 0, o.y = 0);
	const l = e.frame,
		c = e.sourceSize,
		u = e.spriteSourceSize;
	a.id = n;
	const h = n.split("/");
	a.sequence = h.pop(), a.group = h.join("/"), a.frameIndex = i, a.texCoords = new Float32Array([l.x / r.w, (r.h - l.y - l.h) / r.h, l.w / r.w, l.h / r.h]), a.meshCoords = new Float32Array([.5 * u.w + u.x - c.w * o.x, -(.5 * u.h + u.y - c.h * o.y), u.w, u.h]);
	for (let d = 0, p = a.meshCoords.length; d < p; d++) a.meshCoords[d] *= s;
	return a.anchor = o, a.sourceSize = e.sourceSize, a.spriteSourceSize = e.spriteSourceSize, a.vertices = e.vertices, a.verticesUV = e.verticesUV, a.triangles = e.triangles, a
}
FI.setDRACOLoader = e => OI.setDRACOLoader(e), FI.loader = {
	name: "gltf",
	extensions: [".gltf", ".glb"],
	function: FI
}, zI.loader = {
	name: "json",
	extensions: [".json"],
	function: zI
};
var BI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nx.d415b4ef798ddcc2.avif"
	}),
	VI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/ny.43e25496798ddcc2.avif"
	}),
	HI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nz.d3e9e244798ddcc2.avif"
	}),
	GI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/px.344dbb21798ddcc2.avif"
	}),
	WI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/py.dcc357b9798ddcc2.avif"
	}),
	qI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/pz.6fb954e1798ddcc2.avif"
	}),
	jI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nx.f9e72b50798ddcc2.webp"
	}),
	YI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/ny.7c4a5e3a798ddcc2.webp"
	}),
	XI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nz.c2966f23798ddcc2.webp"
	}),
	$I = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/px.0e95ae72798ddcc2.webp"
	}),
	ZI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/py.80936952798ddcc2.webp"
	}),
	KI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/pz.fbb1f069798ddcc2.webp"
	}),
	JI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nx.d00b0222798ddcc2.jpg"
	}),
	QI = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/ny.7547b99b798ddcc2.jpg"
	}),
	eD = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/nz.d8dc138b798ddcc2.jpg"
	}),
	tD = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/px.104b0f3c798ddcc2.jpg"
	}),
	nD = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/py.7137228c798ddcc2.jpg"
	}),
	iD = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: "./assets/pz.e8eabcfe798ddcc2.jpg"
	});

function rD(e, t = {}, n, i) {
	for (const r in e) {
		let s = r.split("/").pop().split(".").slice(0, -1).join(".");
		i && (s = i(s)), n ? (t[s] || (t[s] = {}), t[s][n] = e[r].default) : t[s] = e[r].default
	}
}
const sD = {},
	aD = (e, t, n, i) => sD[e] = {
		default: t,
		webp: n,
		avif: i
	},
	oD = sD.envmap = {};
rD({
	"/src/assets/scene/envmap/nx.jpg": JI,
	"/src/assets/scene/envmap/ny.jpg": QI,
	"/src/assets/scene/envmap/nz.jpg": eD,
	"/src/assets/scene/envmap/px.jpg": tD,
	"/src/assets/scene/envmap/py.jpg": nD,
	"/src/assets/scene/envmap/pz.jpg": iD
}, oD, "default"), rD({
	"/src/assets/scene/envmap/nx.webp": jI,
	"/src/assets/scene/envmap/ny.webp": YI,
	"/src/assets/scene/envmap/nz.webp": XI,
	"/src/assets/scene/envmap/px.webp": $I,
	"/src/assets/scene/envmap/py.webp": ZI,
	"/src/assets/scene/envmap/pz.webp": KI
}, oD, "webp"), rD({
	"/src/assets/scene/envmap/nx.avif": BI,
	"/src/assets/scene/envmap/ny.avif": VI,
	"/src/assets/scene/envmap/nz.avif": HI,
	"/src/assets/scene/envmap/px.avif": GI,
	"/src/assets/scene/envmap/py.avif": WI,
	"/src/assets/scene/envmap/pz.avif": qI
}, oD, "avif"), aD("sprites", "./assets/sprites.48581f03798ddcc2.jpg", "./assets/sprites.49a11731798ddcc2.webp", "./assets/sprites.d60fd3d4798ddcc2.avif"), aD("bluenoise", "./assets/bluenoise.5c5463f0798ddcc2.png"), aD("matcaps", "./assets/matcaps.12ef257a798ddcc2.jpg", "./assets/matcaps.d31cc084798ddcc2.webp", "./assets/matcaps.5e59986f798ddcc2.avif"), aD("bokeh", "./assets/bokeh_overlay.d509a5b1798ddcc2.jpg", "./assets/bokeh_overlay.0ab604e7798ddcc2.webp", "./assets/bokeh_overlay.7c87d4c3798ddcc2.avif"), aD("flakes", "./assets/flakes_256.fdf868cc798ddcc2.png"), aD("carData", "./assets/car_data.f5aa5435798ddcc2.png"), aD("roadDiffuse", "./assets/road_diffuse.94c7099e798ddcc2.jpg", "./assets/road_diffuse.cc0a0797798ddcc2.webp"), aD("roadData", "./assets/road_data.b87b1527798ddcc2.png"), aD("structureDiffuse", "./assets/structure_diffuse.1ae6f1a9798ddcc2.jpg", "./assets/structure_diffuse.27067941798ddcc2.webp", "./assets/structure_diffuse.58ce280f798ddcc2.avif"), aD("structureData", "./assets/structure_data.896cea23798ddcc2.png"), sD.sceneModel = "./assets/scene.42f4fab8798ddcc2.glb", sD.sceneModelDraco = "./assets/scene.drc.af74d8ad798ddcc2.glb", sD.roadCurveData = "./assets/road.1999f759798ddcc2.dat", sD.framesData = "./assets/positions.3bb996d1798ddcc2.dat", sD.spritesData = "./assets/sprites.e45dc30e798ddcc2.json";
var lD = sD;
const cD = new eE,
	uD = (e, t) => (t.position.copy(e.position), t.quaternion.copy(e.quaternion), t.scale.copy(e.scale), t.updateMatrix(), t),
	hD = new Bb;
const dD = function(e) {
	const t = new _E(e);
	Object.assign(this, t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
		position: "POSITION",
		normal: "NORMAL",
		color: "COLOR",
		uv: "TEX_COORD"
	}, this.defaultAttributeTypes = {
		position: "Float32Array",
		normal: "Float32Array",
		color: "Float32Array",
		uv: "Float32Array"
	}
};
dD.prototype = Object.assign(Object.create(_E.prototype), {
	constructor: dD,
	setDecoderPath: function(e) {
		return this.decoderPath = e, this
	},
	setDecoderConfig: function(e) {
		return this.decoderConfig = e, this
	},
	setWorkerLimit: function(e) {
		return this.workerLimit = e, this
	},
	load: function(e, t, n, i) {
		const r = new xE(this.manager);
		r.setPath(this.path), r.setResponseType("arraybuffer"), "use-credentials" === this.crossOrigin && r.setWithCredentials(!0), r.load(e, (e => {
			const n = {
				attributeIDs: this.defaultAttributeIDs,
				attributeTypes: this.defaultAttributeTypes,
				useUniqueIDs: !1
			};
			this.decodeGeometry(e, n).then(t).catch(i)
		}), n, i)
	},
	decodeDracoFile: function(e, t, n, i) {
		const r = {
			attributeIDs: n || this.defaultAttributeIDs,
			attributeTypes: i || this.defaultAttributeTypes,
			useUniqueIDs: !!n
		};
		this.decodeGeometry(e, r).then(t)
	},
	decodeGeometry: function(e, t) {
		for (const o in t.attributeTypes) {
			const e = t.attributeTypes[o];
			void 0 !== e.BYTES_PER_ELEMENT && (t.attributeTypes[o] = e.name)
		}
		const n = JSON.stringify(t);
		if (dD.taskCache.has(e)) {
			const t = dD.taskCache.get(e);
			if (t.key === n) return t.promise;
			if (0 === e.byteLength) throw new Error("DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
		}
		let i;
		const r = this.workerNextTaskID++,
			s = e.byteLength,
			a = this._getWorker(r, s).then((n => (i = n, new Promise(((n, s) => {
				i._callbacks[r] = {
					resolve: n,
					reject: s
				}, i.postMessage({
					type: "decode",
					id: r,
					taskConfig: t,
					buffer: e
				}, [e])
			}))))).then((e => this._createGeometry(e.geometry)));
		return a.finally((() => {
			i && r && this._releaseTask(i, r)
		})), dD.taskCache.set(e, {
			key: n,
			promise: a
		}), a
	},
	_createGeometry: function(e) {
		const t = new ww;
		e.index && t.setIndex(new uw(e.index.array, 1));
		for (let n = 0; n < e.attributes.length; n++) {
			const i = e.attributes[n],
				r = i.name,
				s = i.array,
				a = i.itemSize;
			t.setAttribute(r, new uw(s, a))
		}
		return t
	},
	_loadLibrary: function(e, t) {
		const n = new xE(this.manager);
		return n.setPath(this.decoderPath), n.setResponseType(t), new Promise(((t, i) => {
			n.load(e, t, void 0, i)
		}))
	},
	preload: function() {
		return this._initDecoder(), this
	},
	_initDecoder: function() {
		if (this.decoderPending) return this.decoderPending;
		const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
			t = [];
		return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
			const n = t[0];
			e || (this.decoderConfig.wasmBinary = t[1]);
			const i = dD.DRACOWorker.toString(),
				r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
			this.workerSourceURL = URL.createObjectURL(new Blob([r]))
		})), this.decoderPending
	},
	_getWorker: function(e, t) {
		return this._initDecoder().then((() => {
			if (this.workerPool.length < this.workerLimit) {
				const e = new Worker(this.workerSourceURL);
				e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
					type: "init",
					decoderConfig: this.decoderConfig
				}), e.onmessage = function(t) {
					const n = t.data;
					switch (n.type) {
						case "decode":
							e._callbacks[n.id].resolve(n);
							break;
						case "error":
							e._callbacks[n.id].reject(n)
					}
				}, this.workerPool.push(e)
			} else this.workerPool.sort((function(e, t) {
				return e._taskLoad > t._taskLoad ? -1 : 1
			}));
			const n = this.workerPool[this.workerPool.length - 1];
			return n._taskCosts[e] = t, n._taskLoad += t, n
		}))
	},
	_releaseTask: function(e, t) {
		e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
	},
	dispose: function() {
		for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
		return this.workerPool.length = 0, this
	}
}), dD.DRACOWorker = function() {
	let e, t;

	function n(e, t, n, i, r, s) {
		const a = s.num_components(),
			o = n.num_points() * a;
		let l, c, u;
		switch (r) {
			case Float32Array:
				u = 4 * o, l = e._malloc(u), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_FLOAT32, u, l), c = new Float32Array(e.HEAPF32.buffer, l, o).slice(), e._free(l);
				break;
			case Int8Array:
				l = e._malloc(o), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT8, o, l), c = new Int8Array(e.HEAP8.buffer, l, o).slice(), e._free(l);
				break;
			case Int16Array:
				u = 2 * o, l = e._malloc(u), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT16, u, l), c = new Int16Array(e.HEAP16.buffer, l, o).slice(), e._free(l);
				break;
			case Int32Array:
				u = 4 * o, l = e._malloc(u), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_INT32, u, l), c = new Int32Array(e.HEAP32.buffer, l, o).slice(), e._free(l);
				break;
			case Uint8Array:
				l = e._malloc(o), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT8, o, l), c = new Uint8Array(e.HEAPU8.buffer, l, o).slice(), e._free(l);
				break;
			case Uint16Array:
				u = 2 * o, l = e._malloc(u), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT16, u, l), c = new Uint16Array(e.HEAPU16.buffer, l, o).slice(), e._free(l);
				break;
			case Uint32Array:
				u = 4 * o, l = e._malloc(u), t.GetAttributeDataArrayForAllPoints(n, s, e.DT_UINT32, u, l), c = new Uint32Array(e.HEAPU32.buffer, l, o).slice(), e._free(l);
				break;
			default:
				throw new Error("DRACOLoader: Unexpected attribute type.")
		}
		return {
			name: i,
			array: c,
			itemSize: a
		}
	}
	onmessage = function(i) {
		const r = i.data;
		switch (r.type) {
			case "init":
				e = r.decoderConfig, t = new Promise((function(t) {
					e.onModuleLoaded = function(e) {
						t({
							draco: e
						})
					}, DracoDecoderModule(e)
				}));
				break;
			case "decode":
				const i = r.buffer,
					s = r.taskConfig;
				t.then((e => {
					const t = e.draco,
						a = new t.Decoder,
						o = new t.DecoderBuffer;
					o.Init(new Int8Array(i), i.byteLength);
					try {
						const e = function(e, t, i, r) {
								const s = r.attributeIDs,
									a = r.attributeTypes;
								let o, l;
								const c = t.GetEncodedGeometryType(i);
								if (c === e.TRIANGULAR_MESH) o = new e.Mesh, l = t.DecodeBufferToMesh(i, o);
								else {
									if (c !== e.POINT_CLOUD) throw new Error("DRACOLoader: Unexpected geometry type.");
									o = new e.PointCloud, l = t.DecodeBufferToPointCloud(i, o)
								}
								if (!l.ok() || 0 === o.ptr) throw new Error("DRACOLoader: Decoding failed: " + l.error_msg());
								const u = {
									index: null,
									attributes: []
								};
								for (const h in s) {
									const i = self[a[h]];
									let l, c;
									if (r.useUniqueIDs) c = s[h], l = t.GetAttributeByUniqueId(o, c);
									else {
										if (c = t.GetAttributeId(o, e[s[h]]), -1 === c) continue;
										l = t.GetAttribute(o, c)
									}
									u.attributes.push(n(e, t, o, h, i, l))
								}
								if (c === e.TRIANGULAR_MESH) {
									const n = 3 * o.num_faces(),
										i = 4 * n,
										r = e._malloc(i);
									t.GetTrianglesUInt32Array(o, i, r);
									const s = new Uint32Array(e.HEAPU32.buffer, r, n).slice();
									e._free(r), u.index = {
										array: s,
										itemSize: 1
									}
								}
								return e.destroy(o), u
							}(t, a, o, s),
							i = e.attributes.map((e => e.array.buffer));
						e.index && i.push(e.index.array.buffer), self.postMessage({
							type: "decode",
							id: r.id,
							geometry: e
						}, i)
					} catch (l) {
						self.postMessage({
							type: "error",
							id: r.id,
							error: l.message
						})
					} finally {
						t.destroy(o), t.destroy(a)
					}
				}))
		}
	}
}, dD.taskCache = new WeakMap;
var pD = dD;
const fD = FL.select,
	mD = ["px", "nx", "py", "ny", "pz", "nz"];
async function gD(e) {
	const t = Gi() ? Yt("preloader") : Gy;
	VL.registerLoader(HL), VL.registerLoader(FI), VL.registerLoader(zI);
	const n = e.geometries = {},
		i = e.meshes = {},
		r = e.curves = {},
		s = e.textures = {};

	function a(t, n) {
		const r = n.userData.name;
		"ROAD" === r ? i.road = n : "CAR" === r ? function(e, t) {
			const n = e.meshes,
				i = n.rawCar = t,
				r = i.children[i.children[0].name.includes("wh") ? 0 : 1],
				s = i.children[r === i.children[0] ? 1 : 0],
				a = n.car = new Bb,
				o = s.children[0].geometry;
			a.body = new pC(o, cD, 1), a.body.instanceMatrix.setUsage(35044), uD(s, a.body), uD(s.children[0], hD), a.body.setMatrixAt(0, hD.matrix), a.body.instanceMatrix.needsUpdate = !0, a.add(a.body);
			const l = r.children[0].geometry;
			a.wheels = new pC(l, cD, 4), a.wheels.instanceMatrix.setUsage(35048), uD(r, a.wheels), a.add(a.wheels), a.dummyWheels = r.children.map((e => uD(e, new Bb)))
		}(e, n) : "STRUCTURE" === r && (i.structure = n)
	}

	function l(e, t) {
		const n = t.userData,
			i = n.name;
		if (i && "*" === i[0] && (n.instancedMesh = !0), !n.instancedMesh)
			for (const r of t.children) l(t, r);
		a(0, t)
	}
	e.assets = {}, e.previousFrame = {
		value: null,
		type: "t"
	}, e.currentFrame = {
		value: null,
		type: "t"
	}, e.assets.load = async function() {
		const i = [];
		await FL.test(), n.plane = new oS, i.push(t.task(VL.load(lD.spritesData, {
			onLoad: t => {
				e.atlas = function(e) {
					const t = {
							sprites: {},
							meta: e.meta
						},
						n = e.frames;
					e.animations || (e.animations = {});
					for (const i in e.animations) {
						const r = e.animations[i],
							s = t.sprites[i] = [];
						for (let t = 0, a = r.length; t < a; t++) {
							const a = n[r[t]];
							delete n[r[t]], s.push(UI(a, e.meta, i, t))
						}
					}
					for (const i in n) {
						const r = n[i],
							s = (r.filename ? r.filename.toString() : i).replace(/[^a-zA-Z0-9-_-]/g, "").replace("png", ""),
							a = t.sprites[s] = [];
						delete n[i], a.push(UI(r, e.meta, s))
					}
					return t
				}(t)
			}
		}))), i.push(t.task(Promise.all(mD.map((e => fD(lD.envmap[e]))).map(VL.load)).then((e => e.map((e => e.node)))).then((e => {
			const t = new Zw;
			t.images = e, t.needsUpdate = !0, s.envMap2 = t
		})))), i.push(...[
			[fD(lD.sprites), "sprites", {}],
			[fD(lD.bokeh), "bokeh", {}],
			[fD(lD.bluenoise), "blueNoise", {
				repeat: !0
			}],
			[fD(lD.flakes), "flakes", {
				repeat: !0
			}],
			[fD(lD.matcaps), "matcaps"],
			[fD(lD.carData), "carData"],
			[fD(lD.roadDiffuse), "roadDiffuse"],
			[fD(lD.roadData), "roadData"],
			[fD(lD.structureDiffuse), "structureDiffuse"],
			[fD(lD.structureData), "structureData"]
		].map((e => t.task(VL.load(e[0], {
			onLoad: ({
				node: t
			}) => {
				s[e[1]] = function(e) {
					const t = new Dx(e.img);
					return void 0 !== e.flipY && (t.flipY = e.flipY), void 0 !== e.mipmaps && (t.generateMipmaps = !!e.mipmaps), e.magFilter && (t.magFilter = e.magFilter), e.minFilter && (t.minFilter = e.minFilter), e.encoding && (t.encoding = e.encoding), e.mapping && (t.mapping = e.mapping), e.premultiplyAlpha && (t.premultiplyAlpha = !0), e.repeat ? (t.wrapS = 1e3, t.wrapT = 1e3) : (e.wrapS && (t.wrapS = e.wrapS), e.wrapT && (t.wrapT = e.wrapT)), e.format && (t.format = e.format), e.type && (t.type = e.type), t.needsUpdate = !0, t
				}(o({
					img: t,
					flipY: !1
				}, e[2]))
			}
		}))))), i.push(t.task(VL.load(lD.framesData, {
			onLoad: t => {
				const n = new Float32Array(t),
					i = e.frames = [];
				for (let e = 0, r = n.length / 5; e < r; e++) {
					let t = 5 * e;
					i.push({
						quaternion: new Fx(n[t++], n[t++], n[t++], n[t++]),
						scale: n[t++]
					})
				}
			}
		}))), i.push(t.task(VL.load(lD.roadCurveData, {
			onLoad: e => {
				const t = new Float32Array(e),
					n = r.road = new KC;
				let i = null;
				for (let r = 0, s = t.length / 9; r < s; r++) {
					if (r + 1 >= s) continue;
					const e = 9 * r,
						a = i || new zx(t[e], t[e + 1], t[e + 2]),
						o = new zx(t[e + 6], t[e + 7], t[e + 8]),
						l = new zx(t[e + 12], t[e + 13], t[e + 14]),
						c = i = new zx(t[e + 9], t[e + 10], t[e + 11]);
					n.add(new qC(a, o, l, c))
				}
			}
		})));
		let a = lD.sceneModel;
		const c = new pD;
		c.setDecoderPath(__DATA.config.basepath + "vendors/draco/"), c.preload(), FI.setDRACOLoader(c), a = lD.sceneModelDraco, i.push(t.task(FI(a, {
			onLoad: e => {
				for (const t of e.scene.children) l(e.scene, t)
			}
		}))), await Promise.all(i), e.atlas.meta.image = e.textures.sprites, e.atlas.texture = e.textures.sprites
	}
}

function vD(e) {
	e.store = {
		renderOrder: {
			background: 0,
			road: 1,
			carShadow: 2,
			car: 3,
			structure: 4,
			turboLine: 5,
			carTrails: 6,
			sprites: 7,
			cloudParticles: 8
		},
		carShadow: new Cx,
		shadowActive: ef(!1)
	}
}
const _D = () => {};

function yD(e) {
	const t = {
		createBuffer: function(e) {
			return function({
				renderer: e,
				alpha: t,
				depth: n,
				stencil: i,
				width: r,
				height: s,
				name: a
			}) {
				const o = Cx.get();
				r && s ? o.set(r, s) : e.getDrawingBufferSize(o);
				const l = new Nx(o.x, o.y, {
					minFilter: 1006,
					magFilter: 1006,
					format: 1023,
					depthBuffer: !!n,
					stencilBuffer: !!i
				});
				return o.release(), l.texture.generateMipmaps = !1, l
			}(e)
		},
		registerBuffer: _D,
		unregisterBuffer: _D
	};
	e.fbo = t
}

function xD(e) {
	const t = e.game,
		n = {
			IDLE: 0,
			STARTING: 1,
			ACTIVATING: 2,
			ACTIVE: 3,
			ENDED: 4
		},
		i = "tuto_done";
	let r = 0,
		s = 0,
		a = !0,
		l = !1,
		c = 0,
		u = !0,
		h = -1,
		d = !1;
	const p = o({
		current: n.IDLE,
		reset: function() {
			r = 0, s = 0, a = !0, l = !1, c = 0, h = -1, d = !1
		},
		update: function(o) {
			const x = p.current;
			r = s, s += o, x === n.STARTING ? function(i) {
				const a = e.audio;
				0 === r && (Ll.$stores.keysVisible = !1, a.setBgm("pad"));
				m(g) && a.playSound("UI_Countdown_Three");
				m(1700) && a.playSound("UI_Countdown_Two");
				m(2700) && a.playSound("UI_Countdown_One");
				m(3700) && a.playSound("UI_Countdown_GO");
				m(1e3) && t.view && t.view.countdown.value.show();
				s > 4e3 && f(n.ACTIVATING)
			}() : x === n.ACTIVATING ? (a = !1, l = !1, c = 1e5, Ll.$stores.keysVisible = !1, f(n.ACTIVE)) : x === n.ACTIVE ? function(r) {
				m(10) && e.audio.setBgm("pad+guitar");
				m(6e3) && e.audio.setBgm("pad+drum+guitar");
				m(12e3) && e.audio.setBgm("all");
				m(1e3) && t.view && t.view.timer.value.show();
				m(1200) && (t.view && !a && u && t.view.tuto.value.show(), a = !0, Ll.$stores.keysVisible = !0);
				a && s > 3200 && e.controls.active && (t.view && t.view.tuto.value.hide(), a = !1, u = !1, sessionStorage.setItem(i, 1), c = s);
				!l && s - c > 1e3 && (l = !0, t.view && t.view.turbo.value.show());
				t.progress >= t.checkpoints.list.finish && (t.updateBestTime(), Ll.$rtcDisplay.enabled.value && Ll.$rtcDisplay.sendFinish(t.racetime, t.bestTime), f(n.ENDED))
			}() : x === n.ENDED && function(n) {
				0 === r && (Ll.$stores.keysVisible = !1, e.audio.playSound("UI_Finish"));
				e.gameCam.activeInfluence < .08 && (h < 0 && (h = performance.now()), function(t) {
					const n = performance.now();
					if (n < v) return;
					e.audio.playSound("FireworksEnd", {
						volume: TA.randomFloat(.4, .6)
					}), y = Math.random() < _, y ? _ = 0 : _ += .15 + _;
					const i = y ? TA.randomFloat(10, 90) : TA.randomFloat(150, 420);
					v = n + i, e.scene.emitFirework()
				}());
				m(20) && t.view && t.view.finish.value.show();
				m(700) && e.audio.setBgm("outro");
				m(10) && t.view && (t.view.tuto.value.hide(), t.view.countdown.value.hide(), t.view.turbo.value.hide());
				const i = performance.now();
				if (!d && p.stateTime > 4500 && i - h > 3e3) {
					if (d) return;
					Ll.$router.push({
						name: "result"
					})
				}
			}()
		},
		isGameRunning: function() {
			return p.current > n.IDLE && p.current < n.ENDED
		},
		hasEnded: function(e = 0, i = 0) {
			if (!e && !i) return p.current >= n.ENDED;
			const r = t.checkpoints.list.finish + i;
			return p.current >= n.ENDED && s >= e && t.progress >= r
		},
		get stateTime() {
			return s
		},
		set: f
	}, n);

	function f(e) {
		p.current = e, r = s = 0, h = -1, d = !1, t.ended.set(e > n.ACTIVE)
	}

	function m(e) {
		return r < e && s >= e
	}
	const g = 700;
	let v = 0,
		_ = 1,
		y = !1;
	return p
}
const bD = wD();

function wD() {
	return {
		position: new zx,
		quaternion: new Fx,
		scale: new zx(1, 1, 1)
	}
}

function SD(e) {
	const t = {
			reset: jp()
		},
		n = localStorage.getItem("best_time"),
		i = e.game = {
			createFrameData: wD,
			currentCam: ef(null),
			time: 0,
			racetime: 0,
			elapsed: 0,
			bestTime: null == n || isNaN(n) ? -1 : n,
			getRoadData: function(e) {
				return u(i.progressNorm, e)
			},
			getRelativeRoadData: function(e, t) {
				return u(i.progressNorm + e / i.roadLength, t)
			},
			getAbsoluteRoadData: u,
			normalizeProgress: function(e) {
				return ky(e / i.roadLength, 0, 1)
			},
			roadLength: 0,
			minVelocity: 8,
			maxVelocity: 10.5,
			turboVelocity: 19.8,
			velocity: 0,
			progress: 0,
			progressNorm: 0,
			replay: function() {
				h()
			},
			resetting: !1,
			started: !1,
			ended: ef(!1),
			hooks: t,
			setView: function(e) {
				i.view = e, h()
			},
			removeView: function(e) {
				if (i.view !== e) return;
				i.view = null, h()
			},
			view: null,
			updateProgressNorm: d,
			updateBestTime: function() {
				(i.bestTime < 0 || i.racetime < i.bestTime) && (i.bestTime = i.racetime, localStorage.setItem("best_time", i.bestTime))
			},
			paused: ef(!1),
			isPaused: p,
			forceAutopilot: ef(!1)
		},
		r = function(e) {
			let t = 0;
			const n = {
				progress: 0,
				velProgress: 0,
				hover: !1,
				active: ef(!1),
				init: function() {
					e.game.hooks.reset.watch(i)
				},
				reset: i,
				update: function() {
					const i = e.time.stableDt,
						r = e.scene.road.car,
						s = e.game.progress;
					if (n.active.value) n.progress -= 2.9 * i * 1e-4, n.progress <= 0 && (n.active.set(!1), t = s);
					else if (n.cooldownActive && (n.cooldownActive = s - t < 15), n.hover || (n.progress -= 2 * i * 1e-4, n.cooldownActive || n.ended || (n.velProgress -= 2.8 * i * 1e-4)), r.dip) {
						const e = .007 * ky(Oy(r.dipStrength, .01, .02, 0, 1), 0, 1);
						n.progress -= e, n.active.value || n.cooldownActive || (n.velProgress -= e)
					}
					n.velProgress = ky(n.velProgress, 0, 1), n.progress = ky(n.progress, 0, 1)
				},
				addHitDistance: function(i) {
					if (n.active.value) return;
					const r = n.progress,
						s = i / 50;
					n.progress = ky(n.progress + s, 0, 1);
					const a = i / 50;
					n.velProgress = ky(n.velProgress + a, 0, 1), n.progress >= 1 && r < 1 && (n.cooldownActive = !0, t = e.game.progress, n.active.set(!0), e.audio.playSound("Car_Engine_Boost"))
				},
				cooldownActive: !1,
				cooldown: 15,
				distanceToFill: 50,
				ended: !1
			};
			return n;

			function i() {
				n.progress = 0, n.velProgress = 0, n.hover = !1, n.active.set(!1), n.cooldownActive = !1
			}
		}(e);
	i.turbo = r;
	const s = xD(e);
	i.state = s;
	const a = function(e) {
		return e.game, {
			list: {
				start: 3,
				finish: 786.5
			},
			reset: function() {},
			update: function(e) {}
		}
	}(e);
	let o, l, c;

	function u(t, n) {
		t = ky(t, 0, 1);
		const i = n || bD,
			r = e.frames,
			s = t * (r.length - 1),
			a = Math.floor(s),
			l = s - a,
			c = r[a],
			u = r[a + 1] || c;
		return i.position = o.getPointAt(t, i.position), i.quaternion.slerpQuaternions(c.quaternion, u.quaternion, l), i.scale.set(1, zy(c.scale, u.scale, l), 1), i
	}

	function h() {
		l = !0
	}

	function d() {
		i.progressNorm = ky(i.progress / i.roadLength, 0, 1)
	}

	function p() {
		return i.paused.value && e.scene.gameCam.used
	}
	i.checkpoints = a, i.autopilot = function(e, t) {
		const n = new Qp,
			i = n.set.bind(n);
		delete n.set, e = Array.isArray(e) ? e : [e];
		const r = new Array(e.length);
		let s = [];
		for (let o = 0, l = e.length; o < l; o++) {
			const t = e[o],
				n = function(e) {
					r[o] = e, a()
				};
			r[o] = t.value, t.watch(n), s.push(t, n)
		}

		function a() {
			const e = t.apply(null, r);
			e && e.then ? e.then(i) : i(e)
		}
		return n.destroy = function() {
			for (let e = 0, t = s.length; e < t; e += 2) s[e].unwatch(s[e + 1]);
			s = null, n.unwatchAll()
		}, a(), n
	}([i.forceAutopilot, i.turbo.active, i.currentCam, i.ended], ((e, t, n, i) => e || t || n && n.forceCarAutopilot || i)), e.hooks.afterLoad.watchOnce((function() {
		br((() => {
			i.paused.set(Ll.$stores.gamePaused)
		})), o = e.curves.road, i.roadLength = o.getLength(), r.init()
	})), e.hooks.beforeUpdate.watch((function() {
		const n = e.time.stableDt;
		e.scene.currentCamera !== i.currentCam.value && i.currentCam.set(e.scene.currentCamera);
		if (p()) return;
		c && (i.resetting = !1, c = !1);
		l && function() {
			i.time = 0, i.racetime = 0, i.progress = 0, d(), i.resetting = !0;
			const e = i.view;
			let n = s.IDLE;
			e && (n = s.STARTING);
			s.set(n), l = !1, c = !1, i.progress = Math.min(a.list.start, i.roadLength), t.reset.emit(), r.reset(), s.reset(), a.reset(), i.view && i.view.hideAll()
		}();
		const o = n / 1e3;
		i.elapsed += n, i.time += n, s.current === s.ACTIVE && (i.racetime += n);
		e.scene.road.car.updateVelocity(), i.progress = ky(i.progress + i.velocity * o, 0, i.roadLength), d(), r.update(n), s.update(n), i.resetting && (c = !0)
	})), e.hooks.afterStart.watchOnce(h)
}
var MD = "precision highp float;varying vec2 vUv;uniform sampler2D colorTexture;uniform vec2 texSize;uniform vec2 direction;uniform float sigma;uniform int kernelRadius;\n#ifdef USE_HIGH_PASS\nuniform float threshold;\n#include <shaderHighPass>\n#endif\nfloat gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1.0/texSize;float weightSum=gaussianPdf(0.0,sigma);\n#ifdef USE_HIGH_PASS\nvec3 diffuseSum=highPass(texture2D(colorTexture,vUv).rgba,threshold,0.001)*weightSum;\n#else\nvec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;\n#endif\nif(kernelRadius==3){for(int i=1;i<3;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==5){for(int i=1;i<5;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==7){for(int i=1;i<7;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==9){for(int i=1;i<9;i++){\n#include <shaderBlurChunk>\n}}else if(kernelRadius==11){for(int i=1;i<11;i++){\n#include <shaderBlurChunk>\n}}gl_FragColor=vec4(diffuseSum/weightSum,1.0);}";
const TD = [3, 5, 7, 9, 11],
	CD = new Cx(1, 0),
	ED = new Cx(0, .8),
	AD = {
		format: 1022
	},
	PD = {
		exposure: .9,
		threshold: .6,
		strength: 1.45,
		radius: 1,
		resolution: new Cx(512, 512)
	},
	LD = [],
	ID = [],
	DD = [];
let RD, kD, ND, OD, FD;

function zD(e, t, n) {
	const i = new Nx(t, n, AD);
	return i.texture.name = e, i.texture.generateMipmaps = !1, (e.endsWith("H.mip0") || e.endsWith("site")) && Ol.fbo.registerBuffer(e, i), i
}
var UD = {
		init: function(e) {
			FD = Ol.threeRenderer;
			const t = Cx.get().copy(PD.resolution);
			lS.shaderBlurChunk = "float x=float(i);float w=gaussianPdf(x,sigma);vec2 uvOffset=direction*invSize*x;\n#ifdef USE_HIGH_PASS\nvec3 sample1=highPass(texture2D(colorTexture,vUv+uvOffset).rgba,threshold,0.001);vec3 sample2=highPass(texture2D(colorTexture,vUv-uvOffset).rgba,threshold,0.001);\n#else\nvec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;\n#endif\ndiffuseSum+=(sample1+sample2)*w;weightSum+=2.0*w;", lS.shaderHighPass = "const vec3 hp_DefaultColor=vec3(0.0);const vec3 hp_Luma=vec3(0.299,0.587,0.114);const vec3 pinkColor=vec3(1.,0.5,0.5);vec3 highPass(vec4 texel,float threshold,float epsilon){float neon=step(0.995,texel.g);float intensity=1.-texel.a;float hasWhite=step(0.995,texel.b);float whiteNeon=step(0.995,texel.b);float pinkNeon=step(0.995,texel.g);whiteNeon+=pinkNeon*hasWhite;pinkNeon*=(1.-hasWhite);whiteNeon*=texel.b;pinkNeon*=texel.g;float v=dot(texel.xyz,hp_Luma);float test=step(texel.a,0.999);return texel.rgb*intensity*2.;}";
			for (let n = 0; n < TD.length; n++) 0 === n && (RD = zD("Bloom.composite", t.x, t.y)), LD.push(zD("BloomBlurH.mip" + n, t.x, t.y)), ID.push(zD("BloomBlurV.mip" + n, t.x, t.y)), DD.push(ID[n].texture), t.set(.5 * t.x | 0, .5 * t.y | 0);
			Cx.release(t), kD = pA({
				name: "Bloom - Composite",
				renderer: Ol.threeRenderer,
				fragmentShader: "precision highp float;varying vec2 vUv;uniform sampler2D blurTexture1;uniform sampler2D blurTexture2;uniform sampler2D blurTexture3;uniform sampler2D blurTexture4;uniform sampler2D blurTexture5;uniform float bloomStrength;uniform float bloomRadius;uniform float bloomFactors[NUM_MIPS];uniform vec3 bloomTintColors[NUM_MIPS];float lerpBloomFactor(const in float factor){float mirrorFactor=1.2-factor;return mix(factor,mirrorFactor,bloomRadius);}void main(){gl_FragColor=bloomStrength*(lerpBloomFactor(bloomFactors[0])*vec4(bloomTintColors[0],1.0)*texture2D(blurTexture1,vUv)+lerpBloomFactor(bloomFactors[1])*vec4(bloomTintColors[1],1.0)*texture2D(blurTexture2,vUv)+lerpBloomFactor(bloomFactors[2])*vec4(bloomTintColors[2],1.0)*texture2D(blurTexture3,vUv)+lerpBloomFactor(bloomFactors[3])*vec4(bloomTintColors[3],1.0)*texture2D(blurTexture4,vUv)+lerpBloomFactor(bloomFactors[4])*vec4(bloomTintColors[4],1.0)*texture2D(blurTexture5,vUv));}",
				transparent: !1,
				uniforms: {
					blurTexture1: {
						value: ID[0].texture
					},
					blurTexture2: {
						value: ID[1].texture
					},
					blurTexture3: {
						value: ID[2].texture
					},
					blurTexture4: {
						value: ID[3].texture
					},
					blurTexture5: {
						value: ID[4].texture
					},
					bloomStrength: {
						value: 1
					},
					bloomRadius: {
						value: 0
					},
					bloomFactors: {
						value: [1, .8, .6, .4, .2]
					},
					bloomTintColors: {
						value: [new zx(1, 1, 1), new zx(1, 1, 1), new zx(1, 1, 1), new zx(1, 1, 1), new zx(1, 1, 1)]
					}
				},
				defines: {
					NUM_MIPS: TD.length
				}
			}), OD = pA({
				renderer: Ol.threeRenderer,
				fragmentShader: MD,
				transparent: !1,
				uniforms: {
					colorTexture: {
						value: LD[0].texture
					},
					texSize: {
						value: (new Cx).setScalar(.5 * PD.resolution)
					},
					direction: {
						value: CD
					},
					kernelRadius: {
						type: "i",
						value: TD[0]
					},
					sigma: {
						type: "f",
						value: TD[0]
					}
				}
			}), ND = pA({
				renderer: Ol.threeRenderer,
				fragmentShader: MD,
				transparent: !1,
				uniforms: Object.assign({}, OD.u, {
					threshold: {
						value: .5
					}
				}),
				defines: {
					USE_HIGH_PASS: !0
				}
			})
		},
		render: function(e) {
			if (0 === PD.exposure) return;
			let t = ND;
			t.uniforms.threshold.value = PD.threshold;
			for (let n = 0; n < TD.length; n++) {
				const i = TD[n];
				t.u.kernelRadius.value = 0 | i, t.u.sigma.value = i;
				const r = LD[n];
				t.u.texSize.value.set(r.width, r.height), t.u.colorTexture.value = e.texture, t.u.direction.value = CD, FD.setRenderTarget(r), t.render(), t = OD, t.u.colorTexture.value = LD[n].texture, t.u.direction.value = ED, FD.setRenderTarget(ID[n]), t.render(), e = ID[n]
			}
			kD.u.bloomStrength.value = PD.strength, kD.u.bloomRadius.value = PD.radius, FD.setRenderTarget(RD), kD.render()
		},
		resize: function(e, t) {
			const n = Cx.get().set(e, t);
			for (let i = 0; i < TD.length; i++) 0 === i && RD.setSize(n.x, n.y), LD[i].setSize(n.x, n.y), ID[i].setSize(n.x, n.y), n.set(.5 * n.x | 0, .5 * n.y | 0);
			Cx.release(n)
		},
		blurTextures: DD,
		params: PD,
		get compositeTexture() {
			return RD.texture
		}
	},
	BD = fA(hA, "precision highp float;\n#include <blend_add>\n#include <luma>\n#define PI 3.1415926538\nuniform sampler2D scene;uniform vec4 res;uniform float dpi;uniform vec4 uvOverlayOffset;uniform sampler2D bloom;uniform float time;uniform float bloomExposure;uniform sampler2D noise;uniform vec2 ditherOffset;uniform float menuInfluence;uniform sampler2D overlayTex;uniform vec2 press;varying vec2 vUv;const vec3 PINK=vec3(0.871,0.012,0.682);const vec3 BLUE=vec3(0.1,0.098,0.355);vec3 blendOverlay(vec3 base,vec3 blend){return mix(1.0-2.0*(1.0-base)*(1.0-blend),2.0*base*blend,step(base,vec3(0.5)));}vec3 blendSoftLight(vec3 base,vec3 blend){return mix(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend),2.0*base*blend+base*base*(1.0-2.0*blend),step(base,vec3(0.5)));}float gradientEase(float t){float tm1=t-1.0;float tm1_2=tm1*tm1;return 1.0-tm1_2*tm1_2;}vec2 correctRatio(vec2 inUv){return vec2(inUv.x*uvOverlayOffset.x+uvOverlayOffset.y,inUv.y*uvOverlayOffset.z+uvOverlayOffset.w);}const int speedBlurSamples=6;const float overlayRatio=1024./512.;void main(){vec2 uv=vUv;vec2 pxCoords=vUv*res.xy/dpi;vec2 buv=uv;buv.x+=cos(cos(buv.y)*120.+time*0.012)*0.0004;buv.y+=cos(buv.x*70.+time*0.022)*0.0002;vec3 bloomTexel=texture2D(bloom,buv).xyz;vec3 diffuse=texture2D(scene,vUv).rgb;float radius=length(vUv*2.-1.);diffuse=mix(diffuse,diffuse*0.4,smoothstep(0.8-menuInfluence*0.7,1.8,radius));bloomTexel=bloomTexel*bloomExposure;diffuse+=bloomTexel;diffuse=blendAdd(diffuse,bloomTexel*0.3);diffuse=blendAdd(diffuse,bloomTexel*0.2);diffuse=min(diffuse,1.);diffuse.r-=(1.-gradientEase(min(1.,(1.-vUv.y)*0.6+vUv.x*0.05)))*0.11;diffuse=mix(diffuse,BLUE,(1.-gradientEase(min(1.,(1.-vUv.x)*0.25+vUv.y*0.8-0.15)))*0.05);float screenRatio=res.x/res.y;vec2 overlayUv=mix(correctRatio(vUv.yx),correctRatio(vUv),step(1.,screenRatio));vec3 dirt=texture2D(overlayTex,overlayUv).rgb;diffuse=blendOverlay(diffuse,dirt*bloomTexel*1.8+0.5);diffuse=mix(diffuse,blendOverlay(diffuse,dirt+0.5),luma(diffuse)*0.15);float lum=clamp(luma(diffuse),0.,1.);vec3 dither=texture2D(noise,(pxCoords+ditherOffset)/NOISE_SIZE*dpi).rgb;vec3 ditheredDiffuse=blendSoftLight(diffuse,dither);diffuse=mix(diffuse,ditheredDiffuse,0.85);vec3 menuDiffuse=diffuse*vec3(0.4+diffuse.r*0.6,0.2,0.2);diffuse=mix(diffuse,menuDiffuse,menuInfluence);float vtouch=cos(uv.y*PI*2.)*0.02+0.13;float touch=smoothstep(0.8,1.3,(1.-uv.x)-vtouch)*press.x+smoothstep(0.8,1.3,uv.x-vtouch)*press.y;diffuse=mix(diffuse,vec3(2.,0.5,0.5),touch*4.);gl_FragColor=vec4(diffuse,1.);}");
let VD = 1;
const HD = new kx;

function GD(e) {
	const t = {},
		n = {},
		i = {};
	let r = 128;
	const s = {
		init: function() {
			UD.init(undefined), t.ping = e.fbo.createBuffer({
				name: "Scene - Main Ping",
				renderer: e.threeRenderer,
				depth: !0,
				alpha: !0,
				stencil: !0
			}), t.pong = e.fbo.createBuffer({
				name: "Scene - Main Pong",
				renderer: e.threeRenderer,
				depth: !0,
				alpha: !0,
				stencil: !0
			}), o(), r = e.textures.blueNoise.image.naturalWidth, n.main = pA({
				renderer: e.threeRenderer,
				vertexShader: BD.vs,
				fragmentShader: BD.fs,
				uniforms: Object.assign({
					res: {
						value: new kx
					},
					dpi: {
						value: 0
					},
					scene: e.currentFrame,
					uvOverlayOffset: {
						value: new kx
					},
					time: {
						value: 0
					},
					bloom: {
						value: UD.compositeTexture
					},
					bloomExposure: {
						value: UD.params.exposure
					},
					noise: {
						value: e.textures.blueNoise
					},
					ditherOffset: {
						value: [0, 0]
					},
					overlayTex: {
						value: e.textures.bokeh
					},
					menuInfluence: {
						value: 0
					},
					press: {
						value: [0, 0]
					}
				}),
				defines: {
					NOISE_SIZE: (s = r, s.toString().includes(".") ? s : s + ".")
				}
			}), i.dither = {
				maxFrames: 1,
				frame: 0,
				value: n.main.u.ditherOffset.value
			}, BD.use(n.main.material), e.renderer.drawingBufferSize.watchImmediate(l);
			var s
		},
		enabled: !0,
		update: function() {
			const t = n.main.u;
			t.menuInfluence.value = zy(t.menuInfluence.value, e.game.paused.value ? 1 : 0, .1), t.time.value = e.time.elapsed, a = zy(a, e.controls.pressed ? 1 : 0, e.controls.pressed ? .8 : .1);
			const s = t.press.value;
			s[0] = zy(s[0], a * Math.min(0, e.controls.turn) * -1, e.controls.active ? .15 : .2), s[1] = zy(s[1], a * Math.max(0, e.controls.turn), e.controls.active ? .15 : .2),
				function(e) {
					if (e.frame += 1, e.frame < e.maxFrames) return;
					e.frame = 0, e.value[0] = TA.randomInt(.5 * -r, .5 * r), e.value[1] = TA.randomInt(.5 * -r, .5 * r)
				}(i.dither)
		},
		render: function() {
			n.main.u.bloomExposure.value = UD.params.exposure, n.main.render()
		},
		renderBloom: function(e) {
			UD.render(e)
		},
		buffers: t,
		filters: n,
		bloom: UD,
		pingpong: o
	};
	e.postprocess = s;
	let a = 0;

	function o() {
		const n = t.ping,
			i = t.pong,
			r = t.main === n ? n : i,
			s = r === i ? n : i;
		t.main = s, e.previousFrame.value = r.texture, e.currentFrame.value = s.texture
	}

	function l(i) {
		t.ping.setSize(i.x, i.y), t.pong.setSize(i.x, i.y), VD = i.x > i.y ? i.x / i.y : i.y / i.x, n.main.u.res.value.set(i.x, i.y, 1 / i.x, 1 / i.y), n.main.u.dpi.value = e.renderer.pixelRatio.value, HD.x = 2 > VD ? VD / 2 : 1, HD.y = 2 > VD ? .5 * (1 - VD / 2) : 0, HD.z = 2 <= VD ? 2 / VD : 1, HD.w = 2 <= VD ? .5 * (1 - 2 / VD) : 0, n.main.u.uvOverlayOffset.value.copy(HD)
	}
}
const WD = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(((e, t) => (e[t] = 1, e)), {});

function qD(e) {
	e.hooks.afterLoad.watchOnce((function() {
		window.addEventListener("keydown", s), window.addEventListener("keyup", a), e.viewport.visible.watchImmediate((() => {
			for (const e in t) t[e] = !1
		}))
	})), e.hooks.beforeFrame.watch((function() {
		const r = e.touch.value,
			s = Ll.$rtcDisplay,
			a = s.enabled.value;
		s.controls.state, t.keyA || t.KeyD || t.ArrowLeft || t.ArrowRight ? i.keyboard = !0 : (r.pressed || a && s.controls.state) && (i.keyboard = !1);
		Ll.$rtcDisplay.enabled.value ? (n.left = s.controls.state < 0, n.right = s.controls.state > 0) : (n.left = t.KeyA || t.ArrowLeft || r.pressed && r.activeFinger.normalizePos.x < 0, n.right = t.KeyD || t.ArrowRight || r.pressed && r.activeFinger.normalizePos.x > 0);
		const o = e.time.stableDt,
			l = o / 16.6667,
			c = i.active = !(!n.left && !n.right),
			u = (i.keyboard, c ? .15 : .18);
		i.turnTarget = (-1 * +n.left + 1 * +n.right) * l;
		(e.game.state.current !== e.game.state.ACTIVE || e.game.autopilot.value) && (i.turnTarget = 0, i.active = !1);
		i.pressed = r.pressed, i.turn = Vy(i.turn, i.turnTarget, u, o, .001), i.direction.set(n.right ? 1 : n.left ? -1 : 0)
	}));
	const t = {
			KeyA: !1,
			KeyD: !1,
			ArrowLeft: !1,
			ArrowRight: !1
		},
		n = {
			left: !1,
			right: !1
		},
		i = e.controls = {
			active: !1,
			turn: 0,
			turnTarget: 0,
			pressed: !1,
			keyboard: !0,
			steeringMultKeyboard: 1.1,
			steeringMultTouch: .9,
			rotationMultKeyboard: 1,
			rotationMultTouch: .9,
			direction: ef(0)
		},
		r = Object.keys(t).reduce(((e, t) => (e[t] = 1, e)), {});

	function s(e) {
		(function(e) {
			return !(WD[e.tagName] || e.code && !r[e.code])
		})(e) && (t[e.code] = !0)
	}

	function a(e) {
		r[e.code] && (t[e.code] = !1)
	}
}
const jD = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"].reduce(((e, t) => (e[t] = 1, e)), {}),
	YD = ["game", "webgl"].reduce(((e, t) => (e[t] = 1, e)), {}),
	XD = void 0 !== window.visualViewport && void 0 !== window.visualViewport.scale,
	$D = [{
		identifier: -987654321,
		clientX: 0,
		clientY: 0
	}];

function ZD(e) {
	return $D[0].clientX = e.clientX || 0, $D[0].clientY = e.clientY || 0, $D
}
let KD, JD;
const QD = () => KD = !1;

function eR() {
	KD = !0, clearTimeout(JD), JD = setTimeout(QD, 200)
}

function tR(e) {
	let t;
	const n = Al(),
		i = n.$router,
		r = n.$viewport;

	function s(e) {
		this.name = e, this.position = this.pos = new Cx, this.prevPosition = this.prevPos = new Cx, this.relPos = this.relativePos = new Cx, this.normalizePos = new Cx, this.normalizeRelPos = this.normalizeRelativePos = new Cx, this.initialPos = new Cx, this.vel = this.velocity = new Cx, this.identifier = -1, this.used = !1, this.use = e => {
			this.used = !0, this.id = e.identifier;
			const t = r.width.value,
				n = r.height.value;
			this.initialPos.set(e.clientX || 0, e.clientY || 0), this.pos.set(e.clientX || 0, e.clientY || 0), this.relPos.set(0, 0), this.vel.set(0, 0), this.normalizePos.set(Oy(this.pos.x, 0, t, -1, 1), Oy(this.pos.y, 0, n, 1, -1)), this.normalizeRelPos.set(0, 0)
		}, this.move = e => {
			const t = r.width.value,
				n = r.height.value;
			this.pos.set(e.clientX, e.clientY), this.relPos.subVectors(this.pos, this.initialPos), this.normalizePos.set(Oy(this.pos.x, 0, t, -1, 1), Oy(this.pos.y, 0, n, 1, -1)), this.normalizeRelPos.set(Oy(this.relPos.x, 0, t, -1, 1), Oy(this.relPos.y, 0, n, 1, -1))
		}, this.unuse = () => {
			this.used = !1, this.id = -1
		}
	}
	const a = new s("Finger 1"),
		o = new s("Finger 2"),
		l = ef({
			pressed: !1,
			clickIn: !1,
			clickOut: !1,
			pos: new Cx,
			relativePos: new Cx,
			delta: new Cx,
			normalizePos: new Cx,
			normalizeRelativePos: new Cx,
			activeFinger: a
		}),
		c = {
			firstPos: new Cx,
			prevPos: new Cx,
			clickIn: !1,
			clickOut: !1,
			pressed: !1,
			pos: new Cx(0, 0),
			relativePos: new Cx(0, 0),
			delta: new Cx(0, 0),
			interactive: !1,
			active: !1,
			useTouch: !1,
			fingerCount: 0,
			containerOffset: new Cx
		};

	function u(e) {
		return !!e && (!e.target || ! function(e) {
			if (!e) return !1;
			const t = e.tagName,
				n = i.currentRoute.value.name || "";
			return !!(!YD[n] || jD[t] || XD && 1 !== window.visualViewport.scale)
		}(e.target))
	}

	function h(e) {
		return e.changedTouches[e.changedTouches.length - 1]
	}

	function d(e) {
		if (e && void 0 !== e.identifier) return a.id === e.identifier ? a : o.id === e.identifier ? o : null
	}

	function p(e) {
		const n = !!e.changedTouches;
		if (n) eR();
		else if (KD) return;
		if (!n && 0 !== e.button) return;
		if (c.fingerCount >= 2) return;
		if (!u(e)) return;
		e.preventDefault();
		const i = n ? h(e) : e;
		c.delta.set(0, 0), c.firstPos.set(i.clientX || 0, i.clientY || 0), c.prevPos.copy(c.firstPos), c.pos.copy(c.firstPos), c.pressed = !0, c.clickIn = !0, c.clickOut = !1;
		const r = n ? e.changedTouches : ZD(e);
		for (let t = 0; t < r.length; t++) {
			const e = r[t];
			let n = d(e);
			n || c.fingerCount >= 2 || (n = a.used ? o : a, n.use(e), v = n, c.fingerCount++)
		}
		t = !0, _()
	}

	function f(e) {
		const n = !!e.changedTouches,
			i = n ? h(e) : e;
		c.pos.set(i.clientX || 0, i.clientY || 0), c.pressed ? c.relativePos.copy(c.pos).sub(c.firstPos) : c.relativePos.set(0, 0);
		const r = n ? e.changedTouches : ZD(e);
		for (let t = 0; t < r.length; t++) {
			const e = r[t],
				n = d(e);
			n && n.move(e)
		}
		t = !0
	}

	function m(e) {
		const n = !!e.changedTouches;
		if (n) eR();
		else if (KD) return;
		if (!n && 0 !== e.button) return;
		if (u(e)) e.preventDefault();
		else if (!c.pressed) return;
		n && h(e);
		const i = n ? e.changedTouches : ZD(e);
		for (let t = 0; t < i.length; t++) {
			const e = d(i[t]);
			if (!e) return;
			e.unuse(), c.fingerCount--
		}
		c.clickIn = !1, c.clickOut = c.pressed, t = !0, c.pressed = !(c.fingerCount <= 0), _(), t = !0, c.relativePos.set(0, 0)
	}

	function g() {
		(c.clickIn || c.clickOut) && (t = !0), c.clickOut = c.clickIn = !1, c.delta.copy(c.pos).sub(c.prevPos), c.prevPos.copy(c.pos);
		const e = l.value.delta;
		t || (t = !c.delta.equals(e) || 0 !== c.delta), t && _(), t = !1
	}
	e.touch = l, e.hooks.afterLoad.watchOnce((function() {
		const t = window,
			n = "addEventListener",
			i = {
				passive: !1
			};
		t[n]("touchstart", p, i), t[n]("touchmove", f, i), t[n]("touchend", m, i), t[n]("touchcancel", m, i), t[n]("mousedown", p, i), t[n]("mousemove", f, i), t[n]("mouseup", m, i), t[n]("gesturestart", (e => e.preventDefault()), i), e.hooks.beforeFrame.watch(g)
	}));
	let v = a;

	function _() {
		const e = l.value;
		e.pressed = c.pressed, e.clickIn = c.clickIn, e.clickOut = c.clickOut, e.pos.copy(c.pos), e.relativePos.copy(c.relativePos), e.delta.copy(c.delta);
		const t = {
			x: r.width.value,
			y: r.height.value
		};
		e.activeFinger = o.used && !a.used ? o : a.used && !o.used || a.used && o.used && v === a ? a : a.used && o.used && v === o ? o : a, e.normalizePos.set(Oy(e.pos.x, 0, t.x, -1, 1), Oy(e.pos.y, 0, t.y, 1, -1)), e.normalizeRelativePos.copy(e.relativePos).divide(t), l.set(e, !0)
	}
}
const nR = 2 * Math.PI,
	iR = new aw(1, 1, 1),
	rR = new zx;
var sR = {
		beforeEmit: function(e = {}) {
			e.position || (e.position = rR), e.scale = e.scale || 1, e.angOffset = TA.randomFloat(0, nR)
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			durationMin: s,
			durationMax: a,
			sprite: o,
			color: l,
			amount: c,
			billboard: u,
			velocity: h,
			opacity: d,
			gravity: p = 0
		}) {
			const f = nR / c,
				m = e.index * f + TA.randomFloat(-.2, .2) + t;
			let g = (.01 + TA.randomFloat(-.005, .007)) * i;
			g = .003 * h.x, e.billboard = u, e.angVelocity = 0, e.spriteId = o, e.velocity.copy(h).multiplyScalar(-1), e.velocity.z += g * Math.cos(m), e.velocity.y += g * Math.sin(m), e.rotation.x = Math.PI / -2, e.rotation.z = g * e.velocity.x * Math.cos(m), e.velocityDrag.setScalar(r || .98), e.useVelocityDragMult = !0, e.gravity.y = 0, e.position.copy(n), e.duration = TA.randomFloat(s || 500, a || 900), e.scaleFrom.copy(i), e.scaleTo.setScalar(0), e.alpha = .9, e.colorFrom.copy(l || iR).multiplyScalar(d), e.colorTo.copy(e.colorFrom)
		}
	},
	aR = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: sR
	});
const oR = new Map,
	lR = e => e;

function cR(e) {
	return e ? (oR.has(e) || oR.set(e, al(e[0], e[1], e[2], e[3])), oR.get(e)) : lR
}
const uR = Math.PI;
new aw(1, 1, 1);
const hR = new zx,
	dR = new zx,
	pR = new Bb,
	fR = new Bb;
let mR = 0;
var gR = {
		beforeAlloc: function(e) {
			e.amount = Math.min(150 - mR, e.amount), mR += e.amount
		},
		beforeEmit: function(e = {}) {
			e.position || (e.position = hR), e.scale = e.scale || 1, e.angOffset = TA.randomFloat(uR, 0)
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			durationMin: s,
			durationMax: a,
			sprite: o,
			color: l,
			amount: c,
			billboard: u,
			gravity: h = 0
		}) {
			e.spriteId = "particleA", e.fadeIn = 1e3, e.colorEase = cR(), e.progressEase = cR(), e.colorFrom = new aw(0), e.colorTo = new aw(16777215);
			const d = ky(Ny(Ol.game.velocity, 10, 18), 0, 1),
				p = zy(TA.randomFloat(5, 12), TA.randomFloat(2, 4), d),
				f = Ol.game.getRelativeRoadData(p),
				m = TA.randomFloat(f.scale.y / 7, f.scale.y / 2);
			pR.position.copy(f.position), pR.quaternion.copy(f.quaternion), pR.scale.setScalar(m), pR.updateMatrixWorld();
			const g = t,
				v = TA.randomFloat(3, 4),
				_ = v * Math.cos(g),
				y = v * Math.sin(g),
				x = pR.localToWorld(hR.set(0, y, _));
			fR.position.copy(x), fR.up.copy(dR.set(0, 1, 0).applyQuaternion(f.quaternion)), fR.lookAt(pR.position), fR.updateMatrixWorld(), e.initialRoadProgress = Ol.game.progress + p, e.position.copy(fR.position), e.rotation.copy(fR.rotation), e.scale.x = 1 * Ol.game.velocity, e.scale.y = .11
		},
		particleUpdate: function(e, t) {
			e.initialRoadProgress - Ol.game.progress < -3 && (e.killable = !0), e.progress = e.progressEase(ky(e.age / e.fadeIn, 0, 1)), e.color.copy(e.colorFrom).lerp(e.colorTo, e.colorEase(e.progress)).multiplyScalar(Fy(9.5, 15, Ol.game.velocity) * Ol.scene.gameCam.activeInfluence);
			const n = .3 * Ol.scene.gameCam.activeInfluence;
			e.alpha = 1 - n + (1 - Fy(10, 17, Ol.game.velocity))
		},
		particleReleased: function() {
			mR = Math.max(mR - 1, 0)
		}
	},
	vR = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: gR
	});
const _R = 2 * Math.PI,
	yR = new aw(1, 1, 1),
	xR = new zx;
var bR = {
		beforeEmit: function(e = {}) {
			e.position || (e.position = xR), e.scale = e.scale || 1, e.angOffset = TA.randomFloat(0, _R)
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			sprite: s,
			color: a,
			amount: o,
			billboard: l,
			duration: c = 1e3,
			velocity: u = 1,
			opacity: h,
			gravity: d = 0
		}) {
			const p = _R / o,
				f = e.index * p + TA.randomFloat(-.2, .2) + t;
			u += TA.randomFloat(-.05, .1), u *= 1.03, e.delay = TA.randomFloat(0, 20), e.billboard = l || !0, e.angVelocity = 0, e.spriteId = s, e.velocity.x += u * Math.cos(f), e.velocity.y += u * Math.sin(f), e.angle = -f + Math.PI / 16, e.velocityDrag.setScalar(r || .97), e.useVelocityDragMult = !0, e.gravity.y = -.03, e.position.copy(n), e.position.add(xR.copy(e.velocity).multiplyScalar(5.5)), e.duration = c * TA.randomFloat(.8, 1);
			const m = (i = i || 1).x || i,
				g = i.y || i;
			e.scaleFrom.set(m, g), e.scaleTo.setScalar(0), h *= TA.randomFloat(.8, 1.2), e.alpha = .3, e.colorFrom.copy(a || yR).multiplyScalar(h), e.colorTo.copy(e.colorFrom)
		}
	},
	wR = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: bR
	});
const SR = 2 * Math.PI,
	MR = new aw(1, 1, 1),
	TR = new zx,
	CR = SR;
var ER = {
		beforeEmit: function(e = {}) {
			e.position || (e.position = TR), e.scale = e.scale || 1, e.angOffset = .6 * SR
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			sprite: s,
			color: a,
			amount: o,
			billboard: l,
			duration: c,
			velocity: u = 1,
			opacity: h,
			gravity: d = 0
		}) {
			const p = CR / o,
				f = e.index * p + TA.randomFloat(-.2, .2) + t;
			u *= TA.randomFloat(.8, 1.2), e.billboard = l || !0, e.delay = TA.randomFloat(20, 100), e.angVelocity = 0, e.spriteId = s, e.velocity.x += u * Math.cos(f), e.velocity.y += u * Math.sin(f), e.angle = -f + Math.PI / 16, e.velocityDrag.setScalar(r || .98), e.useVelocityDragMult = !0, e.gravity.y = -.2 * TA.randomFloat(.2, 2.5), e.position.copy(n), e.position.add(TR.copy(e.velocity).multiplyScalar(2.5)), e.duration = c * TA.randomFloat(.8, 1);
			const m = (i = i || 1).x || i,
				g = i.y || i;
			e.scaleFrom.set(m, g), e.scaleTo.setScalar(0), e.alpha = .9, e.colorFrom.copy(a || MR).multiplyScalar(h), e.colorTo.copy(e.colorFrom)
		}
	},
	AR = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: ER
	});
const PR = new aw(1, 1, 1),
	LR = new aw(0, 0, 0);
new Bb;
const IR = new zx,
	DR = [0, .815, .145, 1],
	RR = [0, .485, .465, 1];
var kR = {
	particleEmitted: function(e, {
		position: t,
		scale: n,
		sprite: i,
		duration: r,
		rotation: s = 0,
		power: a,
		gravityY: o = 0,
		powerMult: l = 1,
		glowMult: c = 1
	}) {
		e.billboard = !0, e.spriteId = i, e.position.copy(t || IR), e.duration = r || 1e3;
		const u = (n = n || 1).x || n,
			h = n.y || n;
		e.scaleFrom.set(u, h), e.scaleTo.copy(e.scaleFrom).multiplyScalar(1.1), e.gravity.y = o, e.angle = s, e.alphaEase = cR(RR), e.alphaFrom = (1 - (.3 + .7 * a)) * c, e.alphaTo = 1, e.colorEase = cR(DR), e.colorFrom.lerpColors(LR, PR, (.5 + .5 * a) * l), e.colorTo.copy(LR)
	}
};
var NR = Object.freeze({
	__proto__: null,
	[Symbol.toStringTag]: "Module",
	default: kR
});
const OR = new aw(1, 1, 1),
	FR = new aw(0, 0, 0);
new Bb;
const zR = new zx,
	UR = [0, .815, .145, 1],
	BR = [0, .485, .465, 1];
var VR = {
	particleEmitted: function(e, {
		position: t,
		scale: n,
		sprite: i,
		duration: r,
		power: s
	}) {
		e.billboard = !0, e.spriteId = i, e.position.copy(t || zR), e.duration = r || 1e3;
		const a = (n = n || 1).x || n,
			o = n.y || n;
		e.scaleFrom.set(a, o), e.scaleTo.copy(e.scaleFrom).multiplyScalar(1.1), e.alphaEase = cR(BR), e.alphaFrom = 1 - (.3 + .7 * s), e.alphaTo = 1, e.colorEase = cR(UR), e.colorFrom.lerpColors(FR, OR, .5 + .5 * s), e.colorTo.copy(FR)
	}
};
var HR = Object.freeze({
	__proto__: null,
	[Symbol.toStringTag]: "Module",
	default: VR
});
const GR = 2 * Math.PI,
	WR = new aw(1, 1, 1),
	qR = new Bb;
var jR = {
	beforeEmit: function(e = {}) {
		e.position || (e.position = tVec3);
		e.scale = e.scale || 1, e.angOffset = TA.randomFloat(0, GR)
	},
	particleEmitted: function(e, {
		velDrag: t,
		position: n,
		scale: i,
		sprite: r,
		rotate: s,
		durationMin: a,
		durationMax: o
	}) {
		e.billboard = !1, e.duration = TA.randomFloat(a || 100, o || 300), e.rotation.z = s ? Math.PI / 2 : 0, e.angVelocity = 0, e.spriteId = r, e.velocity.x = -.04;
		const l = .006;
		e.velocity.y = TA.randomFloat(.1 * -.006, .0072), e.velocity.z = TA.randomFloat(-.006, l), e.velocityDrag.setScalar(t || .88), e.useVelocityDragMult = !0, e.position.copy(n), e.scaleFrom.set(1 * i, i * TA.randomFloat(7, 12)), e.scaleTo.set(.1 * i, 6 * i), qR.position.setScalar(0), qR.lookAt(e.velocity), qR.rotateX(-Math.PI / 2), e.rotation.copy(qR.rotation), e.alphaFrom = 0, e.alphaTo = 1, e.colorFrom.copy(WR), e.colorTo.copy(WR)
	}
};
var YR = Object.freeze({
	__proto__: null,
	[Symbol.toStringTag]: "Module",
	default: jR
});
const XR = 2 * Math.PI,
	$R = new aw(1, 1, 1),
	ZR = new aw(1, 0, 0),
	KR = new zx;
var JR = {
		beforeEmit: function(e = {}) {
			e.position || (e.position = KR), e.scale = e.scale || 1, e.angOffset = TA.randomFloat(0, XR)
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			sprite: s,
			color: a,
			amount: o,
			billboard: l,
			velocity: c,
			opacity: u
		}) {
			const h = XR / o,
				d = e.index * h + TA.randomFloat(-.2, .2) + t,
				p = TA.randomFloat(.0018, .002);
			e.billboard = l, e.angVelocity = 0, e.spriteId = s, e.velocity.copy(c), e.velocity.x *= -1 * TA.randomFloat(.0075, .015);
			const f = TA.randomFloat(.7, .9);
			e.velocity.z += p * Math.cos(d) * f, e.velocity.y += p * Math.sin(d) * f, e.angle = f * Math.cos(d), e.velocityDrag.setScalar(r || .98), e.useVelocityDragMult = !0, e.gravity.y = TA.randomFloat(-1e-4, 22e-5), e.position.copy(n), e.duration = TA.randomFloat(500, 900), e.scaleFrom.copy(i), e.scaleTo.setScalar(0), e.alpha = .2, e.colorFrom.copy(a || $R).multiplyScalar(u), e.colorTo.copy(ZR)
		}
	},
	QR = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: JR
	});
const ek = 2 * Math.PI,
	tk = new aw(1, 1, 1),
	nk = new zx;
var ik = {
		beforeEmit: function(e = {}) {
			e.position || (e.position = nk), e.scale = e.scale || 1, e.angOffset = TA.randomFloat(0, ek)
		},
		particleEmitted: function(e, {
			angOffset: t,
			position: n,
			scale: i,
			velDrag: r,
			durationMin: s,
			durationMax: a,
			sprite: o,
			color: l,
			amount: c,
			billboard: u,
			velocity: h,
			opacity: d,
			gravity: p = 0
		}) {
			const f = ek / c,
				m = e.index * f + TA.randomFloat(-.2, .2) + t;
			let g = (.01 + TA.randomFloat(-.005, .007)) * i;
			g = .003 * h.x, e.billboard = u, e.angVelocity = 0, e.spriteId = o, e.velocity.copy(h).multiplyScalar(-1), e.velocity.z += g * Math.cos(m), e.velocity.y += g * Math.sin(m), e.rotation.x = Math.PI / -2, e.rotation.z = g * e.velocity.x * Math.cos(m), e.velocityDrag.setScalar(r || .98), e.useVelocityDragMult = !0, e.gravity.y = 0, e.position.copy(n), e.duration = TA.randomFloat(s || 500, a || 900), e.scaleFrom.copy(i), e.scaleTo.setScalar(0), e.alpha = .9, e.colorFrom.copy(l || tk).multiplyScalar(d), e.colorTo.copy(e.colorFrom)
		}
	},
	rk = Object.freeze({
		__proto__: null,
		[Symbol.toStringTag]: "Module",
		default: ik
	});
const sk = new Fx,
	ak = 1 / Number.MAX_SAFE_INTEGER,
	ok = {};
let lk;
new Bb;
class ck extends fP {
	constructor(e) {
		e.useEuler = !0, super(e), lk || (lk = Nl()), this.batcher && this.batcher.removeInstance(this), this.spriteId = null, this.spriteFrame = 0, this.spriteFrameDuration = 50, this.spriteLoop = !1, this.spriteAutoplay = !1, this.rotation = new Tb, this.delay = 0, this.duration = 0, this.age = 0, this.progress = 0, this.onProgress = null, this.onComplete = null, this.onEnd = null, this.angVelocity = 0, this.angVelocityDrag = 0, this.velocity = new zx, this.velocityDrag = new zx, this.velocityDragMult = new zx, this.useVelocityDragMult = !1, this.scaleWithVel = !1, this.gravity = new zx, this.scaleFrom = new Cx, this.scaleTo = new Cx, this.colorFrom = new aw, this.colorTo = new aw, this.alphaFrom = 1, this.alphaTo = 1, this.alive = !1, this.killable = !1, this.progressEase = cR(), this.scaleEase = cR(), this.alphaEase = cR(), this.colorEase = cR(), this.scaleVelEase = cR([0, 1, .5, 1])
	}
	reset() {
		this.alive && this.onRelease && this.onRelease(), this.preset && this.preset.particleReleased && this.preset.particleReleased(this, this.presetOptions), this.parent = null, this.preset = ok, this.spriteId = null, this.spriteFrame = 0, this.spriteFrameDuration = 50, this.spriteLoop = !1, this.spriteAutoplay = !1, this.billboard = !1, this.angle = 0, this.quaternion.copy(sk), this.rotation.set(0, 0, 0), this.position.setScalar(0), this.scale.setScalar(1), this.delay = 0, this.duration = 1e3, this.age = 0, this.progress = 0, this.onProgress = null, this.onComplete = null, this.onRelease = null, this.angVelocity = 0, this.angVelocityDrag = 0, this.velocity.setScalar(0), this.velocityDrag.setScalar(0), this.useVelocityDragMult = !1, this.scaleWithVel = !1, this.gravity.setScalar(0), this.scaleFrom.setScalar(1), this.scaleTo.setScalar(1), this.colorFrom.setRGB(255, 255, 255), this.colorTo.setRGB(255, 255, 255), this.alphaFrom = 1, this.alphaTo = 1, this.progressEase = cR(), this.scaleEase = cR(), this.alphaEase = cR(), this.colorEase = cR(), this.scaleVelEase = cR([.7, .3, .2, .2])
	}
	emit(e, t, n, i) {
		this.reset(), this.batcher = e, this.spriteId = this.killable = !1, this.alive = !0, this.index = i, this.billboard = n.billboard || !1, this.parent = n.parent, this.preset = t || ok, this.presetOptions = n || ok, this.preset.particleEmitted && this.preset.particleEmitted(this, this.presetOptions), this.sprite.setAtlas(this.batcher.atlas), this.sprite.change({
			id: this.spriteId,
			frame: this.spriteFrame,
			frameDuration: this.spriteFrameDuration,
			loop: this.spriteLoop,
			autoplay: this.spriteAutoplay
		}), this.batcher.addInstance(this), this.sprite.update(1), this.update(0)
	}
	kill() {
		this.killable && this.preset.particleKilled && this.preset.particleKilled(this, this.presetOptions), this.killable && this.onComplete && this.onComplete(), this.batcher && (this.batcher.removeInstance(this), this.batcher = null), this.reset(), this.progress = 1, this.alive = !1, this.killable = !1
	}
	update() {
		if (!this.alive || this.killable) return;
		if (this.progress >= 1) return this.killable = !0;
		let e = lk.time.stableDt;
		if (this.delay > 0) {
			if (this.delay -= e, this.delay > 0) return this.alpha = 0, void this.scale.setScalar(ak);
			e = Math.max(0, e + this.delay)
		}
		super.update(e);
		const t = Math.max(Math.min(e / 16.666666667, 1.5), .5);
		if (this.age += e, this.progress = this.progressEase(ky(this.age / this.duration, 0, 1)), this.preset.particleUpdate) this.preset.particleUpdate(this, this.presetOptions);
		else {
			if (this.useVelocityDragMult) this.velocity.multiply(this.velocityDrag), this.velocity.lengthSq < 1e-4 && this.velocity.setScalar(0);
			else {
				if (this.velocity.x) {
					const e = Math.sign(this.velocity.x);
					this.velocity.x -= e * this.velocityDrag.x * t, Math.sign(this.velocity.x) !== e && (this.velocity.x = 0)
				}
				if (this.velocity.y) {
					const e = Math.sign(this.velocity.y);
					this.velocity.y -= e * this.velocityDrag.y * t, Math.sign(this.velocity.y) !== e && (this.velocity.y = 0)
				}
				if (this.velocity.z) {
					const e = Math.sign(this.velocity.z);
					this.velocity.z -= e * this.velocityDrag.z * t, Math.sign(this.velocity.z) !== e && (this.velocity.z = 0)
				}
			}
			if (this.angVelocity) {
				const e = Math.sign(this.angVelocity);
				this.angVelocity -= e * this.angVelocityDrag * t, Math.sign(this.angVelocity) !== e && (this.angVelocity = 0)
			}
			this.position.x += (this.velocity.x + this.gravity.x) * t, this.position.y += (this.velocity.y + this.gravity.y) * t, this.position.z += (this.velocity.z + this.gravity.z) * t, this.billboard ? this.angle += this.angVelocity * t : this.rotation.z += this.angVelocity * t, this.scaleWithVel ? this.scale.copy(this.scaleFrom).lerp(this.scaleTo, this.scaleVelEase(this.progress)) : this.scale.copy(this.scaleFrom).lerp(this.scaleTo, this.scaleEase(this.progress)), this.color.copy(this.colorFrom).lerp(this.colorTo, this.colorEase(this.progress)), this.alpha = zy(this.alphaFrom, this.alphaTo, this.alphaEase(this.progress))
		}
		this.preset.particleUpdated && this.preset.particleUpdated(this, this.presetOptions), this.onProgress && this.onProgress(this, this.progress)
	}
}
const uk = {};
class hk extends xA {
	constructor(e) {
		super(e), e.batcher && (e.batchers = [e.batcher]), this.count = e.count || 150, this.dead = new Array(this.count).fill(0).map((() => new ck({}))), this.alive = [], this.batchers = e.batchers || []
	}
	emit(e, t = {}, n) {
		"number" == typeof t && (t = {
			amount: t
		});
		const i = t.amount = t.amount || 1,
			r = uk[e];
		if (!r) return;
		if (r.beforeAlloc && r.beforeAlloc(t), t.amount <= 0) return;
		const s = this.batchers[n] || this.batchers[0],
			a = this.alloc(i);
		r.beforeEmit && r.beforeEmit(t, a);
		for (let o = a.length - 1; o >= 0; o--) a[o].alive || 0, this.alive.push(a[o]), a[o].emit(s, r, t, o)
	}
	update(e) {
		const t = [];
		for (let n = this.alive.length - 1; n >= 0; n--) {
			const i = this.alive[n];
			i.update(e), i.killable && (t.push(i), this.alive.splice(n, 1), this.dead.push(i))
		}
		for (let n = t.length - 1; n >= 0; n--) t[n].kill()
	}
	alloc(e) {
		const t = this.dead,
			n = this.alive;
		let i = [],
			r = e;
		return t.length > 0 && (i = t.splice(0, r)), r -= i.length, r > 0 && (i = i.concat(n.splice(0, r))), i
	}
	killAll() {
		for (let e = this.alive.length - 1; e >= 0; e--) this.alive[e].kill(), this.dead.push(this.alive[e]), this.alive.splice(e, 1)
	}
	registerPreset(e, t) {
		! function(e, t) {
			t || (t = {}), uk[e] = t
		}(e, t)
	}
}
let dk = 0;
const pk = new oS,
	fk = new Map,
	mk = new Bb,
	gk = new Fx,
	vk = {
		default: 1,
		additive: 2
	},
	_k = {
		double: 2,
		front: 0,
		back: 1
	};
var yk = class extends ZA {
		init(e) {
			this.needsUpdate = !0, this.atlas = e.atlas, this.count = e.count || 200, this.geo = new UE, this.geo.index = pk.index, this.geo.attributes.position = pk.attributes.position, this.geo.attributes.uv = pk.attributes.uv, this.initAttributes(), this.layers = [], this.layersHashmap = {}, this.instances = new Set, this.setDynamic(e.dynamic);
			const t = this.getMaterial(e);
			this.base = new Bw(this.geo, t), this.base.renderOrder = e.renderOrder, this.base.frustumCulled = !!e.frustumCulled, this.currentCount = 0, this.updateAttributes = this.updateAttributes.bind(this)
		}
		setDynamic(e) {
			this.dynamic = null == e || !!e, this.interleavedBuffer.setUsage(this.dynamic ? 35048 : StaticDrawUsage), this.interleavedBuffer.needsUpdate = !0, this.needsUpdate = !0
		}
		getMaterial(e) {
			const t = e.material;
			if (!t) return;
			fk.has(t) || fk.set(t, {});
			const n = fk.get(t),
				i = e.atlas;
			if (!i) return;
			null == i.meta.atlasIndex && (i.meta.atlasIndex = ++dk);
			const r = null == e.depthWrite || e.depthWrite,
				s = null == e.depthTest || e.depthTest,
				a = null != e.blending ? e.blending : "default",
				c = null != e.transparent && e.transparent,
				u = null != e.alphaTest && e.alphaTest,
				h = null != e.side ? e.side : "front",
				d = [i.meta.atlasIndex, h + "", r.toString(), s.toString(), a.toString(), c.toString(), u.toString()].join("_");
			if (n[d]) return n[d];
			const p = o({}, e);
			return delete p.material, n[d] = new t(l(o({}, p), {
				atlas: i,
				side: _k[h],
				blending: "function" == typeof a ? a : vk[a],
				depthWrite: !!r,
				depthTest: !!s,
				transparent: !!c,
				alphaTest: !!u
			}))
		}
		initAttributes() {
			this.stride = 20, this.buffer = new Float32Array(this.count * this.stride);
			const e = this.geo,
				t = this.interleavedBuffer = new ZE(this.buffer, this.stride);
			e.setAttribute("texCoords", new ZT(t, 4, 0, !1)), e.setAttribute("meshCoords", new ZT(t, 4, 4, !1)), e.setAttribute("spritePos", new ZT(t, 3, 8, !1)), e.setAttribute("billboard", new ZT(t, 1, 11, !1)), e.setAttribute("spriteQt", new ZT(t, 4, 12, !1)), e.setAttribute("spriteColor", new ZT(t, 4, 16, !1)), t.needsUpdate = !0
		}
		updateAttributes(e) {
			if (!e || !e.visible) return;
			const t = this.currentCount++,
				n = this.buffer,
				i = this.stride,
				r = e.sprite.frame;
			let s = t * i;
			e.useEuler && e.quaternion.setFromEuler(e.rotation);
			let a = e.position,
				o = e.quaternion,
				l = e.scale;
			if (e.parent) {
				const t = e.parent;
				mk.position.copy(a), mk.quaternion.copy(e.billboard ? gk : o), mk.scale.set(l.x, l.y, 1), mk.applyMatrix4(t.matrixWorld), mk.updateMatrixWorld(), a = mk.position, o = mk.quaternion, l = mk.scale
			}
			const c = e.billboard ? e.angle : o.x;
			n[s++] = r.texCoords[0], n[s++] = r.texCoords[1], n[s++] = r.texCoords[2], n[s++] = r.texCoords[3], n[s++] = r.meshCoords[0] * e.scale.x, n[s++] = r.meshCoords[1] * e.scale.y, n[s++] = r.meshCoords[2] * e.scale.x, n[s++] = r.meshCoords[3] * e.scale.y, n[s++] = a.x, n[s++] = a.y, n[s++] = a.z, n[s++] = e.billboard ? 1 : 0, n[s++] = c, n[s++] = o.y, n[s++] = o.z, n[s++] = o.w, n[s++] = e.color.r, n[s++] = e.color.g, n[s++] = e.color.b, n[s++] = e.alpha
		}
		addInstance(e) {
			this.instances.has(e) || this.instances.add(e)
		}
		removeInstance(e) {
			this.instances.has(e) && this.instances.delete(e)
		}
		update() {
			this.dynamic && (this.currentCount = 0, this.instances.forEach(this.updateAttributes), this.geo.instanceCount = this.currentCount, this.interleavedBuffer.needsUpdate = !0)
		}
		clearInstances() {
			this.instances.clear()
		}
		destroy() {
			this.clearInstances(), this.geo.dispose(), super.destroy()
		}
	},
	xk = fA("precision highp float;attribute vec4 texCoords;attribute vec4 meshCoords;attribute vec3 spritePos;attribute vec4 spriteQt;attribute vec4 spriteColor;attribute float billboard;varying vec2 vUv;varying vec4 vColor;\n#include <get_instance_matrix>\nvoid main(){vColor=spriteColor;vUv=uv*texCoords.zw+texCoords.xy;vUv.y=1.-vUv.y;vec3 transformed=position;transformed.xy=transformed.xy*meshCoords.zw+(meshCoords.xy*0.5);transformed.xy+=meshCoords.xy*0.5;mat4 instanceMatrix=getInstanceMatrix(spritePos,spriteQt,vec3(1.));vec4 mvPosition=modelViewMatrix*instanceMatrix*vec4(transformed,1.);vec4 bbPosition=modelViewMatrix*instanceMatrix*vec4(0.0,0.0,0.0,1.0);bbPosition.x+=cos(spriteQt.x)*transformed.x-sin(spriteQt.x)*transformed.y;bbPosition.y+=sin(spriteQt.x)*transformed.x+cos(spriteQt.x)*transformed.y;mvPosition=mix(mvPosition,bbPosition,billboard);gl_Position=projectionMatrix*mvPosition;}", "precision highp float;uniform sampler2D atlas;varying vec2 vUv;varying vec4 vColor;void main(){vec2 uv=vUv;vec3 color=texture2D(atlas,uv).rgb;float alpha=1.-(color.r*(1.-vColor.a));gl_FragColor=vec4(vColor.rgb*color,alpha);}");
class bk extends jw {
	constructor(e = {}) {
		const t = e.atlas;
		delete e.atlas, delete e.renderOrder;
		const n = "function" == typeof e.blending && e.blending;
		n && delete e.blending, super(e), this.uniforms = l(o({}, e.uniforms || {}), {
			atlas: {
				value: t.texture,
				type: "t"
			}
		}), n && n(this), e.vertexShader || e.fragmentShader || xk.use(this)
	}
}
const wk = {
		"/webgl/particlePresets/burst.js": aR,
		"/webgl/particlePresets/dashline.js": vR,
		"/webgl/particlePresets/fireworksBurst.js": wR,
		"/webgl/particlePresets/fireworksBurstFall.js": AR,
		"/webgl/particlePresets/fireworksFlash.js": NR,
		"/webgl/particlePresets/flash.js": HR,
		"/webgl/particlePresets/hitSparkles.js": YR,
		"/webgl/particlePresets/line.js": QR,
		"/webgl/particlePresets/smoke.js": rk
	},
	Sk = Object.entries(wk).map((([e, t]) => ({
		id: e.split("/").pop().split(".js").shift(),
		module: t.default
	})));

function Mk(e) {
	const t = {
		init: function(t) {
			const a = {
				renderOrder: e.store.renderOrder.sprites,
				material: bk,
				atlas: e.atlas,
				blending: GP,
				depthWrite: !1,
				depthTest: !1
			};
			n = new yk(o({}, a)), i = new yk(l(o({}, a), {
				depthTest: !0
			})), t.add(n.base), t.add(i.base);
			r = new hk({
				batchers: [n, i]
			}), Sk.forEach((e => r.registerPreset(e.id, e.module))), e.game.hooks.reset.watch(s)
		},
		emit: function(e, t = {}) {
			if (!r) return;
			const n = t.depthTest ? 1 : 0;
			return r.emit(e, t, n)
		},
		update: function() {
			if (e.game.isPaused()) return;
			n.update(), i.update(), r.update()
		},
		get batcher() {
			return n
		},
		get batcherDepth() {
			return i
		}
	};
	let n, i, r;

	function s() {
		r.killAll()
	}
	e.particles = e.game.particles = t
}

function Tk() {}
const Ck = {},
	Ek = {};

function Ak(e) {
	try {
		return e.stop(), !1
	} catch (t) {
		return !0
	}
}

function Pk(e) {
	return Ck[e] || (Ck[e] = new Promise((t => {
		const n = new XMLHttpRequest;
		n.open("GET", e, !0), n.responseType = "arraybuffer", n.onload = () => t(n.response), n.send()
	}))), Ck[e]
}

function Lk(e, t) {
	return e ? (Ek[t] || (Ek[t] = new Promise((n => {
		Pk(t).then((t => {
			e.decodeAudioData(t, (e => n(e)))
		}))
	}))), Ek[t]) : Pk(t)
}
class Ik {
	constructor(e) {
		this.onEnded = this.onEnded.bind(this), this.onLoaded = this.onLoaded.bind(this), this.controller = e, this.context = e.getContext(), this.input = null, this.output = this.context.createGain()
	}
	reset(e = {}) {
		this.onStop = null, this.stop(), this.pausedProgress = 0, this.fadein = e.fadein || 0, this.fadeout = e.fadeout || 0, this.fadeinTimer = 0, this.fadeoutTimer = 0, this.fadeinActive = !1, this.fadeoutActive = !1, this.needsPlay = !1, this.isPlaying = !1, this.isStopping = !1, this.hasEnded = !1, this.loaded = !1, this.stopped = !1, this.id = e.id || null, this.source = null, this.buffer = null, this.loop = !!e.loop, this.autoplay = !!e.autoplay, this.playbackRate = e.playbackRate || 1, this.volume = e.volume || 1, this.realvolume = -1, this.loopStart = e.loopStart || 0, this.loopEnd = e.loopEnd || 0, this.onStop = e.onStop || Tk, this.baseOffset = e.start || e.baseOffset || 0, this.duration = e.duration;
		const t = e.input || this.controller.getInput();
		t !== this.input && (this.input && this.output.disconnect(this.input), this.input = t, this.output.connect(this.input)), Lk(this.context, e.path).then(this.onLoaded), this.autoplay && this.play()
	}
	onLoaded(e) {
		this.isStopping || this.stopped || this.stopped || (this.loaded = !0, this.buffer = e, this.needsPlay && this.play())
	}
	onEnded() {
		this.loop || (this.hasEnded = !0, this.stop())
	}
	getOutput() {
		return this.output
	}
	update(e) {
		if (!this.source) return;
		let t = this.volume;
		if (this.fadeinActive) {
			this.fadeinTimer += e;
			const n = ky(this.fadeinTimer / this.fadein, 0, 1);
			t *= n, 1 === n && (this.fadeinActive = !1)
		}
		if (this.fadeoutActive) {
			this.fadeoutTimer += e;
			const n = ky(1 - this.fadeoutTimer / this.fadeout, 0, 1);
			t *= n, 0 === n && this.realstop()
		}
		t !== this.realvolume && this.setVolume(t)
	}
	play() {
		if (this.source && this.stop(), !this.loaded) return void(this.needsPlay = !0);
		const e = this.source = this.context.createBufferSource();
		if (e.buffer = this.buffer, e.onended = this.onEnded, this.startTime = this.context.currentTime, this.isPlaying = !0, this.needsPlay = !1, !e || !e.buffer) return this.stop();
		this.progressStart = this.startTime - this.offset, this.duration || (this.duration = e.buffer.duration);
		const t = Math.max(this.duration - this.offset, .01),
			n = function(e, t, n, i) {
				try {
					return e.start(t, n, i), !1
				} catch (r) {
					return !0
				}
			}(this.source, this.startTime, (this.baseOffset + this.offset) % e.buffer.duration, this.duration ? t : void 0);
		n ? requestAnimationFrame((() => this.stop())) : (this.fadein && 0 === this.fadeinTimer ? this.setVolume(0, !0) : this.setVolume(this.volume, !0), this.fadein && (this.fadeinActive = !0), this.setPlaybackRate(this.playbackRate), this.connect(), this.setLoop(this.loop))
	}
	getCurrentTime() {
		return this.getProgress() * this.duration
	}
	getProgress() {
		return this.isPlaying ? (this.context.currentTime - this.progressStart) / this.duration : this.pausedProgress
	}
	connect() {
		this.source.connect(this.output)
	}
	disconnect() {
		this.source.disconnect(this.output)
	}
	pause() {
		this.pausedProgress = this.getProgress(), this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.needsPlay = !1, this.isPlaying = !1, this.source && (Ak(this.source), this.source.onended = null, this.source = null)
	}
	realstop() {
		this.onStop && this.onStop(this), this.onStop = null, this.offset = 0, this.needsPlay = !1, this.isPlaying = !1, this.isStopping = !1, this.fadeinActive = !1, this.fadeoutActive = !1, this.stopped = !0, this.source && (Ak(this.source), this.source.onended = null, this.source = null)
	}
	stop(e = {}) {
		this.isStopping || (this.isStopping = !0, e.fadeout && (this.fadeout = e.fadeout), this.fadeout ? this.fadeoutActive = !0 : this.realstop())
	}
	getPlaybackRate() {
		return this.playbackRate
	}
	setPlaybackRate(e) {
		this.playbackRate = e, this.isPlaying && this.source && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01)
	}
	getLoop() {
		return this.loop
	}
	setLoop(e) {
		this.loop = e, this.isPlaying && this.source && (this.source.loop = this.loop, this.source.loopStart = this.loopStart, this.source.loopEnd = this.loopEnd)
	}
	getVolume() {
		return this.output.gain.value
	}
	setVolume(e, t, n = .01) {
		this.realvolume = e, t && (this.output.gain.value = this.realvolume), this.output.gain.setTargetAtTime(this.realvolume, this.context.currentTime, n)
	}
	release() {
		Ik.release(this)
	}
}
Ik.pool = [], Ik.get = function(e, t) {
	const n = Ik.pool.pop() || new Ik(e);
	return n.reset(t), n
}, Ik.release = function(e) {
	e.buffer = null, e.onStop = null, Ik.pool.length < 50 && Ik.pool.push(e)
};
const Dk = window.performance || window.Date,
	Rk = ["click", "touchend", "keydown"],
	kk = window.AudioContext || window.webkitAudioContext;
let Nk = null,
	Ok = null,
	Fk = null,
	zk = !1;
const Uk = {
		initialized: !1,
		unlocked: !1,
		unlockerListening: !0,
		lastStuckCheck: Dk.now(),
		stuckTimer: 0,
		previousWebAudioTime: 0
	},
	Bk = {
		onContextCreation: null,
		onUnlock: null,
		onStuck: null
	};

function Vk(e) {
	const t = e.createBufferSource();
	t.buffer = e.createBuffer(1, 1, 44100), t.connect(e.destination), t.start(0), t.disconnect()
}

function Hk() {
	Uk.unlocked || (! function() {
		if (Fk) return;
		Fk = function() {
			try {
				const e = new kk;
				return Vk(e), e.close(), new kk
			} catch (e) {
				return null
			}
		}(), Uk.initialized = !0, Bk.onContextCreation && Bk.onContextCreation(Fk);
		qk()
	}(), Fk.suspend(), window.setTimeout((() => Fk.resume()), 10), Vk(Fk), Gk(), function() {
		Uk.unlockerListening = !1;
		for (const e of Rk) document.removeEventListener(e, Hk, {
			passive: !0
		})
	}(), Uk.unlocked = !0, Uk.stuckTimer = -800, Uk.lastStuckCheck = Dk.now(), Bk.onUnlock && Bk.onUnlock())
}

function Gk(e = !1) {
	return new Promise((e => {
		Ok || (Ok = document.createElement("audio"), Ok.setAttribute("x-webkit-airplay", "deny"), Ok.preload = "auto", Ok.loop = !1, Ok.src = Nk, Ok.load()), Ok.pause(), Ok.currentTime = 0;
		try {
			Promise.resolve().then((() => Ok.play())).then((() => e(!0))).catch((t => {
				e(!1)
			}))
		} catch (t) {
			e(!1)
		}
	}))
}

function Wk() {
	Uk.unlocked = !1, Uk.unlockerListening = !0;
	for (const e of Rk) document.addEventListener(e, Hk, {
		passive: !0
	})
}

function qk() {
	window.requestAnimationFrame(qk);
	const e = Dk.now(),
		t = e - Uk.lastStuckCheck;
	if (!Uk.initialized || !Fk || t < 400) return;
	const n = Fk.currentTime,
		i = n === Uk.previousWebAudioTime;
	Uk.stuckTimer = i ? Uk.stuckTimer + t : 0, Uk.previousWebAudioTime = n, Uk.lastStuckCheck = e, Uk.stuckTimer > 400 && Uk.unlocked && !Uk.unlockerListening && (Wk(), Bk.onStuck && Bk.onStuck())
}
var jk = {
	init: function() {
		Uk.initialized || (Nk = function(e) {
			const t = new ArrayBuffer(10),
				n = new DataView(t);
			return n.setUint32(0, e, !0), n.setUint32(4, e, !0), n.setUint16(8, 1, !0), `data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAEA${window.btoa(String.fromCharCode(...new Uint8Array(t))).slice(0,13)}AgAZGF0YQcAAACAgICAgICAAAA=`
		}(44100), Wk(), async function() {
			await Gk(!0) && Hk()
		}())
	},
	getVolume: function(e) {
		return e.gain.value
	},
	setVolume: function(e, t) {
		e.gain.setTargetAtTime(t, Fk.currentTime, .01)
	},
	getContext: () => Fk,
	isUnlocked: () => Uk.unlocked,
	set debug(e) {
		zk = e
	},
	set onContextCreation(e) {
		Bk.onContextCreation = e
	},
	set onUnlock(e) {
		Bk.onUnlock = e
	},
	set onStuck(e) {
		Bk.onStuck = e
	}
};
const Yk = {};
JSON.parse('[["Boost_Line_Loop",0,16,16],["Button",16.25,16.5,0.25],["Car_Engine_Boost",16.75,22.3809,5.6309],["Car_Engine_Loop_AirFlow",22.6309,27.1309,4.5],["Car_Engine_Loop_High",27.3809,31.8809,4.5],["Car_Engine_Loop_Low",32.1309,36.6309,4.5],["Car_Engine_Loop_Mid",36.8809,41.3809,4.5],["Car_Friction_Loop",41.6309,45.1375,3.5066],["Car_Impact",[[45.3875,46.2837,0.8962],[46.5337,47.43,0.8962],[47.68,48.5762,0.8962],[48.8262,49.7224,0.8962],[49.9724,50.8686,0.8962]]],["FireworksEnd",[[51.1186,52.7831,1.6645],[53.0331,55.007,1.9739],[55.257,57.0637,1.8067],[57.3137,59.0446,1.7309],[59.2946,60.9627,1.6681]]],["UI_Countdown_GO",61.2127,64.3783,3.1656],["UI_Countdown_One",64.6283,67.316,2.6877],["UI_Countdown_Three",67.566,70.1448,2.5788],["UI_Countdown_Two",70.3948,73.1069,2.7121],["UI_Finish",73.3569,76.5225,3.1656],["UI_Hover_Tiny",76.7725,76.8764,0.1039],["UI_Pause",77.1264,78.9815,1.8551],["UI_QRCode",79.2315,81.5343,2.3028],["UI_ResulTime",81.7843,84.4429,2.6585],["UI_Title_TheRace",84.6929,87.5254,2.8326],["UI_Validate_Big",87.7754,89.8833,2.1079],["UI_Validate_Small",90.1333,91.8986,1.7654]]').forEach((([e, t, n, i]) => {
	Yk[e] = Array.isArray(t) ? {
		id: e,
		path: "./assets/audiosprites.5ae006ed798ddcc2.m4a",
		variations: t.map((t => ({
			id: e,
			start: t[0],
			end: t[1],
			duration: t[2]
		})))
	} : {
		id: e,
		path: "./assets/audiosprites.5ae006ed798ddcc2.m4a",
		start: t,
		end: n,
		duration: i
	}
})), Yk.Music_Layer1_SoftBeat = {
	path: "./assets/Music_Layer1_SoftBeat.d230ffac798ddcc2.m4a",
	unique: !0
}, Yk.Music_Layer2_Pad = {
	path: "./assets/Music_Layer2_Pad.97e61a1b798ddcc2.m4a",
	unique: !0
}, Yk.Music_Layer3_Drum = {
	path: "./assets/Music_Layer3_Drum.c70889f1798ddcc2.m4a",
	unique: !0
}, Yk.Music_Layer4_BassSnare = {
	path: "./assets/Music_Layer4_BassSnare.0c2dc411798ddcc2.m4a",
	unique: !0
};
var Xk = Yk;
const $k = .05 * Math.log(10);
const Zk = e => {
		return t = e + 0, Math.exp(t * $k);
		var t
	},
	Kk = (e, t) => Object.assign(Xk[e], t);
Kk("Music_Layer1_SoftBeat", {
	volume: Zk(0),
	fadein: 5e3,
	loop: !0
}), Kk("Music_Layer2_Pad", {
	volume: Zk(0),
	fadein: 5e3,
	loop: !0
}), Kk("Music_Layer3_Drum", {
	volume: Zk(0),
	fadein: 5e3,
	loop: !0
}), Kk("Music_Layer4_BassSnare", {
	volume: Zk(0),
	fadein: 5e3,
	loop: !0
});
Kk("Car_Engine_Loop_Low", {
	fadein: 1e3,
	loop: !0
}), Kk("Car_Engine_Loop_Mid", {
	fadein: 1e3,
	loop: !0
}), Kk("Car_Engine_Loop_High", {
	fadein: 1e3,
	loop: !0
}), Kk("Car_Engine_Loop_AirFlow", {
	fadein: 1e3,
	loop: !0
}), Kk("Car_Friction_Loop", {
	loop: !0,
	fadein: 300,
	fadeout: 300
}), Kk("Boost_Line_Loop", {
	loop: !0
}), Kk("UI_Hover_Tiny", {
	randomRate: [.9, 1.1],
	volume: .75
}), Kk("UI_Validate_Big", {
	volume: .7
}), Kk("UI_Validate_Small", {
	volume: .7
}), Kk("Button", {
	randomRate: [.1, 2],
	volume: .8
});
const Jk = [{
		id: "Music_Layer1_SoftBeat",
		type: "softbeat"
	}, {
		id: "Music_Layer2_Pad",
		type: "pad"
	}, {
		id: "Music_Layer3_Drum",
		type: "drum"
	}, {
		id: "Music_Layer4_BassSnare",
		type: "snareGuitar"
	}],
	Qk = {
		nothing: [],
		pad: ["pad"],
		"pad+drum": ["pad", "drum"],
		"pad+guitar": ["pad", "snareGuitar"],
		"pad+drum+guitar": ["pad", "drum", "snareGuitar"],
		"pad+drum+softbeat": ["pad", "drum", "softbeat"],
		"pad+guitar+softbeat": ["pad", "snareGuitar", "softbeat"],
		all: ["softbeat", "pad", "drum", "snareGuitar"],
		intro: ["softbeat", "pad"],
		outro: ["pad", "drum"]
	};
const eN = cR([.345, .005, .635, 1]),
	tN = () => 0,
	nN = () => 1,
	iN = e => eN(e),
	rN = e => 1 - eN(e),
	sN = cR([.57, .06, .925, .595]),
	aN = e => e,
	oN = cR([.555, .03, 1, .81]),
	lN = cR([0, .705, .49, .995]),
	cN = cR([0, .705, .49, .995]),
	uN = [{
		id: "Car_Engine_Loop_Low",
		pitchFrom: .5,
		pitchTo: 2,
		before: rN,
		middle: .6,
		after: tN,
		gain: .63
	}, {
		id: "Car_Engine_Loop_Mid",
		pitchFrom: .5,
		pitchTo: 2,
		before: iN,
		middle: .5,
		after: rN,
		gain: .63 * .95
	}, {
		id: "Car_Engine_Loop_High",
		pitchFrom: .5,
		pitchTo: 2,
		before: tN,
		middle: .3,
		after: iN,
		gain: .63 * .9
	}, {
		id: "Car_Engine_Loop_AirFlow",
		pitchFrom: 1,
		pitchTo: 3,
		before: nN,
		middle: .5,
		after: nN,
		gain: 1.2
	}],
	hN = cR([0, .745, .195, .995]),
	dN = cR([.735, .02, 1, .295]),
	pN = [4, 5.2, 6.5, 7.7, 8.3, 9.4],
	fN = ["INACTIVE", "DECREASE", "INCREASE", "COOLDOWN"].reduce(((e, t, n) => (e[t] = n, e)), {});

function mN(e, t) {
	const n = e.game;
	let i = !1,
		r = 0,
		s = 0,
		a = 0,
		o = 1,
		l = 1,
		c = 0,
		u = fN.INACTIVE,
		h = 0,
		d = 1,
		p = 1;
	return {
		onUnlock: async function() {
			const n = [];
			for (const e of uN) n.push(t.preloadSound(e.id));
			await Promise.all(n);
			for (const e of uN) t.stopSound(e.id), e.instance = t.playSound(e.id);
			i || (e.hooks.afterUpdate.watch(m), i = !0)
		}
	};

	function f(e, t) {
		null != t && (d = p = t), h = 0, u = e
	}

	function m() {
		! function() {
			if (e.game.paused.value) return;
			const t = e.time.stableDt,
				i = n.velocity;
			if (h += t, e.game.turbo.active.value) f(fN.INACTIVE, 1);
			else switch (u) {
				case fN.INACTIVE:
					for (let e = 0; e < pN.length; e++) {
						const t = pN[e];
						if (c < t && i >= t) {
							c = t, f(fN.DECREASE, 1);
							break
						}
						i <= t && c >= t && (c = t)
					}
					break;
				case fN.DECREASE:
					d = By(d, 0, .6, t), p = Oy(hN(d), 0, 1, .55, 1), d < 1e-4 && f(fN.INCREASE);
					break;
				case fN.INCREASE:
					d = By(d, 1, .1, t), p = Oy(dN(d), 0, 1, .55, 1), d > .999 && f(fN.COOLDOWN, 1);
					break;
				case fN.COOLDOWN:
					h > 150 && f(fN.INACTIVE, 1)
			}
		}();
		const t = e.time.stableDt,
			i = n.velocity;
		o = zy(o, 1 - e.game.paused.value, .1);
		const m = .25 * n.minVelocity,
			g = ky(Ny(i, m, n.maxVelocity), 0, 1),
			v = aN(ky(Ny(i, 0, m), 0, 1));
		let _ = sN(g) * p;
		const y = zy(1, .8, oN(ky(Ny(_, .6, 1), 0, 1))),
			x = e.scene.currentCamera,
			b = e.scene.road.pointer,
			w = x.base.position.distanceTo(b.base.position),
			S = x.isGameCamera && x.activeInfluence < .9999,
			M = +(x.isIdleCamera || 1 - (x.activeInfluence || 0));
		const T = zy(1, 1.15 * (1 - lN(ky(Ny(w, .3, 15), 0, 1))), M);
		let C = (e => 1 - cN(ky(Ny(e, 0, 20), 0, 1)))(w);
		x.carTowardsCam && (C = 1 - C);
		let E = null != x.engineMult ? x.engineMult : 1;
		S && (E = 1.2);
		const A = zy(.8 * _ * E, _ * E, C);
		_ = zy(_, A, M);
		const P = e.game.turbo.active.value;
		l = zy(l, P ? 1.2 : 1, P ? .1 : .07), _ *= l, a = 1 * Math.abs(e.controls.turn - r) + .1 * Math.abs(e.controls.turn), s = By(s, a, .1, t), r = e.controls.turn, _ *= 1 - s;
		for (let e = 0; e < uN.length; e++) {
			const t = uN[e],
				n = zy(t.pitchFrom, t.pitchTo, _);
			t.rate = n;
			const i = _ > t.middle,
				r = i ? t.middle : 0,
				s = i ? 1 : t.middle,
				a = (i ? t.after : t.before)(Ny(_, r, s));
			t.volume = a * v * y * t.gain * T * o, t.instance && (t.instance.volume = t.volume, t.instance.setPlaybackRate(t.rate))
		}
	}
}
const gN = (e, t) => void 0 !== e ? e : t;

function vN(e) {
	const t = ef(!1);
	let n, i, r, s = !1,
		a = !1;
	const o = e => e.update(r),
		l = {},
		c = new Set;
	let u = 1;
	const h = {
			main: 1,
			fade: 1,
			mute: 1
		},
		d = {
			muted: t,
			init: function() {
				if (s) return;
				s = !0, jk.debug = !0, jk.onUnlock = _, jk.onContextCreation = g, jk.onStuck = v, jk.init(), Kc.add(x), Sr((() => Ll.$stores.muted), (e => d.muted.set(e)), {
					immediate: !0
				}), e.viewport.visible.watch(m), d.muted.watchImmediate(y)
			},
			get masterVolume() {
				return u
			},
			getContext: () => n,
			getInput: () => i,
			play: w,
			pause: S,
			stop: M,
			playSound: T,
			stopSound: function(e, t = {}) {
				const n = l[e];
				if (!n) return;
				n.forEach((e => e.stop(t)))
			},
			preloadSound: function(e) {
				const t = Xk[e];
				if (!t) return;
				const i = t.path;
				return Lk(n, i)
			},
			setBgm: function(e) {
				p.setPreset(e)
			}
		};
	e.audio = e.game.audio = d;
	const p = function(e, t) {
			let n = Qk.nothing,
				i = !1;
			return {
				onUnlock: r,
				setPreset: function(e) {
					const t = Qk[e];
					t && t !== n && (n = t, a())
				},
				restart: function() {
					i && r()
				}
			};
			async function r() {
				const e = [];
				for (const n of Jk) e.push(t.preloadSound(n.id));
				await Promise.all(e);
				for (const n of Jk) t.stopSound(n.id), n.instance = t.playSound(n.id), n.baseVolume = n.instance.volume, n.targetVolume = n.baseVolume;
				i || (Kc.add(s), i = !0), a(!0)
			}

			function s() {
				for (const e of Jk) e.instance.volume !== e.targetVolume && (e.instance.volume = Uy(e.instance.volume, e.targetVolume, .025, .001))
			}

			function a(e) {
				for (const t of Jk) t.targetVolume = n.includes(t.type) ? t.baseVolume : 0, e && (t.instance.volume = t.targetVolume)
			}
		}(0, d),
		f = mN(e, d);

	function m(e) {
		n && (e ? (w(), h.fade = 1) : (S(), h.fade = 0), b())
	}

	function g(e) {
		n = e, i = e.createGain(), i.connect(e.destination)
	}

	function v() {
		M()
	}

	function _() {
		p.onUnlock(n), f.onUnlock(n)
	}

	function y(e) {
		h.mute = e ? 0 : 1
	}

	function x(e) {
		if (jk.isUnlocked()) {
			r = e;
			for (const t of c) t.timer -= e, t.timer <= 0 && (c.delete(t), T(t.id, t.opts));
			if (b(), !a)
				for (const e in l) l[e].forEach(o)
		}
	}

	function b() {
		const e = h;
		u = e.main * e.fade * e.mute, jk.setVolume(i, u)
	}

	function w() {
		if (a) {
			a = !1;
			for (const e in l) l[e].forEach((e => {
				e.loop || e.play()
			}))
		}
	}

	function S() {
		if (!a) {
			a = !0;
			for (const e in l) l[e].forEach((e => {
				e.loop || e.pause()
			}))
		}
	}

	function M() {
		for (const e in l) l[e].forEach((e => e.stop()))
	}

	function T(e, t = {}) {
		if (!jk.isUnlocked()) return;
		const n = Xk[e];
		if (!n) return;
		if (t.delay) {
			const n = t.delay;
			return delete t.delay, void c.add({
				id: e,
				opts: t,
				timer: n
			})
		}
		if (l[e] || (l[e] = new Set), n.unique && l[e].size > 0) {
			const t = l[e].values().next().value;
			return t.play(), t
		}
		if (t.id = e, t.path = n.path, t.onStop = C, t.autoplay = !0, t.loop = gN(t.loop, !!n.loop), t.fadein = t.fadein || n.fadein, t.fadeout = t.fadeout || n.fadeout, n.variations) {
			let e = t.variation && n.variations[t.variation - 1];
			e || (e = GA(n.variations)), t.start = gN(t.start, e.start), t.duration = gN(t.duration, e.duration), t.loopStart = gN(t.loopStart, gN(e.loopStart, t.start)), t.loopEnd = gN(t.loopEnd, gN(e.loopEnd, t.start + t.duration))
		} else t.start = gN(t.start, n.start), t.duration = gN(t.duration, n.duration), t.loopStart = gN(t.loopStart, gN(n.loopStart, t.start)), t.loopEnd = gN(t.loopEnd, gN(n.loopEnd, t.start + t.duration));
		var i, r;
		t.volume = gN(t.volume, gN(n.volume, 1)), t.playbackRate = n.randomRate ? (i = n.randomRate[0], r = n.randomRate[1], Math.random() * (r - i) + i) : null != t.playbackRate ? t.playbackRate : 1;
		const s = Ik.get(d, t);
		return l[e].add(s), s
	}

	function C(e) {
		const t = l;
		e.release();
		const n = t[e.id];
		n && n.delete(e)
	}
}

function _N(e) {
	let t, n;
	async function i() {
		const i = e.postprocess;
		n.update(), t.update(), i.update()
	}
	async function r() {
		const i = e.threeRenderer,
			r = e.postprocess;
		r.enabled && r.pingpong(), i.setRenderTarget(r.enabled ? r.buffers.main : null), i.clearDepth(), n.render(), t.render(), r.enabled && (r.bloom.enabled && r.renderBloom(r.buffers.main), i.setRenderTarget(null), r.render())
	}

	function s(t) {
		const n = Al(),
			i = e.renderer,
			r = e.threeRenderer,
			s = e.postprocess,
			a = e.scene,
			o = a.lightning,
			l = s.bloom,
			c = n.$device.type.mobile,
			u = r.capabilities.isWebGL2,
			h = "safari" === n.$device.browser,
			d = c || !u || h;
		switch (a.setNear(d ? .18 : .1), t) {
			case 5:
				i.setMaxPixelRatio(2), i.setMinPixelRatio(1.5), o.setShadowSize(256), o.toggleShadow(!0), a.setFar(d ? 150 : 200), l.resize(512, 512), l.enabled = !0, e.postprocess.enabled = !0;
				break;
			case 4:
				i.setMaxPixelRatio(c ? 1.6 : 1.75), i.setMinPixelRatio(c ? 1 : 1.2), o.setShadowSize(128), o.toggleShadow(!0), a.setFar(d ? 150 : 190), l.resize(512, 512), l.enabled = !0, e.postprocess.enabled = !0;
				break;
			case 3:
				i.setMaxPixelRatio(c ? 1.25 : 1.5), i.setMinPixelRatio(1), o.setShadowSize(64), o.toggleShadow(!0), a.setFar(d ? 150 : 175), l.resize(256, 256), l.enabled = !0, e.postprocess.enabled = !0;
				break;
			case 2:
				i.setMaxPixelRatio(c ? 1 : 1.15), i.setMinPixelRatio(1), o.setShadowSize(64), o.toggleShadow(!0), a.setFar(150), l.resize(256, 256), l.enabled = !0, e.postprocess.enabled = !0;
				break;
			case 1:
				i.setMaxPixelRatio(1), i.setMinPixelRatio(1), o.setShadowSize(4), o.toggleShadow(!1), a.setFar(150), l.resize(128, 128), l.enabled = !1, e.postprocess.enabled = !0;
				break;
			default:
				i.setMaxPixelRatio(1), i.setMinPixelRatio(1), o.setShadowSize(4), o.toggleShadow(!1), a.setFar(140), l.resize(128, 128), l.enabled = !1, e.postprocess.enabled = !1
		}
	}! function() {
		for (const e in kL) {
			const t = e.split("/").pop().slice(0, -".glsl".length);
			lS[t] = kL[e].default
		}
	}(), e.plugins.push(gD, vD, tR, yD, SD, qD, Mk, GD, vN), Object.assign(e, {
		init: async function() {
			const {
				renderer: t
			} = e;
			Object.assign(t.options, {
				precision: "highp",
				antialiased: !1,
				premultipliedAlpha: !1,
				stencil: !1
			}), e.time.clampTo60Fps = !0, t.init();
			const n = t.instance;
			aA(n), n.setClearColor(11184810), n.autoClear = !1, t.setMaxPixelRatio(1), n.shadowMap.enabled = !0, n.shadowMap.type = 2
		},
		start: async function() {
			n = e.background = new yA, t = e.scene = new RL, e.renderer.resize(), e.time.init(), e.postprocess.init(), e.audio.init(), e.prerender(), e.quality.current.watchImmediate(s)
		},
		load: async function() {
			return e.audio.preloadSound("Car_Engine_Loop_AirFlow"), e.assets.load()
		},
		update: i,
		render: r,
		prerender: async function() {
			i(), r()
		}
	})
}
const yN = function() {};
let xN = null;
var bN;
bN = async (e, t = {}) => {
	mx(Fx, (e => e.set(0, 0, 0, 0))), mx(aw, (e => e.setRGB(0, 0, 0))), mx(Cx, (e => e.setScalar(0))), mx(zx, (e => e.setScalar(0))), mx(kx, (e => e.setScalar(0))), mx(Tb, (e => e.set(0, 0, 0, "XYZ"))), mx(mb);
	const n = t,
		i = {},
		r = [!1, iA, tA, rA, sA].filter(Boolean),
		s = jp(),
		a = jp(),
		o = jp(),
		l = jp(),
		c = jp(),
		u = jp(),
		h = jp(),
		d = jp(),
		p = jp(),
		f = jp(),
		m = jp(),
		g = jp(),
		v = jp(),
		_ = jp(),
		y = jp(),
		x = jp(),
		b = {
			beforePluginsInstall: s,
			afterPluginsInstall: a,
			beforeInit: o,
			afterInit: l,
			beforeLoad: c,
			afterLoad: u,
			beforeStart: h,
			afterStart: d,
			beforePrerender: p,
			afterPrerender: f,
			beforeFrame: m,
			afterFrame: g,
			beforeUpdate: v,
			afterUpdate: _,
			beforeRender: y,
			afterRender: x
		};

	function w() {
		e.update(), e.render()
	}

	function S(t, n) {
		return t.install ? t.install(e, n) : "function" == typeof t ? t(e, n) : void 0
	}

	function M(t, n) {
		const i = e[t] || yN;
		if ("function" == typeof n) e[t] = n(i);
		else {
			const s = !!n,
				a = (r = t).charAt(0).toUpperCase() + r.slice(1),
				o = b["before" + a] || yN,
				l = b["after" + a] || yN;
			e[t] = s ? async function(e) {
				o.emit(), await i(e), l.emit()
			}: function(e) {
				o.emit(), i(e), l.emit()
			}
		}
		var r;
		return e[t]
	}
	return Object.assign(e, {
		options: n,
		state: i,
		plugins: r,
		hooks: b,
		init: function() {
			e.renderer.init()
		},
		load: yN,
		start: function() {
			e.renderer.resize(), e.time.init()
		},
		frame: w,
		update: yN,
		render: yN,
		prerender: w
	}), _N(e), M("load", !0), M("start", !0), M("frame"), M("update"), M("render"), M("init", (t => n => {
		o.emit(),
			function() {
				s.emit();
				const t = e.plugins.filter(Boolean);
				for (const e of t) {
					const t = Array.isArray(e);
					S(t ? e[0] : e, t ? e[1] : {})
				}
				a.emit()
			}(), t(n), l.emit()
	})), M("prerender", (e => t => {
		p.emit(), i.prerendering = !0, e(t), i.prerendering = !1, f.emit()
	})), await e.init(t), xN = e, e
}, Fl((async e => {
	kl = {}, await bN(kl, e)
}));
const wN = () => xN;

function SN(e = {}) {
	const t = bu();
	let n = {
		initialized: t,
		start: async function(e = {}) {
			await s.start(e)
		},
		post: function(e, t = {}) {
			t.type = e
		}
	};
	e.customize && (n = e.customize(n) || n);
	const i = n.init,
		r = n.load;
	n.init = e => (async function(e = {}) {
		i && (e = await i(e));
		await async function(e) {
			Rl = !0, Dl = e;
			for (const t of Il) await t(e);
			Il.length = 0
		}(e), s = wN(), t.resolve()
	}(e), t), n.load = async function(e = {}) {
		await t, r && (e = await r(e));
		await s.load(e)
	};
	let s = null;
	return n
}
let MN = null;

function TN(e = {}) {
	let t, n;
	const i = MN = {
		getElement: function() {
			return t
		},
		install: function(r) {
			const s = r.config.globalProperties;
			s.$webGL = i, r.provide("webGL", i), r.component("WebGL", hx), t = document.createElement("canvas"), n = SN({
				app: r,
				customize: e.bridge
			}), i.bridge = n, i.load = e => s.$preloader.task(n.load(e)), i.prerender = n.prerender, s.$preloader.task(n.init({
				canvas: t
			})), i.load({
				type: "main"
			}), s.$preloader.beforeExit(n.start), delete i.install
		}
	};
	return i
}
const CN = {
		key: 0,
		class: "cookie-consent"
	},
	EN = {
		class: "cookie-consent__inner"
	},
	AN = ["innerHTML"],
	PN = {
		class: "cookie-consent__buttons"
	},
	LN = ["innerHTML"],
	IN = ["innerHTML"],
	DN = {
		props: {
			textHtml: {
				type: String,
				default: "Accept cookies?"
			},
			acceptHtml: {
				type: String,
				default: "Accept"
			},
			declineHtml: {
				type: String,
				default: "Decline"
			},
			visible: {
				type: Boolean,
				default: !0
			}
		},
		emits: ["accept", "decline"],
		setup(e, {
			emit: t
		}) {
			const n = e,
				i = Yt("preloader"),
				r = Yt("stats"),
				s = void 0 !== typeof window,
				a = "cookieAccepted",
				o = function() {
					const e = document.cookie.match("(^|;)\\s*cookieAccepted\\s*=\\s*([^;]+)");
					return e ? !!+e.pop() : null
				}(),
				l = Tt(null !== o),
				c = Tt(o),
				u = Dt((() => (!i || void 0 !== typeof i.hidden && i.hidden) && !l.value && !!n.visible));

			function h() {
				const e = c.value;
				t(e ? "accept" : "decline"), e && r && r.init && r.init(), s && document.documentElement.classList.add("cookie-consent-hidden")
			}

			function d() {
				f(!0)
			}

			function p() {
				f(!1)
			}

			function f(e) {
				if (l.value) return;
				l.value = !0, c.value = !!e, h();
				let t = new Date(Date.now() + 5184e6);
				t = t.toUTCString(), document.cookie = [a + "=" + (e ? 1 : 0) + ";", "Path=/;", "SameSite=none;", "Secure; Expires=" + t].join(" ")
			}
			return l.value && h(), (e, t) => (pi(), _i(Xr, {
				name: "cookie-consent",
				appear: ""
			}, {
				default: Vt((() => [At(u) ? (pi(), vi("div", CN, [Mi("div", EN, [Mi("p", {
					class: "cookie-consent__description",
					innerHTML: n.textHtml
				}, null, 8, AN), Mi("div", PN, [Mi("button", {
					class: "cookie-consent__cta cookie-consent__cta--decline",
					onClick: p
				}, [Mi("p", {
					class: "cta__text",
					innerHTML: n.declineHtml
				}, null, 8, LN)]), Mi("button", {
					class: "cookie-consent__cta cookie-consent__cta--accept",
					onClick: d
				}, [Mi("p", {
					class: "cta__text",
					innerHTML: n.acceptHtml
				}, null, 8, IN)])])])])) : Pi("", !0)])),
				_: 1
			}))
		}
	};
export {
	Mh as $, vn as A, By as B, ki as C, tu as D, El as E, oi as F, Sr as G, y as H, Pi as I, pr as J, _d as K, Ty as L, zd as M, br as N, ni as O, _i as P, DN as Q, Ei as R, Cl as S, Pl as T, qs as U, Sl as V, Xo as W, jl as X, kc as Y, Ch as Z, zl as _, ys as a, Fh as a0, Ai as a1, wc as a2, ms as a3, jn as a4, cs as a5, Ri as a6, xu as a7, us as a8, Cu as a9, Iy as aa, Ha as ab, Dy as ac, dt as ad, ef as ae, qa as af, Jo as ag, Ry as b, xy as c, vc as d, Wy as e, $y as f, ax as g, ux as h, TN as i, Rc as j, vi as k, Mi as l, Ll as m, g as n, pi as o, Ut as p, Bt as q, Tt as r, Dt as s, Ti as t, At as u, Wa as v, Ol as w, _c as x, pn as y, Kc as z
};
